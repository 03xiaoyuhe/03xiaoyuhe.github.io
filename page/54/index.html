<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link rel="stylesheet" href="/css/custom.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="O3xiaoyuhe">
<meta property="og:url" content="http://example.com/page/54/index.html">
<meta property="og:site_name" content="O3xiaoyuhe">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="听">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/54/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>O3xiaoyuhe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">O3xiaoyuhe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/%E5%90%8E%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/%E5%90%8E%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:21" itemprop="dateModified" datetime="2024-11-13T22:44:21+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>后记</h1>
<p>从最初的想法开始，到断断续续完成这本书，再到树洞的热烈反响，我很激动，但也五味杂陈。原来在北大这个园子里，也有那么多人，对自己的本科生涯并不满意。而这里，可是囊括了中国非常优秀的一帮年轻人。所以问题出在哪里？我不知道。</p>
<p>我只是个籍籍无名的本科生呀，只是一个单纯的求学者，我的目标只是想快乐地、自由地、高质量地掌握那些专业知识，我想，正在看这本书的大多数本科生也是如此，谁想付出时间但却收效甚微呢？又是谁迫使大家带着痛苦去应付呢？我不知道。</p>
<p>我写这本书绝不是为了鼓励大家翘课自学，试问谁不想在课堂上和那么多优秀的同学济济一堂，热烈讨论呢？谁不想遇到问题直接找老师答疑解惑呢？谁不想辛苦学习的成果可以直接化作学校承认的学分绩点呢？可如果一个兢兢业业、按时到堂的学生收获的却是痛苦，而那个一学期只有考试会出席的学生却学得自得其乐，这公平吗？我不知道。</p>
<p>我只是不甘，不甘心这些通过高考战胜无数人进入高校的学子本可以收获一个更快乐的本科生涯，但现实却留给了他们遗憾。我反问自己，本科教育究竟应该带给我们什么呢？是学完所有这些课程吗？倒也未必，它也许只适合我这种nerd。但我觉得，本科教育至少得展现它应有的诚意，一种分享知识的诚意，一种以人为本的诚意，一种注重学生体验的诚意。它至少不应该是一种恶意，一种拼比知识的恶意，一种胜者为王的恶意，一种让人学无所得的恶意。但这一切能改变吗？我不知道。</p>
<p>我只知道我做了应该做的事情，学生们会用脚投票，树洞的关注量和回帖数证明了这样一份资料是有价值的，也道出了国内CS本科教育和国外的差距。也许这样的改变是微乎其微的，但别忘了我只是一个籍籍无名的本科生，是北大信科一千多名本科生中的普通一员，是中国几百万在读本科生中的一分子，如果有更多的人站出来，每个人做一点点，也许是分享一个帖子，也许是当一门课的助教，也许是精心设计一门课的lab，更或许是将来获得教职之后开设一门高质量的课程，出版一本经典的教材。本科教育真的有什么技术壁垒吗？我看未必，教育靠的是诚意，靠的是育人之心。</p>
<p>今天是2021年12月12日，我期待在不久的将来这个帖子会被遗忘，大家可以满心欢喜地选着自己培养方案上的课程，做着学校自行设计的各类编程实验，课堂没有签到也能济济一堂，学生踊跃地发言互动，大家的收获可以和努力成正比，那些曾经的遗憾和痛苦可以永远成为历史。我真的很期待那一天，真的真的真的很期待。</p>
<p align="right">PKUFlyingPig</p>
<p align="right">2021年12月12日写于燕园</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:20" itemprop="dateModified" datetime="2024-11-13T22:44:20+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>如何使用这本书</h1>
<p>随着贡献者的不断增多，本书的内容也不断扩展，想把书中所有的课程全部学完是不切实际也没有必要的，甚至会起到事倍功半的反效果，吃力而不讨好。为了更好地贴合读者，让这本书真正为你所用，我将读者按照需求大致分为了如下三类，大家可以结合切身实际，精准地规划属于自己的自学方案。</p>
<h2 id="初入校园">初入校园</h2>
<p>如果你刚刚进入大学校园或者还在低年级，并且就读的是计算机方向或者想要转到计算机方向，那么你很幸运，因为学习是你的本业，你可以有充足的时间和自由来学习自己感兴趣的东西，不会有工作的压力和生活的琐碎，不必过于纠结“学了有没有用”，“能不能找到工作”这类功利的想法。那么该如何安排自己的学业呢？我觉得首要的一点就是要打破在高中形成的“按部就班”式的被动学习。作为一个小镇做题家，我深知国内大部分高中会把大家一天当中的每一分钟都安排得满满当当，你只需要被动地跟着课表按部就班地完成一个个既定的任务。只要足够认真，结果都不会太差。但步入大学的校门，自由度一下子变大了许多。首先所有的课外时间基本都由你自由支配，没有人为你整理知识点，总结提纲，考试也不像高中那般模式化。如果你还抱着高中那种“乖学生”的心态，老老实实按部就班，结果未必如你所愿。因为专业培养方案未必就是合理，老师的教学未必就会负责，认真出席课堂未必就能听懂，甚至考试内容未必就和讲的有关系。说句玩笑话，你或许会觉得全世界都与你为敌，而你只能指望自己。</p>
<p>那么现状就是这么个现状，你想改变，也得先活过去，并且拥有足够的能力去质疑它。而在低年级，打好基础很重要。这里的基础是全方面的，课内的知识固然重要，但计算机很大程度上还是强调实践，因此有很多课本外的能力需要培养，而这恰恰是国内的计算机本科教育很欠缺的一点。我根据个人的体验总结出了下面几点建议，供大家参考。</p>
<p>其一就是了解如何写“优雅”的代码。国内的很多大一编程入门课都会讲成极其无聊的语法课，其效果还不如直接让学生看官方文档。事实上，在刚开始接触编程的时候，让学生试着去了解什么样的代码是优雅的，什么样的代码 “have bad taste” 是大有裨益的。一般来说，编程入门课会先介绍过程式编程（例如 C 语言）。但即便是面向过程编程，<strong>模块化</strong> 和 <strong>封装</strong> 的思想也极其重要。如果你只想着代码能在 OpenJudge 上通过，写的时候图省事，用大段的复制粘贴和臃肿的 main 函数，长此以往，你的代码质量将一直如此。一旦接触稍微大一点的项目，无尽的 debug 和沟通维护成本将把你吞没。因此，写代码时不断问自己，是否有大量重复的代码？当前函数是否过于复杂（Linux 提倡每个函数只需要做好一件事）？这段代码能抽象成一个函数吗？一开始你可能觉得很不习惯，甚至觉得这么简单的题需要如此大费周章吗？但记住好的习惯是无价的，C 语言初中生都能学会，凭什么公司要招你去当程序员呢？</p>
<p>学过面向过程编程后，大一下学期一般会讲面向对象编程（例如 C++ 或 Java）。这里非常推荐大家看 <a href="6031.md">MIT 6.031: Software Construction</a> 这门课的 Notes，会以 Java 语言（22年改用了 TypeScript 语言）为例非常详细地讲解如何写出“优雅”的代码。例如 Test-Driven 的开发、函数 Specification 的设计、异常的处理等等等等。除此之外，既然接触了面向对象，那么了解一些常见的设计模式也是很有必要的。因为国内的面向对象课程同样很容易变成极其无聊的语法课，让学生纠结于各种继承的语法，甚至出一些无聊的脑筋急转弯一样的题目，殊不知这些东西在地球人的开发中基本不会用到。面向对象的精髓是让学生学会自己将实际的问题抽象成若干类和它们之间的关系，而设计模式则是前人总结出来的一些精髓的抽象方法。这里推荐<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">大话设计模式</a> 这本书，写得非常浅显易懂。</p>
<p>其二就是尝试学习一些能提高生产力的工具和技能，例如 Git、Shell、Vim。这里强烈推荐学习 <a href="MIT-Missing-Semester.md">MIT missing semester</a> 这门课，也许一开始接触这些工具用起来会很不习惯，但强迫自己用，熟练之后开发效率会直线提高。此外，还有很多应用也能极大提高的你生产力。一条定律是：一切需要让手离开键盘的操作，都应该想办法去除。例如切换应用、打开文件、浏览网页这些都有相关插件可以实现快捷操作（例如 Mac 上的 <a target="_blank" rel="noopener" href="https://www.alfredapp.com/">Alfred</a>）。如果你发现某个操作每天都会用到，并且用时超过1秒，那就应该想办法把它缩减到0.1秒。毕竟以后数十年你都要和电脑打交道，形成一套顺滑的工作流是事半功倍的。最后，学会盲打！如果你还需要看着键盘打字，那么赶紧上网找个教程学会盲打，这将极大提高你的开发效率。</p>
<p>其三就是平衡好课内和自学。我们质疑现状，但也得遵守规则，毕竟绩点在保研中还是相当重要的。因此在大一，我还是建议大家尽量按照自己的课表学习，但辅以一些优质的课外资源。例如微积分线代可以参考 <a href="MITmaths.md">MIT 18.01/18.02</a> 和 <a href="MITLA.md">MIT 18.06</a> 的课程 Notes。假期可以通过 <a href="CS61A.md">UCB CS61A</a> 来学习 Python。同时做到上面第一、第二点说的，注重好的编程习惯和实践能力的培养。就个人经验，大一的数学课学分占比相当大，而且数学考试的内容方差是很大的，不同学校不同老师风格迥异，自学也许能让你领悟数学的本质，但未必能给你一个好成绩。因此考前最好有针对性地刷往年题，充分应试。</p>
<p>在升入大二之后，计算机方向的专业课将居多，此时大家可以彻底放飞自我，进入自学的殿堂了。具体可以参考 <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">一份仅供参考的CS学习规划</a>，这是我根据自己三年自学经历总结提炼出来的全套指南，每门课的特点以及为什么要上这门课我都做了简单的介绍。对于你课表上的每个课程，这份规划里应该都会有相应的国外课程，而且在质量上我相信基本是全方位的碾压。由于计算机方向的专业知识基本是一样的，而且高质量的课程会让你从原理上理解知识点，对于国内大多照本宣科式的教学来说基本是降维打击。一般来说只要考前将老师“辛苦”念了一学期的 PPT 拿来突击复习两天，取得一个不错的卷面分数并不困难。如果有课程大作业，则可以尽量将国外课程的 Lab 或者 Project 修改一番以应付课内的需要。我当时上操作系统课，发现老师还用着早已被国外学校淘汰的课程实验，便邮件老师换成了自己正在学习的 <a href="MIT6.S081.md">MIT 6.S081</a> 的 xv6 Project，方便自学的同时还无意间推动了课程改革。总之，灵活变通是第一要义，你的目标是用最方便、效率最高的方式掌握知识，所有与你这一目标违背的所谓规定都可以想方设法地去“糊弄”。凭着这份糊弄劲儿，我大三之后基本没有去过线下课堂（大二疫情在家呆了大半年），对绩点也完全没有影响。</p>
<p>最后，希望大家少点浮躁和功利，多一些耐心和追求。很多人发邮件问我自学需不需要很强的自制力，我觉得得关键得看你自己想要什么。如果你依然抱着会一门编程语言便能月薪过万的幻想，想分一杯互联网的红利，那么我说再多也是废话。其实我最初的自学并没有太多功利的想法，只是单纯的好奇和本能的求知欲。自学的过程也没有所谓的“头悬梁，锥刺股”，该吃吃，该玩玩，不知不觉才发现竟然攒下了这么多资料。现如今中美的对抗已然成为趋势，而我们还在“卑微”地“师夷长技”，感叹国外高质量课程的同时也时常会有一种危机感。这一切靠谁来改变呢？靠的是刚刚入行的你们。所以，加油吧，少年！</p>
<h2 id="删繁就简">删繁就简</h2>
<p>如果你已经本科毕业开始读研或者走上了工作岗位，亦或是从事着其他领域的工作想要利用业余时间转码，那么你也许并没有充足的业余时间来系统地学完 <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">一份仅供参考的CS学习规划</a> 里的内容，但又想弥补本科时期欠下的基础。考虑到这部分读者通常有一定的编程经验，入门课程没有必要再重复学习。而且从实用角度来说，由于工作的大体方向已经确定，确实没有太大必要对于每个计算机分支都有特别深入的研究，更应该侧重一些通用性的原则和技能。因此我结合自身经历，选取了个人感觉最重要也是质量最高的几门核心专业课，希望能更好地加深读者对计算机的理解。学完这些课程，无论你具体从事的是什么工作，我相信你将不可能沦为一个普通的调包侠，而是对计算机的底层运行逻辑有更深入的了解。</p>
<table>
<thead>
<tr>
<th>课程方向</th>
<th>课程名</th>
</tr>
</thead>
<tbody>
<tr>
<td>离散数学和概率论</td>
<td><a href="CS70.md">UCB CS70 : discrete Math and probability theory</a></td>
</tr>
<tr>
<td>数据结构与算法</td>
<td><a href="Algo.md">Coursera: Algorithms I &amp; II</a></td>
</tr>
<tr>
<td>软件工程</td>
<td><a href="6031.md">MIT 6.031: Software Construction</a></td>
</tr>
<tr>
<td>全栈开发</td>
<td><a href="mitweb.md">MIT web development course</a></td>
</tr>
<tr>
<td>计算机系统导论</td>
<td><a href="CSAPP(CMU%20CS15213).md">CMU CS15213: CSAPP</a></td>
</tr>
<tr>
<td>体系结构入门</td>
<td><a href="N2T.md">Coursera: Nand2Tetris</a></td>
</tr>
<tr>
<td>体系结构进阶</td>
<td><a href="CS61C.md">CS61C: Great Ideas in Computer Architecture</a></td>
</tr>
<tr>
<td>数据库原理</td>
<td><a href="Database-Systems(CMU%2015-445).md">CMU 15-445: Introduction to Database System</a></td>
</tr>
<tr>
<td>计算机网络</td>
<td><a href="topdown.md">Computer Networking: A Top-Down Approach</a></td>
</tr>
<tr>
<td>人工智能</td>
<td><a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CS50.md">Harvard CS50: Introduction to AI with Python</a></td>
</tr>
<tr>
<td>深度学习</td>
<td><a href="CS230.md">Coursera: Deep Learning</a></td>
</tr>
</tbody>
</table>
<h2 id="心有所属">心有所属</h2>
<p>如果你对于计算机领域的核心专业课都掌握得相当扎实，而且已经确定了自己的工作或研究方向，那么书中还有很多未在 <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">一份仅供参考的CS学习规划</a> 提到的课程供你探索。</p>
<p>随着贡献者的不断增多，左侧的目录中将不断增加新的分支，例如 <strong>机器学习进阶</strong> 和 <strong>机器学习系统</strong>。并且同一个分支下都有若干同类型课程，它们来自不同的学校，有着不同的侧重点和课程实验，例如 <strong>操作系统</strong> 分支下就包含了麻省理工、伯克利、南京大学还有哈工大四所学校的课程。如果你想深耕一个领域，那么学习这些同类的课程会给你不同的视角来看待类似的知识。同时，本书作者还计划联系一些相关领域的科研工作者来分享某个细分领域的科研学习路径，让 CS自学指南 在追求广度的同时，实现深度上的提高。</p>
<p>如果你想贡献这方面的内容，欢迎和作者邮件联系 <a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.en/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:19" itemprop="dateModified" datetime="2024-11-13T22:44:19+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><strong>How to Use This Book</strong></h1>
<p>As the number of contributors grows, the content of this book keeps expanding. It is impractical and unnecessary to try to complete all the courses in the book. Attempting to do so might even be counterproductive, resulting in effort without reward. To better align with our readers and make this book truly useful for you, I have roughly divided readers into the following three categories based on their needs. Everyone can plan their own self-study program accurately according to their actual situation.</p>
<h2 id="Freshmen"><strong>Freshmen</strong></h2>
<p>If you have just entered the university or are in the lower grades, and you are studying or planning to switch to computer science, then you are lucky. As studying is your main task, you have ample time and freedom to learn what you are interested in without the pressure of work and daily life. You needn’t be overly concerned with utilitarian thoughts like “is it useful” or “can it help me find a job”. So, how should you arrange your studies? The first point is to break away from the passive learning style formed in high school. As a small-town problem solver, I know that most Chinese high schools fill every minute of your day with tasks, and you just need to passively follow the schedule. As long as you are diligent, the results won’t be too bad. However, once you enter university, you have much more freedom. All your extracurricular time is yours to use, and no one will organize knowledge points or summarize outlines for you. Exams are not as formulaic as in high school. If you still hold the mentality of a “good high school student”, following everything step by step, the results may not be as expected. The professional training plan may not be reasonable, the teaching may not be responsible, attending classes may not guarantee understanding, and even the exam content may not relate to what was taught. Jokingly, you might feel that the whole world is against you, and you can only rely on yourself.</p>
<p>Given this reality, if you want to change it, you must first survive and have the ability to question it. In the lower grades, it’s important to lay a solid foundation. This foundation is comprehensive, covering both in-class knowledge and practical skills, which are often lacking in China’s undergraduate computer science education. Based on personal experience, I offer the following suggestions for your reference.</p>
<p>First, learn how to write “elegant” code. Many programming introductory courses in China can be extremely boring syntax classes, less effective than reading official documentation. Initially, letting students understand what makes code elegant and what constitutes “bad taste” is beneficial. Introductory courses usually start with procedural programming (like C language), but even here, the concepts of <strong>modularity</strong> and <strong>encapsulation</strong> are crucial. If you write code just to pass on OpenJudge, using lengthy copy-pasting and bloated main functions, your code quality will remain poor. For larger projects, endless debugging and maintenance costs will overwhelm you. So, constantly ask yourself, is there a lot of repetitive code? Is the current function too complex (Linux advocates each function should do only one thing)? Can this code be abstracted into a function? Initially, this may seem cumbersome for simple problems, but remember, good habits are invaluable. Even middle school students can master C language, so why should a company hire you as a software engineer?</p>
<p>After procedural programming, the second semester of the freshman year usually introduces object-oriented programming (like C++ or Java). I highly recommend <a href="6031.md">MIT 6.031: Software Construction</a> course notes, which use Java (switch to TypeScript after 2022) to explain how to write “elegant” code in detail, including Test-Driven development, function Specification design, exception handling, and more. Also, understanding common design patterns is necessary when learning object-oriented programming. Domestic object-oriented courses can easily become dull syntax classes, focusing on inheritance syntax and puzzling questions, neglecting that these are rarely used in real-world development. The essence of object-oriented programming is teaching students to abstract real problems into classes and their relationships, and design patterns are the essence of these abstractions. I recommend the book <a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">“Big Talk Design Patterns”</a>, which is very easy to understand.</p>
<p>Second, try to learn some productivity-enhancing tools and skills, such as Git, Shell, Vim. I strongly recommend the <a href="MIT-Missing-Semester.md">MIT missing semester</a> course. Initially, you may feel awkward, but force yourself to use them, and your development efficiency will skyrocket. Additionally, many applications can greatly increase your productivity. A rule of thumb is: any action that requires your hands to leave the keyboard should be eliminated. For example, switching applications, opening files, browsing the web - there are plugins for these (like <a target="_blank" rel="noopener" href="https://www.alfredapp.com/">Alfred</a> for Mac). If you find an daily operation that takes more than 1 second, try to reduce it to 0.1 seconds. After all, you’ll be dealing with computers for decades, so forming a smooth workflow can greatly enhance efficiency. Lastly, learn to touch type! If you still need to look at the keyboard while typing, find a tutorial online and learn to type without looking. This will significantly increase your development efficiency.</p>
<p>Third, balance coursework and self-learning. We feel angry about the institution but must also follow the rules, as GPA is still important for postgraduate recommendations. Therefore, in the first year, I suggest focusing on the curriculum, complemented by high-quality extracurricular resources. For example, for calculus and linear algebra, refer to <a href="MITmaths.md">MIT 18.01/18.02</a> and <a href="MITLA.md">MIT 18.06</a>. During holidays, learn Python through <a href="CS61A.md">UCB CS61A</a>. Also, focus on good programming habits and practical skills mentioned above. From my experience, mathematics courses matter a lot for your GPA in the first year, and the content of math exams varies greatly between different schools and teachers. Self-learning might help you understand the essence of mathematics, but it may not guarantee good grades. Therefore, it’s better to specifically practice past exams.</p>
<p>In your sophomore year, as computer science courses become the majority, you can fully immerse yourself in self-learning. Refer to <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">A Reference Guide for CS Learning</a>, a guide I created based on three years of self-learning, introducing each course and its importance. For every course in your curriculum, this guide should have a corresponding one, and I believe they are of higher quality. If there are course projects, try to adapt labs or projects from these self-learning courses. For example, I took an operating systems course and found the teacher was still using experiments long abandoned by UC Berkeley, so I emailed the teacher to switch to the <a href="MIT6.S081.md">MIT 6.S081</a> xv6 Project I was studying. This allowed me to self-learn while inadvertently promoting curriculum reform. In short, be flexible. Your goal is to master knowledge in the most convenient and efficient way. Anything that contradicts this goal can be “fudged” as necessary. With this attitude, after my junior year, I barely attended offline classes (I spent most of my sophomore year at home due to the pandemic), and it had no impact on my GPA.</p>
<p>Finally, I hope everyone can be less impetuous and more patient in their pursuit. Many ask if self-learning requires strong self-discipline. It depends on what you want. If you still hold the illusion that mastering a programming language will earn you a high salary and a share of the internet’s profits, then whatever I say is pointless. Initially, my motivation was out of pure curiosity and a natural desire for knowledge, not for utilitarian reasons. The process didn’t involve “extraordinary efforts”; I spent my days in college as usual and gradually accumulated this wealth of materials. Now, as the US-China confrontation becomes a trend, we still humbly learn techniques from the West. Who will change this? You, the newcomers. So, go for it, young man!</p>
<h2 id="Simplify-the-Complex"><strong>Simplify the Complex</strong></h2>
<p>If you have graduated and started postgraduate studies, or have begun working, or are in another field and want to learn coding in your spare time, you may not have enough time to systematically complete the materials in <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">A Reference Guide for CS Learning</a>, but still want to fill the gaps in your undergraduate foundation. Considering that these readers usually has some programming experience, there is no need to repeat introductory courses. From a practical standpoint, since the general direction of work is already determined, there is no need to deeply study every branch of computer science. Instead, focus on general principles and skills. Based on my own experience, I’ve selected the most important and highest quality core professional courses to deepen readers’ understanding of computer science. After completing these courses, regardless of your specific job, I believe you won’t just be an ordinary coder, but will have a deeper understanding of the underlying logic of computers.</p>
<table>
<thead>
<tr>
<th>Course Direction</th>
<th>Course Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Discrete Mathematics and Probability Theory</td>
<td><a href="CS70.md">UCB CS70: Discrete Math and Probability Theory</a></td>
</tr>
<tr>
<td>Data Structures and Algorithms</td>
<td><a href="Algo.md">Coursera: Algorithms I &amp; II</a></td>
</tr>
<tr>
<td>Software Engineering</td>
<td><a href="6031.md">MIT 6.031: Software Construction</a></td>
</tr>
<tr>
<td>Full-Stack Development</td>
<td><a href="mitweb.md">MIT Web Development Course</a></td>
</tr>
<tr>
<td>Introduction to Computer Systems</td>
<td><a href="mitweb.md">CMU CS15213: CSAPP</a></td>
</tr>
<tr>
<td>Introductory System Architecture</td>
<td><a href="N2T.md">Coursera: Nand2Tetris</a></td>
</tr>
<tr>
<td>Advanced System Architecture</td>
<td><a href="CS61C.md">CS61C: Great Ideas in Computer Architecture</a></td>
</tr>
<tr>
<td>Principles of Databases</td>
<td><a href="Database-Systems(CMU%2015-445).md">CMU 15-445: Introduction to Database Systems</a></td>
</tr>
<tr>
<td>Computer Networking</td>
<td><a href="topdown.md">Computer Networking: A Top-Down Approach</a></td>
</tr>
<tr>
<td>Artificial Intelligence</td>
<td><a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CS50.md">Harvard CS50: Introduction to AI with Python</a></td>
</tr>
<tr>
<td>Deep Learning</td>
<td><a href="CS230.md">Coursera: Deep Learning</a></td>
</tr>
</tbody>
</table>
<h2 id="Focused-and-Specialized"><strong>Focused and Specialized</strong></h2>
<p>If you have a solid grasp of the core professional courses in computer science and have already determined your work or research direction, then there are many courses in the book not mentioned in <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">A Reference Guide for CS Learning</a> for you to explore.</p>
<p>As the number of contributors increases, new branches such as <strong>Advanced Machine Learning</strong> and <strong>Machine Learning Systems</strong> will be added to the navigation bar. Under each branch, there are several similar courses from different schools with different emphases and experiments, such as the <strong>Operating Systems</strong> branch, which includes courses from MIT, UC Berkeley, Nanjing University, and Harbin Institute of Technology. If you want to delve into a field, studying these similar courses will give you different perspectives on similar knowledge. Additionally, I plan to contact researchers in related fields to share research learning paths in specific subfields, enhancing the depth of the CS Self-learning Guide while pursuing breadth.</p>
<p>If you want to contribute in this area, feel free to contact the author via email <a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/index/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:18" itemprop="dateModified" datetime="2024-11-13T22:44:18+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure markdown>
  ![Image title](./images/title.png){ width="600" }
</figure>
<h1>前言</h1>
<p><strong>最近更新：<a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/releases/tag/v1.1.0">Release v1.1.0</a> 已发布 🎉</strong></p>
<p>这是一本计算机的自学指南，也是对自己大学三年自学生涯的一个纪念。</p>
<p>这同时也是一份献给北大信科学弟学妹们的礼物。如果这本书能对你们的信科生涯有哪怕一丝一毫的帮助，都是对我极大的鼓励和慰藉。</p>
<p>本书目前包括了以下部分(如果你有其他好的建议，或者想加入贡献者的行列，欢迎邮件 <a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a> 或者在 issue 里提问)：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必学工具：IDE, 翻墙, StackOverflow, Git, GitHub, Vim, LaTeX, GNU Make, 实用工具 …</p>
</li>
<li class="lvl-2">
<p>环境配置：PC端以及服务器端开发环境配置、各类运维相关教材及资料 …</p>
</li>
<li class="lvl-2">
<p>经典书籍推荐：看过 CSAPP 这本书的同学一定感叹好书的重要，我将列举推荐自己看过的计算机领域的必看好书与资源链接。</p>
</li>
<li class="lvl-2">
<p><strong>国外高质量 CS 课程汇总</strong>：我将把我上过的所有高质量的国外 CS 课程分门别类进行汇总，并给出相关的自学建议，大部分课程都会有一个独立的仓库维护相关的资源以及我的作业实现。</p>
</li>
</ul>
<h2 id="梦开始的地方-——-CS61A">梦开始的地方 —— CS61A</h2>
<p>大一入学时我是一个对计算机一无所知的小白，装了几十个 G 的 Visual Studio 天天和 OJ 你死我活。凭着高中的数学底子我数学课学得还不错，但在专业课上对竞赛大佬只有仰望。提到编程我只会打开那笨重的 IDE，新建一个我也不知道具体是干啥的命令行项目，然后就是 <code>cin</code>, <code>cout</code>, <code>for</code> 循环，然后 CE, RE, WA 循环。当时的我就处在一种拼命想学好但不知道怎么学，课上认真听讲但题还不会做，课后做作业完全是用时间和它硬耗的痛苦状态。我至今电脑里还存着自己大一上学期计算概论大作业的源代码 —— 一个 1200 行的 C++ 文件，没有头文件、没有类、没有封装、没有 unit test、没有 Makefile、没有 Git，唯一的优点是它确实能跑，缺点是“能跑”的补集。我一度怀疑我是不是不适合学计算机，因为童年对于极客的所有想象，已经被我第一个学期的体验彻底粉碎了。</p>
<p>这一切的转机发生在我大一的寒假，我心血来潮想学习 Python。无意间看到知乎有人推荐了 CS61A 这门课，说是 UC Berkeley 的大一入门课程，讲的就是 Python。我永远不会忘记那一天，打开 <a target="_blank" rel="noopener" href="https://cs61a.org/">CS61A</a> 课程网站的那个瞬间，就像哥伦布发现了新大陆一样，我开启了新世界的大门。</p>
<p>我一口气 3 个星期上完了这门课，它让我第一次感觉到原来 CS 可以学得如此充实而有趣，原来这世上竟有如此精华的课程。</p>
<p>为避免有崇洋媚外之嫌，我单纯从一个学生的视角来讲讲自学 CS61A 的体验：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>独立搭建的课程网站: 一个网站将所有课程资源整合一体，条理分明的课程 schedule、所有 slides, hw, discussion 的文件链接、详细明确的课程给分说明、历年的考试题与答案。这样一个网站抛开美观程度不谈，既方便学生，也让资源公正透明。</p>
</li>
<li class="lvl-2">
<p>课程教授亲自编写的教材：CS61A 这门课的开课老师将MIT的经典教材 <em>Structure and Interpretation of Computer Programs</em> (SICP) 用Python这门语言进行改编（原教材基于 Scheme 语言），保证了课堂内容与教材内容的一致性，同时补充了更多细节，可以说诚意满满。而且全书开源，可以直接线上阅读。</p>
</li>
<li class="lvl-2">
<p>丰富到让人眼花缭乱的课程作业：14 个 lab 巩固随堂知识点，10 个 homework，还有 4 个代码量均上千行的 project。与大家熟悉的 OJ 和 Word 文档式的作业不同，所有作业均有完善的代码框架，保姆级的作业说明。每个 Project 都有详尽的 handout 文档、全自动的评分脚本。CS61A 甚至专门开发了一个<a target="_blank" rel="noopener" href="https://okpy.org/">自动化的作业提交评分系统</a>（据说还发了论文）。当然，有人会说“一个 project 几千行代码大部分都是助教帮你写好的，你还能学到啥？”。此言差矣，作为一个刚刚接触计算机，连安装 Python 都磕磕绊绊的小白来说，这样完善的代码框架既可以让你专注于巩固课堂上学习到的核心知识点，又能有“我才学了一个月就能做一个小游戏了！”的成就感，还能有机会阅读学习别人高质量的代码，从而为自己所用。我觉得在低年级，这种代码框架可以说百利而无一害。唯一的害也许是苦了老师和助教，因为开发这样的作业可想而知需要相当的时间投入。</p>
</li>
<li class="lvl-2">
<p>每周 Discussion 讨论课，助教会讲解知识难点和考试例题：类似于北京大学 ICS 的小班研讨，但习题全部用 LaTeX 撰写，相当规范且会明确给出 solution。</p>
</li>
</ul>
<p>这样的课程，你完全不需要任何计算机的基础，你只需要努力、认真、花时间就够了。此前那种有劲没处使的感觉，那种付出再多时间却得不到回报的感觉，从此烟消云散。这太适合我了，我从此爱上了自学。</p>
<p>试想如果有人能把艰深的知识点嚼碎嚼烂，用生动直白的方式呈现给你，还有那么多听起来就很 fancy，种类繁多的 project 来巩固你的理论知识，你会觉得他们真的是在倾尽全力想方设法地让你完全掌握这门课，你会觉得不学好它简直是对这些课程建设者的侮辱。</p>
<p>如果你觉得我在夸大其词，那么不妨从 <a target="_blank" rel="noopener" href="https://cs61a.org/">CS61A</a> 开始，因为它是我的梦开始的地方。</p>
<h2 id="为什么写这本书">为什么写这本书</h2>
<p>在我2020年秋季学期担任《深入理解计算机系统》（CSAPP）这门课的助教时，我已经自学一年多了。这一年多来我无比享受这种自学模式，为了分享这种快乐，我为自己的小班同学做过一个 <a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/Self-learning-Computer-Science">CS自学资料整理仓库</a>。当时纯粹是心血来潮，因为我也不敢公然鼓励大家翘课自学。</p>
<p>但随着又一年时间的维护，这个仓库的内容已经相当丰富，基本覆盖了计科、智能系、软工系的绝大多数课程，我也为每个课程都建了各自的 GitHub 仓库，汇总我用到的自学资料以及作业实现。</p>
<p>直到大四开始凑学分毕业的时候，我打开自己的培养方案，我发现它已经是我这个自学仓库的子集了，而这距离我开始自学也才两年半而已。于是，一个大胆的想法在我脑海中浮现：也许，我可以打造一个自学式的培养方案，把我这三年自学经历中遇到的坑、走过的路记录下来，以期能为后来的学弟学妹们贡献自己的一份微薄之力。</p>
<p>如果大家可以在三年不到的时间里就能建立起整座CS的基础大厦，能有相对扎实的数学功底和代码能力，经历过数十个千行代码量的 Project 的洗礼，掌握至少 C/C++/Java/JS/Python/Go/Rust 等主流语言，对算法、电路、体系、网络、操统、编译、人工智能、机器学习、计算机视觉、自然语言处理、强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、Web开发、云服务、超算等等方面均有涉猎。我想，你将有足够的底气和自信选择自己感兴趣的方向，无论是就业还是科研，你都将有相当的竞争力。</p>
<p>因为我坚信，既然你能坚持听我 BB 到这里，你一定不缺学好 CS 的能力，你只是没有一个好的老师，给你讲一门好的课程。而我，将力图根据我三年的体验，为你挑选这样的课程。</p>
<h2 id="自学的好处">自学的好处</h2>
<p>对我来说，自学最大的好处就在于可以完全根据自己的进度来调整学习速度。对于一些疑难知识点，我可以反复回看视频，在网上谷歌相关的内容，上 StackOverflow 提问题，直到完全将它弄明白。而对于自己掌握得相对较快的内容，则可以两倍速甚至三倍速略过。</p>
<p>自学的另一大好处就是博采众长。计算机系的几大核心课程：体系、网络、操统、编译，每一门我基本都上过不同大学的课程，不同的教材、不同的知识点侧重、不同的 project 将会极大丰富你的视野，也会让你理解错误的一些内容得到及时纠正。</p>
<p>自学的第三个好处是时间自由，具体原因省略。</p>
<h2 id="自学的坏处">自学的坏处</h2>
<p>当然，作为 CS 自学主义的忠实拥趸，我不得不承认自学也有它的坏处。</p>
<p>第一就是交流沟通的不便。我其实是一个很热衷于提问的人，对于所有没有弄明白的点，我都喜欢穷追到底。但当你面对着屏幕听到老师讲了一个你没明白的知识点的时候，你无法顺着网线到另一端向老师问个明白。我努力通过独立思考和善用 Google 来缓解这一点，但是，如果能有几个志同道合的伙伴结伴自学，那将是极好的。关于交流群的建立，大家可以参考仓库 <code>README</code> 中的教程。</p>
<p>第二就是这些自学的课程基本都是英文的。从视频到slides到作业全是英文，所以有一定的门槛。不过我觉得这个挑战如果你克服了的话对你是极为有利的。因为在当下，虽然我很不情愿，但也不得不承认，在计算机领域，很多优质的文档、论坛、网站都是全英文的。养成英文阅读的习惯，在赤旗插遍世界之前，还是有一定好处的（狗头保命）。</p>
<p>第三，也是我觉得最困难的一点，就是自律。因为没有 DDL 有时候真的是一件可怕的事情，特别是随着学习的深入，国外的很多课程是相当虐的。你得有足够的驱动力强迫自己静下心来，阅读几十页的 Project Handout，理解上千行的代码框架，忍受数个小时的 debug 时光。而这一切，没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。</p>
<h2 id="这本书适合谁">这本书适合谁</h2>
<p>正如我在前言里说的，任何有志于自学计算机的朋友都可以参考这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习。当然，如果你是一个像我当年一样对计算机一无所知的小白，初入大学的校门，我希望这本书能成为你的攻略，让你花最少的时间掌握你所需要的知识和能力。某种程度上，这本书更像是一个根据我的体验来排序的课程搜索引擎，帮助大家足不出户，体验世界顶级名校的计算机优质课程。</p>
<p>当然，作为一个还未毕业的本科生，我深感自己没有能力也没有权利去宣扬一种学习方式，我只是希望这份资料能让那些同样有自学之心和毅力朋友可以少走些弯路，收获更丰富、更多样、更满足的学习体验。</p>
<h2 id="特别鸣谢">特别鸣谢</h2>
<p>在这里，我怀着崇敬之心真诚地感谢所有将课程资源无偿开源的各位教授们。这些课程倾注了他们数十年教学生涯的积淀和心血，他们却选择无私地让所有人享受到如此高质量的CS教育。没有他们，我的大学生活不会这样充实而快乐。很多教授在我给他们发了感谢邮件之后，甚至会回复上百字的长文，真的让我无比感动。他们也时刻激励着我，做一件事，就得用心做好，无论是科研，还是为人。</p>
<h2 id="你也想加入到贡献者的行列">你也想加入到贡献者的行列</h2>
<p>一个人的力量终究是有限的，这本书也是我在繁重的科研之余熬夜抽空写出来的，难免有不够完善之处。另外，由于个人做的是系统方向，很多课程侧重系统领域，对于数学、理论计算机、高级算法相关的内容则相对少些。如果有大佬想在其他领域分享自己的自学经历与资源，可以直接在项目中发起 Pull Request，也欢迎和我邮件联系（<a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a>）。</p>
<h2 id="关于交流群的建立">关于交流群的建立</h2>
<p>方法参见仓库的 <code>README.md</code>。</p>
<h2 id="请作者喝杯下午茶">请作者喝杯下午茶</h2>
<p>本书的内容是完全开源免费的，如果你觉得该项目对你真的有帮助，可以给仓库点个 star 或者请作者喝一杯下午茶。</p>
<figure markdown>
  ![Image title](./images/sponsor.png){ width="500" }
</figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/index.en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/index.en/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:17" itemprop="dateModified" datetime="2024-11-13T22:44:17+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure markdown>
  ![Image title](./images/title.png){ width="600" }
</figure>
<h1><strong>Foreword</strong></h1>
<p>This is a self-learning guide to computer science, and a memento of my three years of self-learning at university.</p>
<p>It is also a gift to the young students at Peking University. It would be a great encouragement and comfort to me if this book could be of even the slightest help to you in your college life.</p>
<p>The book is currently organized to include the following sections (if you have other good suggestions, or would like to join the ranks of contributors, please feel free to email <a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a> or ask questions in the issue).</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Productivity Toolkit: IDE, VPN, StackOverflow, Git, Github, Vim, Latex, GNU Make and so on.</p>
</li>
<li class="lvl-2">
<p>Environment configuration: PC/Server development environment setup, DevOps tutorials and so on.</p>
</li>
<li class="lvl-2">
<p>Book recommendations: Those who have read the CSAPP must have realized the importance of good books. I will list links to books and resources in different areas of Computer Science that I find rewarding to read.</p>
</li>
<li class="lvl-2">
<p><strong>List of high quality CS courses</strong>: I will summarize all the high quality foreign CS courses I have taken into different categories and give relevant self-learning advice. Most of them will have a separate repository containing relevant resources as well as my homework/project implementations.</p>
</li>
</ul>
<h2 id="The-place-where-dreams-start-——-CS61A"><strong>The place where dreams start —— CS61A</strong></h2>
<p>In my freshman year, I was a novice who knew nothing about computers. I installed a giant IDE Visual Studio and fight with OJ every day. With my high school maths background, I did pretty well in maths courses, but I felt struggled to learn courses in my major. When it came to programming, all I could do was open up that clunky IDE, create a new project that I didn’t know exactly what it was for, and then <code>cin</code>, <code>cout</code>, <code>for</code> loops, and then CE, RE, WA loops. I was in a state where I was desperately trying to learn well but I didn’t know how to learn. I listened carefully in class but I couldn’t solve the homework problems. I spent almost all my spare time doing the homework after class, but the results were disappointing. I still retain the source code of the project for Introduction to Computing course —— a single 1200-line C++ file with no header files, no class abstraction, no unit tests, no makefile, no version control. The only good thing is that it can run, the disadvantage is the complement of “can run”. For a while I wondered if I wasn’t cut out for computer science, as all my childhood imaginings of geekiness had been completely ruined by my first semester’s experience.</p>
<p>It all turned around during the winter break of my freshman year, when I had a hankering to learn Python. I overheard someone recommend CS61A, a freshman introductory course at UC Berkeley on Python. I’ll never forget that day, when I opened the <a target="_blank" rel="noopener" href="https://cs61a.org/">CS61A</a> course website. It was like Columbus discovering a new continent, and I opened the door to a new world.</p>
<p>I finished the course in 3 weeks and for the first time I felt that CS could be so fulfilling and interesting, and I was shocked that there existed such a great course in the world.</p>
<p>To avoid any suspicion of pandering to foreign courses, I will tell you about my experience of studying CS61A from the perspective of a pure student.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em><strong>Course website developed by course staffs</strong></em>: The course website integrates all the course resources into one, with a well organised course schedule, links to all slides, recorded videos and homework, detailed and clear syllabus, list of exams and solutions from previous years. Aesthetics aside, this website is so convenient for students.</p>
</li>
<li class="lvl-2">
<p><em><strong>Textbook written by course instructor</strong></em>: The course instructor has adapted the classic MIT textbook <em>Structure and Interpretation of Computer Programs</em> (SICP) into Python (the original textbook was based on Scheme). This is a great way to ensure that the classroom content is consistent with the textbook, while adding more details. The entire book is open source and can be read directly online.</p>
</li>
<li class="lvl-2">
<p><em><strong>Various, comprehensive and interesting homework</strong></em>: There are 14 labs to reinforce the knowledge gained in class, 10 homework assignments to practice, and 4 projects each with thousands of lines of code, all with well-organized skeleton code and babysitting instructions. Unlike the old-school OJ and Word document assignments, each lab/homework/project has a detailed handout document, fully automated grading scripts, and CS61A staffs have even developed an <a target="_blank" rel="noopener" href="https://okpy.org/">automated assignment submission and grading system</a>. Of course, one might say “How much can you learn from a project where most of code are written by your teaching assistants?” . For someone who is new to CS and even stumbling over installing Python, this well-developed skeleton code allows students to focus on reinforcing the core knowledge they’ve learned in class, but also gives them a sense of achievement that they already can make a little game despite of learning Python only for a month. It also gives them the opportunity to read and learn from other people’s high quality code so that they can reuse it later. I think in the freshman year, this kind of skeleton code is absolutely beneficial. The only bad thing perhaps is for the instructors and teaching assistants, as developing such assignments can conceivably require a considerable time commitment.</p>
</li>
<li class="lvl-2">
<p><em><strong>Weekly discussion sessions</strong></em>: The teaching assistants will explain the difficult knowledge in class and add some supplementary materials which may not be covered in class. Also, there will be exercises from exams of previous years. All the exercises are written in LaTeX with solutions.</p>
</li>
</ul>
<p>In CS61A, You don’t need any prerequesites about CS at all. You just need to pay attention, spend time and work hard. The feeling that you do not know what to do, that you are not getting anything in return for all the time you put in, is gone. It suited me so well that I fell in love with self-learning.</p>
<p>Imagine that if someone could chew up the hard knowledge and present it to you in a vivid and straightforward way, with so many fancy and varied projects to reinforce your theoretical knowledge, you’d think they were really trying their best to make you fully grasp the course, and it was even an insult to the course builders not to learn it well.</p>
<p>If you think I’m exaggerating, start with <a target="_blank" rel="noopener" href="https://cs61a.org/">CS61A</a>, because it’s where my dreams began.</p>
<h2 id="Why-write-this-book"><strong>Why write this book?</strong></h2>
<p>In the 2020 Fall semester, I worked as a teaching assistant for the class “Introduction to Computer Systems” at Peking University. At that time, I had been studying totally on my own for over a year. I enjoyed this style of learning immensely. To share this joy, I have made a <a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/Self-learning-Computer-Science">CS Self-learning Materials List</a> for students in my seminar. It was purely on a whim at the time, as I wouldn’t dare to encourage my students to skip classes and study on their own.</p>
<p>But after another year of maintenance, the list has become quite comprehensive, covering most of the courses in Computer Science, Artificial Intelligence and Soft Engineering, and I have built separate repositories for each course, summarising the self-learning materials that I used.</p>
<p>In my last college year, when I opened up my curriculum book, I realized that it was already a subset of my self-learning list. By then, it was only two and a half years after I had started my self-learning journey. Then, a bold idea came to my mind: perhaps I could create a self-learning book, write down the difficulty I encountered and the interest I found during these years of self-learning, hoping to make it easy for students who may also enjoy self-learning to start their wonderful self-learning journey.</p>
<p>If you can build up the whole CS foundation in less than three years, have relatively solid mathematical skills and coding ability, experience dozens of projects with thousands of lines of code, master at least C/C++/Java/JS/Python/Go/Rust and other mainstream programming languages, have a good understanding of algorithms, circuits, architectures, networks, operating systems, compilers, artificial intelligence, machine learning, computer vision, natural language processing, reinforcement learning, cryptography, information theory, game theory, numerical analysis, statistics, distributed systems, parallel computing, database systems, computer graphics, web development, cloud computing, supercomputing etc. I think you will be confident enough to choose the area you are interested in, and you will be quite competitive in both industry and academia.</p>
<p>I firmly believe that if you have read to this line, you do not lack the ability and committment to learn CS well, you just need a good teacher to teach you a good course. And I will try my best to pick such courses for you, based on my three years of experience.</p>
<h2 id="Pros"><strong>Pros</strong></h2>
<p>For me, the biggest advantage of self-learning is that I can adjust the pace of learning entirely according to my own progress. For difficult parts, I can watch the videos over and over again, Google it online and ask questions on StackOverflow until I have it all figured out. For those that I mastered relatively quickly, I could skip them at twice or even three times the speed.</p>
<p>Another great thing about self-learning is that you can learn from different perspectives. I have taken core courses such as architectures, networking, operating systems, and compilers from different universities. Different instructors may have different views on the same knowledge, which will broaden your horizon.</p>
<p>A third advantage of self-learning is that you do not need to go to the class, listening to the boring lectures.</p>
<h2 id="Cons"><strong>Cons</strong></h2>
<p>Of course, as a big fan of self-learning, I have to admit that it has its disadvantages.</p>
<p>The first is the difficulty of communication. I’m actually a very keen questioner, and I like to follow up all the points I don’t understand. But when you’re facing a screen and you hear a teacher talking about something you don’t understand, you can’t go to the other end of the network and ask him or her for clarification. I try to mitigate this by thinking independently and making good use of Google, but it would be great to have a few friends to study together. You can refer to <code>README</code> for more information on participating a community group.</p>
<p>The second thing is that these courses are basically in English. From the videos to the slides to the assignments, all in English. You may struggle at first, but I think it’s a challenge that if you overcome, it will be extremely rewarding. Because at the moment, as reluctant as I am, I have to admit that in computer science, a lot of high quality documentation, forums and websites are all in English.</p>
<p>The third, and I think the most difficult one, is self-discipline. Because have no DDL can sometimes be a really scary thing, especially when you get deeper, many foreign courses are quite difficult. You have to be self-driven enough to force yourself to settle down, read dozens of pages of Project Handout, understand thousands of lines of skeleton code and endure hours of debugging time. With no credits, no grades, no teachers, no classmates, just one belief - that you are getting better.</p>
<h2 id="Who-is-this-book-for"><strong>Who is this book for?</strong></h2>
<p>As I said in the beginning, anyone who is interested in learning computer science on their own can refer to this book. If you already have some basic skills and are just interested in a particular area, you can selectively pick and choose what you are interested in to study. Of course, if you are a novice who knows nothing about computers like I did back then, and just begin your college journey, I hope this book will be your cheat sheet to get the knowledge and skills you need in the least amount of time. In a way, this book is more like a course search engine ordered according to my experience, helping you to learn high quality CS courses from the world’s top universities without leaving home.</p>
<p>Of course, as an undergraduate student who has not yet graduated, I feel that I am not in a position nor have the right to preach one way of learning. I just hope that this material will help those who are also self-motivated and persistent to gain a richer, more varied and satisfying college life.</p>
<h2 id="Special-thanks"><strong>Special thanks</strong></h2>
<p>I would like to express my sincere gratitude to all the professors who have made their courses public for free. These courses are the culmination of decades of their teaching careers, and they have chosen to selflessly make such a high quality CS education available to all. Without them, my university life would not have been as fulfilling and enjoyable. Many of the professors would even reply with hundreds of words in length after I had sent them a thank you email, which really touched me beyond words. They also inspired me all the time that if decide to do something, do it with all heart and soul.</p>
<h2 id="Want-to-join-as-a-contributor"><strong>Want to join as a contributor?</strong></h2>
<p>There is a limit to how much one person can do, and this book was written by me under a heavy research schedule, so there are inevitably imperfections. In addition, as I work in the area of systems, many of the courses focus on systems, and there is relatively little content related to advanced mathematics, computing theory, and advanced algorithms. If any of you would like to share your self-learning experience and resources in other areas, you can directly initiate a Pull Request in the project, or feel free to contact me by email (<a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a>).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.en/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:14" itemprop="dateModified" datetime="2024-11-13T22:44:14+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>A Reference Guide for CS Learning</h1>
<p>The field of computer science is vast and complex, with a seemingly endless sea of knowledge. Each specialized area can lead to limitless learning if pursued deeply. Therefore, a clear and definite study plan is very important. I’ve taken some detours in my years of self-study and finally distilled the following content for your reference.</p>
<p>Before you start learning, I highly recommend a popular science video series for beginners: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EW411u7th">Crash Course: Computer Science</a>. In just 8 hours, it vividly and comprehensively covers various aspects of computer science: the history of computers, how computers operate, the important modules that make up a computer, key ideas in computer science, and so on. As its slogan says, <em>Computers are not magic!</em> I hope that after watching this video, everyone will have a holistic perception of computer science and embark on the detailed and in-depth learning content below with interest.</p>
<h2 id="Essential-Tools">Essential Tools</h2>
<blockquote>
<p>As the saying goes: sharpening your axe will not delay your job of chopping wood. If you are a pure beginner in the world of computers, learning some tools will make you more efficient.</p>
</blockquote>
<p><strong>Learn to ask questions</strong>: You might be surprised that asking questions is the first one listed? I think in the open-source community, learning to ask questions is a very important ability. It involves two aspects. First, it indirectly cultivates your ability to solve problems independently, as the cycle of forming a question, describing it, getting answers from others, and then understanding the response is quite long. If you expect others to remotely assist you with every trivial issue, then the world of computers might not suit you. Second, if after trying, you still can’t solve a problem, you can seek help from the open-source community. But at that point, how to concisely explain your situation and goal to others becomes particularly important. I recommend reading the article <a target="_blank" rel="noopener" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How To Ask Questions The Smart Way</a>, which not only increases the probability and efficiency of solving your problems but also keeps those who provide answers in the open-source community in a good mood.</p>
<p><strong>Learn to be a hacker</strong>: <a href="MIT-Missing-Semester.md">MIT-Missing-Semester</a> covers many useful tools for a hacker and provides detailed usage instructions. I strongly recommend beginners to study this course. However, one thing to note is that the course occasionally refers to terms related to the development process. Therefore, it is recommended to study it at least after completing an introductory computer science course.</p>
<p><strong><a href="%E7%BF%BB%E5%A2%99.md">GFW</a></strong>: For well-known reasons, sites like Google and GitHub are not accessible in mainland China. However, in many cases, Google and StackOverflow can solve 99% of the problems encountered during development. Therefore, learning to use a VPN is almost an essential skill for a mainland CSer. (Considering legal issues, the methods provided in this book are only applicable to users with a Peking University email address).</p>
<p><strong>Command Line</strong>: Proficiency in using the command line is often overlooked or considered difficult to master, but in reality, it greatly enhances your flexibility and productivity as an engineer. <a target="_blank" rel="noopener" href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">The Art of Command Line</a> is a classic tutorial that started as a question on Quora, but with the contribution of many experts, it has become a top GitHub project with over 100,000 stars, translated into dozens of languages. The tutorial is not long, and I highly recommend everyone to read it repeatedly and internalize it through practice. Also, mastering shell script programming should not be overlooked, and you can refer to this <a target="_blank" rel="noopener" href="https://www.shellscript.sh/">tutorial</a>.</p>
<p><strong>IDE (Integrated Development Environment)</strong>: Simply put, it’s where you write your code. The importance of an IDE for a programmer goes without saying, but many IDEs are designed for large-scale projects and are quite bulky and overly feature-rich. Nowadays, some lightweight text editors with rich plugin ecosystems can basically meet the needs of daily lightweight programming. My personal favorites are VS Code and Sublime (the former has a very simple plugin configuration, while the latter is a bit more complex but aesthetically pleasing). Of course, for large projects, I would still use slightly heavier IDEs, such as Pycharm (Python), IDEA (Java), etc. (Disclaimer: all IDEs are the best in the world).</p>
<p><strong><a href="Vim.md">Vim</a></strong>: A command-line editor. Vim has a somewhat steep learning curve, but mastering it, I think, is very necessary because it will greatly improve your development efficiency. Most modern IDEs also support Vim plugins, allowing you to retain the coolness of a geek while enjoying a modern development environment.</p>
<p><strong><a href="Emacs.md">Emacs</a></strong>: A classic editor that stands alongside Vim, with equally high development efficiency and more powerful expandability. It can be configured as a lightweight editor or expanded into a custom IDE, and even more sophisticated tricks.</p>
<p><strong><a href="Git.md">Git</a></strong>: A version control tool for your project. Git, created by the father of Linux, Linus, is definitely one of the must-have tools for every CS student.</p>
<p><strong><a href="GitHub.md">GitHub</a></strong>: A code hosting platform based on Git. The world’s largest open-source community and a gathering place for CS experts.</p>
<p><strong><a href="GNU_Make.md">GNU Make</a></strong>: An engineering build tool. Proficiency in GNU Make will help you develop a habit of modularizing your code and familiarize you with the compilation and linking processes of large projects.</p>
<p><strong><a href="CMake.md">CMake</a></strong>: A more powerful build tool than GNU Make, recommended for study after mastering GNU Make.</p>
<p><strong><a href="LaTeX.md">LaTex</a></strong>: <del>Pretentious</del> Paper typesetting tool.</p>
<p><strong><a href="Docker.md">Docker</a></strong>: A lighter-weight software packaging and deployment tool compared to virtual machines.</p>
<p><strong><a href="tools.md">Practical Toolkit</a></strong>: In addition to the tools mentioned above that are frequently used in development, I have also collected many practical and interesting free tools, such as download tools, design tools, learning websites, etc.</p>
<p><strong><a href="thesis.md">Thesis</a></strong>: Tutorial for writing graduation thesis in Word.</p>
<h2 id="Recommended-Books">Recommended Books</h2>
<blockquote>
<p>I believe a good textbook should be people-oriented, rather than a display of technical jargon. It’s certainly important to tell readers “what it is,” but a better approach would be for the author to integrate decades of experience in the field into the book and narratively convey to the reader “why it is” and what should be done in the future.</p>
</blockquote>
<p><a href="%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90.md">Link here</a></p>
<h2 id="Environment-Setup">Environment Setup</h2>
<blockquote>
<p>What you think of as development — coding frantically in an IDE for hours.</p>
<p>Actual development — setting up the environment for several days without starting to code.</p>
</blockquote>
<h3 id="PC-Environment-Setup">PC Environment Setup</h3>
<p>If you are a Mac user, you’re in luck, as this <a target="_blank" rel="noopener" href="https://sourabhbajaj.com/mac-setup/">guide</a> will walk you through setting up the entire development environment. If you are a Windows user, thanks to the efforts of the open-source community, you can enjoy a similar experience with <a href="Scoop.md">Scoop</a>.</p>
<p>Additionally, you can refer to an <a target="_blank" rel="noopener" href="https://taylover2016.github.io/%E6%96%B0%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%EF%BC%88%E6%96%B0%E6%89%8B%E5%90%91%EF%BC%89/index.html">environment setup guide</a> inspired by <a href="MIT-Missing-Semester.md">6.NULL MIT-Missing-Semester</a>, focusing on terminal beautification. It also includes common software sources (such as GitHub, Anaconda, PyPI) for acceleration and replacement, as well as some IDE configuration and activation tutorials.</p>
<h3 id="Server-Side-Environment-Setup">Server-Side Environment Setup</h3>
<p>Server-side operation and maintenance require basic use of Linux (or other Unix-like systems) and fundamental concepts like processes, devices, networks, etc. Beginners can refer to the <a target="_blank" rel="noopener" href="https://101.lug.ustc.edu.cn/">Linux 101</a> online notes compiled by the Linux User Association of the University of Science and Technology of China. If you want to delve deeper into system operation and maintenance, you can refer to the <a target="_blank" rel="noopener" href="https://stevens.netmeister.org/615/">Aspects of System Administration</a> course.</p>
<p>Additionally, if you need to learn a specific concept or tool, I recommend a great GitHub project, <a target="_blank" rel="noopener" href="https://github.com/Tikam02/DevOps-Guide">DevOps-Guide</a>, which covers a lot of foundational knowledge and tutorials in the administration field, such as Docker, Kubernetes, Linux, CI-CD, GitHub Actions, and more.</p>
<h2 id="Course-Map">Course Map</h2>
<blockquote>
<p>As mentioned at the beginning of this chapter, this course map is merely a <strong>reference guide</strong> for course planning, from my perspective as an undergraduate nearing graduation. I am acutely aware that I neither have the right nor the capability to preach to others about “how one should learn”. Therefore, if you find any issues with the course categorization and selection below, I fully accept and deeply apologize for them. You can tailor your own course map in the next section <a href="#yourmap">Customize Your Own Course Map</a>.</p>
</blockquote>
<p>Apart from courses labeled as <em>basic</em> or <em>introductory</em>, there is no explicit sequence in the following categories. As long as you meet the prerequisites for a course, you are free to choose any course according to your needs and interests.</p>
<h3 id="Mathematical-Foundations">Mathematical Foundations</h3>
<h4 id="Calculus-and-Linear-Algebra">Calculus and Linear Algebra</h4>
<p>As a freshman, mastering calculus and linear algebra is as important as learning to code. This point has been reiterated countless times by predecessors, but I feel compelled to emphasize it again: mastering calculus and linear algebra is really important! You might complain that these subjects are forgotten after exams, but I believe that indicates a lack of deep understanding of their essence. If you find the content taught in class to be obscure, consider referring to MIT’s <a href="MITmaths.md">Calculus Course</a> and <a href="MITLA.md">18.06: Linear Algebra</a> course notes. For me, they greatly deepened my understanding of the essence of calculus and linear algebra. Also, I highly recommend the maths YouTuber <a target="_blank" rel="noopener" href="https://www.youtube.com/c/3blue1brown"><strong>3Blue1Brown</strong></a>, whose channel features videos explaining the core of mathematics with vivid animations, offering both depth and breadth of high quality.</p>
<h4 id="Introduction-to-Information-Theory">Introduction to Information Theory</h4>
<p>For computer science students, gaining some foundational knowledge in information theory early on is beneficial. However, most information theory courses are targeted towards senior or even graduate students, making them quite inaccessible to beginners. MIT’s <a href="information.md">6.050J: Information theory and Entropy</a> is tailored for freshmen, with almost no prerequisites, covering coding, compression, communication, information entropy, and more, which is very interesting.</p>
<h3 id="Advanced-Mathematics">Advanced Mathematics</h3>
<h4 id="Discrete-Mathematics-and-Probability-Theory">Discrete Mathematics and Probability Theory</h4>
<p>Set theory, graph theory, and probability theory are essential tools for algorithm derivation and proof, as well as foundations for more advanced mathematical courses. However, the teaching of these subjects often falls into a rut of being overly theoretical and formalistic, turning classes into mere recitations of theorems and conclusions without helping students grasp the essence of these theories. If theory teaching can be interspersed with examples of algorithm application, students can expand their algorithm knowledge while appreciating the power and charm of theory.</p>
<p><a href="CS70.md">UCB CS70: Discrete Math and Probability Theory</a> and <a href="CS126.md">UCB CS126: Probability Theory</a> are UC Berkeley’s probability courses. The former covers the basics of discrete mathematics and probability theory, while the latter delves into stochastic processes and more advanced theoretical content. Both emphasize the integration of theory and practice and feature abundant examples of algorithm application, with the latter including numerous Python programming assignments to apply probability theory to real-world problems.</p>
<h4 id="Numerical-Analysis">Numerical Analysis</h4>
<p>For computer science students, developing computational thinking is crucial. Modeling and discretizing real-world problems, and simulating and analyzing them on computers, are vital skills. Recently, the <a target="_blank" rel="noopener" href="https://julialang.org/">Julia</a> programming language, developed by MIT, has become popular in the field of numerical computation with its C-like speed and Python-friendly syntax. Many MIT mathematics courses have started using Julia as a teaching tool, presenting complex mathematical theories through clear and intuitive code.</p>
<p><a target="_blank" rel="noopener" href="https://computationalthinking.mit.edu/Spring21/">ComputationalThinking</a> is an introductory course in computational thinking offered by MIT. All course materials are open source and accessible on the course website. Using the Julia programming language, the course covers image processing, social science and data science, and climatology modeling, helping students understand algorithms, mathematical modeling, data analysis, interactive design, and graph presentation. The course content, though not difficult, profoundly impressed me with the idea that the allure of science lies not in obscure theories or jargon but in presenting complex concepts through vivid examples and concise, deep language.</p>
<p>After completing this experience course, if you’re still eager for more, consider MIT’s <a href="numerical.md">18.330: Introduction to Numerical Analysis</a>. This course also uses Julia for programming assignments but is more challenging and in-depth. It covers floating-point encoding, root finding, linear systems, differential equations, and more, with the main goal of using discrete computer representations to estimate and approximate continuous mathematical concepts. The course instructor has also written an accompanying open-source textbook, <a target="_blank" rel="noopener" href="https://fncbook.github.io/fnc/frontmatter.html">Fundamentals of Numerical Computation</a>, which includes abundant Julia code examples and rigorous formula derivations.</p>
<p>If you’re still not satisfied, MIT’s graduate course in numerical analysis, <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-335j-introduction-to-numerical-methods-spring-2019/index.htm">18.335: Introduction to Numerical Methods</a>, is also available for reference.</p>
<h4 id="Differential-Equations">Differential Equations</h4>
<p>Wouldn’t it be cool if the motion and development of everything in the world could be described and depicted with equations? Although differential equations are not a mandatory part of any CS curriculum, I believe mastering them provides a new perspective to view the world.</p>
<p>Since differential equations often involve complex variable functions, you can refer to <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-04-complex-variables-with-applications-spring-2018/">MIT18.04: Complex Variables Functions</a> course notes to fill in prerequisite knowledge.</p>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-03sc-differential-equations-fall-2011/unit-i-first-order-differential-equations/">MIT18.03: Differential Equations</a> mainly covers the solution of ordinary differential equations, and on this basis, <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-152-introduction-to-partial-differential-equations-fall-2011/index.htm">MIT18.152: Partial Differential Equations</a> dives into the modeling and solving of partial differential equations. With the powerful tool of differential equations, you will gain enhanced capabilities in modeling real-world problems and intuitively grasping the essence among various noisy variables.</p>
<h3 id="Advanced-Mathematical-Topics">Advanced Mathematical Topics</h3>
<p>As a computer science student, I often hear arguments about the uselessness of mathematics. While I neither agree nor have the authority to oppose such views, if everything is forcibly categorized as useful or useless, it indeed becomes quite dull. Therefore, the following advanced mathematics courses, aimed at senior and even graduate students, are available for those interested.</p>
<h4 id="Convex-Optimization">Convex Optimization</h4>
<p><a href="convex.md">Standford EE364A: Convex Optimization</a></p>
<h4 id="Information-Theory">Information Theory</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-441-information-theory-spring-2016/syllabus/">MIT6.441: Information Theory</a></p>
<h4 id="Applied-Statistics">Applied Statistics</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-443-statistics-for-applications-spring-2015/index.htm">MIT18.650: Statistics for Applications</a></p>
<h4 id="Elementary-Number-Theory">Elementary Number Theory</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-781-theory-of-numbers-spring-2012/index.htm">MIT18.781: Theory of Numbers</a></p>
<h4 id="Cryptography">Cryptography</h4>
<p><a target="_blank" rel="noopener" href="http://crypto.stanford.edu/~dabo/cs255/">Standford CS255: Cryptography</a></p>
<h3 id="Programming-Fundamentals">Programming Fundamentals</h3>
<blockquote>
<p>Languages are tools, and you choose the right tool for the right job. Since there’s no universally perfect tool, there’s no universally perfect language.</p>
</blockquote>
<h4 id="Shell">Shell</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="MIT-Missing-Semester.md">MIT-Missing-Semester</a></p>
</li>
</ul>
<h4 id="Python">Python</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS50P.md">CS50P: CS50’s Introduction to Programming with Python</a></p>
</li>
<li class="lvl-2">
<p><a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/CS50.md">Harvard CS50: This is CS50x</a></p>
</li>
<li class="lvl-2">
<p><a href="CS61A.md">UCB CS61A: Structure and Interpretation of Computer Programs</a></p>
</li>
</ul>
<h4 id="C">C++</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS106B_CS106X.md">Stanford CS106B/X: Programming Abstractions</a></p>
</li>
<li class="lvl-2">
<p><a href="CS106L.md">Stanford CS106L: Standard C++ Programming</a></p>
</li>
</ul>
<h4 id="Rust">Rust</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS110L.md">Stanford CS110L: Safety in Systems Programming</a></p>
</li>
</ul>
<h4 id="OCaml">OCaml</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://cs3110.github.io/textbook/cover.html">Cornell CS3110 textbook: Functional Programming in OCaml</a></p>
</li>
</ul>
<h3 id="Electronics-Fundamentals">Electronics Fundamentals</h3>
<h4 id="Basics-of-Circuits">Basics of Circuits</h4>
<p>For computer science students, understanding basic circuit knowledge and experiencing the entire pipeline from sensor data collection to data analysis and algorithm prediction can be very helpful for future learning and developing computational thinking. <a href="EE16.md">EE16A&amp;B: Designing Information Devices and Systems I&amp;II</a> at UC Berkeley are introductory courses for freshmen in electrical engineering. EE16A focuses on collecting and analyzing data from the real environment through circuits, while EE16B focuses on analyzing these collected data to make predictive actions.</p>
<h4 id="Signals-and-Systems">Signals and Systems</h4>
<p>Signals and Systems is a course I find very worthwhile. Initially, I studied it out of curiosity about Fourier Transform, but after completing it, I was amazed at how Fourier Transform provided a new perspective to view the world, just like differential equations, immersing you in the elegance and magic of precisely depicting the world with mathematics.</p>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-003-signals-and-systems-fall-2011/lecture-videos/lecture-1-signals-and-systems/">MIT 6.003: Signal and Systems</a> provides all course recordings, written assignments, and answers. You can also check out this course’s <a href="Signals_and_Systems_AVO.md">ancient version</a>.</p>
<p><a href="signal.md">UCB EE120: Signal and Systems</a> has very well-written notes on Fourier Transform and provides many interesting Python programming assignments to practically apply the theories and algorithms of signals and systems.</p>
<h3 id="Data-Structures-and-Algorithms">Data Structures and Algorithms</h3>
<p>Algorithms are the core of computer science and the foundation for almost all professional courses. How to abstract real-world problems into algorithmic problems mathematically and solve them under time and memory constraints using appropriate data structures is the eternal theme of algorithm courses. If you are fed up with your teacher’s rote teaching, I highly recommend UC Berkeley’s <a href="CS61B.md">UCB CS61B: Data Structures and Algorithms</a> and Princeton’s <a href="Algo.md">Coursera: Algorithms I &amp; II</a>. Both courses are taught in a deep yet simple manner and have rich and interesting programming experiments to integrate theory with knowledge.</p>
<p>Both of these courses are based on Java. If you prefer C/C++, you can refer to Stanford’s data structure and basic algorithm course <a href="CS106B_CS106X.md">Stanford CS106B/X: Programming Abstractions</a>. For those who prefer Python, you can learn MIT’s introductory algorithm course <a href="6.006.md">MIT 6.006: Introduction to Algorithms</a>.</p>
<p>For those interested in more advanced algorithms and NP problems, consider UC Berkeley’s course on algorithm design and analysis <a href="CS170.md">UCB CS170: Efficient Algorithms and Intractable Problems</a> or MIT’s advanced algorithms course <a href="6.046.md">MIT 6.046: Design and Analysis of Algorithms</a>.</p>
<h3 id="Software-Engineering">Software Engineering</h3>
<h4 id="Introductory-Course">Introductory Course</h4>
<p>There is a fundamental difference between “working” code and high-quality industrial code. Therefore, I highly recommend senior students to take <a href="6031.md">MIT 6.031: Software Construction</a>. Based on Java, this course teaches how to write high-quality code that is <strong>bug-resistant, clear, and easy to maintain and modify</strong> with rich and detailed reading materials and well-designed programming exercises. From macro data structure design to minor details like how to write comments, following these details and experiences summarized by predecessors can greatly benefit your future programming career.</p>
<h4 id="Professional-Course">Professional Course</h4>
<p>Of course, if you want to systematically take a software engineering course, I recommend UC Berkeley’s <a href="CS169.md">UCB CS169: Software Engineering</a>. However, unlike most software engineering courses, this course does not involve the traditional <strong>design and document</strong> model that emphasizes various class diagrams, flowcharts, and document design. Instead, it adopts the <strong>Agile Development</strong> model, which has become popular in recent years, featuring small team rapid iterations and the <strong>Software as a Service</strong> model using cloud platforms.</p>
<h3 id="Computer-Architecture">Computer Architecture</h3>
<h4 id="Introductory-Course-2">Introductory Course</h4>
<p>Since childhood, I’ve always heard that the world of computers is made of 0s and 1s, which I didn’t understand but was deeply impressed by. If you also have this curiosity, consider spending one to two months learning the barrier-free computer course <a href="N2T.md">Coursera: Nand2Tetris</a>. This comprehensive course starts from 0s and 1s, allowing you to build a computer by hand and run a Tetris game on it. It covers compilation, virtual machines, assembly, architecture, digital circuits, logic gates, etc., from top to bottom, from software to hardware. Its difficulty is carefully designed to omit many complex details of modern computers, extracting the most core essence, aiming to make it understandable to everyone. In lower levels, establishing a bird’s-eye view of the entire computer system is very beneficial.</p>
<h4 id="Professional-Course-2">Professional Course</h4>
<p>Of course, if you want to delve into the complex details of modern computer architecture, you still need to take a university-level course <a href="CS61C.md">UCB CS61C: Great Ideas in Computer Architecture</a>. This course emphasizes practice, and you will hand-write assembly to construct neural networks in projects, build a CPU from scratch, and more, all of which will give you a deeper understanding of computer architecture, beyond the monotony of “fetch, decode, execute, memory access, write back.”</p>
<h3 id="Introduction-to-Computer-Systems">Introduction to Computer Systems</h3>
<p>Computer systems are a vast and profound topic. Before delving into a specific area, having a macro conceptual understanding of each field and some general design principles will reinforce core and even philosophical concepts in your subsequent in-depth study, rather than being shackled by complex internal details and various tricks. In my opinion, the key to learning systems is to grasp these core concepts to design and implement your own systems.</p>
<p><a target="_blank" rel="noopener" href="http://web.mit.edu/6.033/www/">MIT6.033: System Engineering</a> is MIT’s introductory course to systems, covering topics like operating systems, networks, distributed systems, and system security. In addition to the theory, this course also teaches some writing and expression skills, helping you learn how to design, introduce, and analyze your own systems. The accompanying textbook <em>Principles of Computer System Design: An Introduction</em> is also very well written and recommended for reading.</p>
<p><a href="CSAPP(CMU%20CS15213).md">CMU 15-213: Introduction to Computer System</a> is CMU’s introductory systems course, covering architecture, operating systems, linking, parallelism, networks, etc., with both breadth and depth. The accompanying textbook <em>Computer Systems: A Programmer’s Perspective</em> is also of very high quality and strongly recommended for reading.</p>
<h3 id="Operating-Systems">Operating Systems</h3>
<blockquote>
<p>There’s nothing like writing your own kernel to deepen your understanding of operating systems.</p>
</blockquote>
<p>Operating systems provide a set of elegant abstractions to virtualize various complex underlying hardware, providing rich functional support for all application software. Understanding the design principles and internal mechanisms of operating systems is greatly beneficial for a programmer who is not satisfied with just being a coder. Out of love for operating systems, I have taken many operating system courses in different colleges, each with its own focus and merits. You can choose based on your interests.</p>
<p><a href="MIT6.S081.md">MIT 6.S081: Operating System Engineering</a>, offered by the famous PDOS lab at MIT, features 11 projects that modify an elegantly implemented Unix-like operating system xv6. This course made me realize that systems is not about reading PPTs; it’s about writing tens of thousands of lines of code.</p>
<p><a href="CS162.md">UCB CS162: Operating System</a>, UC Berkeley’s operating system course, uses the same Project as Stanford — an educational operating system, Pintos. As the teaching assistant for Peking University’s 2022 and 2023 Spring Semester Operating Systems Course, I introduced and improved this Project. The course resources are fully open-sourced, with details on <a target="_blank" rel="noopener" href="https://pku-os.github.io">the course website</a>.</p>
<p><a href="NJUOS.md">NJU: Operating System Design and Implementation</a>, offered by Professor Yanyan Jiang at Nanjing University, provides an in-depth and accessible explanation of various operating system concepts, combining a unique system perspective with rich code examples. All course content is in Chinese, making it very convenient for students.</p>
<p><a href="HITOS.md">HIT OS: Operating System</a>, taught by Professor Zhijun Li at Harbin Institute of Technology, is a Chinese course on operating systems. Based on the Linux 0.11 source code, the course places great emphasis on code practice, explaining the intricacies of operating systems from the student’s perspective.</p>
<h3 id="Parallel-and-Distributed-Systems">Parallel and Distributed Systems</h3>
<p>In recent years, the most common phrase heard in CS lectures is “Moore’s Law is coming to an end.” As single-core capabilities reach their limits, multi-core and many-core architectures are becoming increasingly important. The changes in hardware necessitate adaptations and changes in the upper-level programming logic. Writing parallel programs has nearly become a mandatory skill for programmers to fully utilize hardware performance. Meanwhile, the rise of deep learning has brought unprecedented demands on computing power and storage, making the deployment and optimization of large-scale clusters a hot topic.</p>
<h4 id="Parallel-Computing">Parallel Computing</h4>
<p><a href="CS149.md">CMU 15-418/Stanford CS149: Parallel Computing</a></p>
<h4 id="Distributed-Systems">Distributed Systems</h4>
<p><a href="MIT6.824.md">MIT 6.824: Distributed System</a></p>
<h3 id="System-Security">System Security</h3>
<p>Whether you chose computer science because of a youthful dream of becoming a hacker, the reality is that becoming a hacker is a long and difficult journey.</p>
<h4 id="Theoretical-Courses">Theoretical Courses</h4>
<p><a href="CS161.md">UCB CS161: Computer Security</a> at UC Berkeley covers stack attacks, cryptography, website security, network security, and more.</p>
<p><a href="CSE365.md">ASU CSE365: Introduction to Cybersecurity</a> at Arizona State University focuses mainly on injections, assembly, and cryptography.</p>
<p><a href="CSE466.md">ASU CSE466: Computer Systems Security</a> at Arizona State University covers a wide range of topics in system security. It has a high barrier to entry, requiring familiarity with Linux, C, and Python.</p>
<p><a href="SEEDLabs.md">SU SEED Labs</a> at Syracuse University, supported by a $1.3 million grant from the NSF, has developed hands-on experimental exercises (called SEED Labs) for cybersecurity education. The course emphasizes both theoretical teaching and practical exercises, including detailed open-source lectures, video tutorials, textbooks (printed in multiple languages), and a ready-to-use virtual machine and Docker-based attack-defense environment. This project is currently used by 1,050 institutions worldwide and covers a wide range of topics in computer and information security, including software security, network security, web security, operating system security, and mobile app security.</p>
<h4 id="Practical-Courses">Practical Courses</h4>
<p>After mastering this theoretical knowledge, it’s essential to cultivate and hone these “hacker skills” in practice. <a target="_blank" rel="noopener" href="https://ctf-wiki.org/">CTF competitions</a> are a popular way to comprehensively test your understanding and application of computer knowledge in various fields. Peking University also successfully held the <a target="_blank" rel="noopener" href="https://geekgame.pku.edu.cn/">0th and 1st editions</a>, encouraging participation to improve skills through practice. Here are some resources I use for learning (and relaxing):</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/">CTF-wiki</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf101.org/">CTF-101</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf.hacker101.com/">Hacker-101</a></p>
</li>
</ul>
<h3 id="Computer-Networks">Computer Networks</h3>
<blockquote>
<p>There’s nothing like writing your own TCP/IP protocol stack to deepen your understanding of computer networks.</p>
</blockquote>
<p>The renowned <a href="CS144.md">Stanford CS144: Computer Network</a> includes 8 projects that guide you in implementing the entire TCP/IP protocol stack.</p>
<p>If you’re just looking to understand computer networks theoretically, I recommend the famous networking textbook “A Top-Down Approach” and its accompanying learning resources <a href="topdown.md">Computer Networking: A Top-Down Approach</a>.</p>
<h3 id="Database-Systems">Database Systems</h3>
<blockquote>
<p>There’s nothing like building your own relational database to deepen your understanding of database systems.</p>
</blockquote>
<p>CMU’s famous database course <a href="Database-Systems(CMU%2015-445).md">CMU 15-445: Introduction to Database System</a> guides you through 4 projects to add various functionalities to the educational relational database <a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">bustub</a>. The experimental evaluation framework is also open-source, making it very suitable for self-learning. The course experiments also use many new features of C<ins>11, offering a great opportunity to strengthen C</ins> coding skills.</p>
<p>Berkeley, as the birthplace of the famous open-source database PostgreSQL, has its own course [UCB CS186: Introduction to Database System](Introduction%20to%20Database%20System(.md) where you will implement a relational database in Java that supports SQL concurrent queries, B+ tree indexing, and fault recovery.</p>
<h3 id="Compiler-Theory">Compiler Theory</h3>
<blockquote>
<p>There’s nothing like writing your own compiler to deepen your understanding of compilers.</p>
</blockquote>
<p><a href="CS143.md">Stanford CS143: Compilers</a> guides you through the process of writing a compiler.</p>
<h3 id="Web-Development">Web Development</h3>
<p>Front-end development is often overlooked in computer science curricula, but mastering these skills has many benefits, such as building your personal website or creating an impressive presentation website for your course projects.</p>
<h4 id="Two-Week-Crash-Course">Two-Week Crash Course</h4>
<p><a href="mitweb.md">MIT web development course</a></p>
<h4 id="Systematic-Study-Version">Systematic Study Version</h4>
<p><a href="CS142.md">Stanford CS142: Web Applications</a></p>
<h3 id="Computer-Graphics">Computer Graphics</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS148.md">Stanford CS148</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES101.md">Games101</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES103.md">Games103</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES202.md">Games202</a></p>
</li>
</ul>
<h3 id="Data-Science">Data Science</h3>
<p>Data science, machine learning, and deep learning are closely related, with a focus on practical application. Berkeley’s <a href="Data100.md">UCB Data100: Principles and Techniques of Data Science</a> lets you master various data analysis tools and algorithms through extensive programming exercises. The course guides you through extracting desired results from massive datasets and making predictions about future data or user behavior. For those looking to learn industrial-level data mining and analysis techniques, Stanford’s big data mining course <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs246/">CS246: Mining Massive Data Sets</a> is an option.</p>
<h3 id="Artificial-Intelligence">Artificial Intelligence</h3>
<p>Artificial intelligence has been one of the hottest fields in computer science over the past decade. If you’re not content with just hearing about AI advancements in the media and want to delve into the subject, I highly recommend Harvard’s renowned CS50 series AI course <a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CS50.md">Harvard CS50: Introduction to AI with Python</a>. The course is concise and covers several major branches of traditional AI, supplemented with rich and interesting Python programming exercises to reinforce your understanding of AI algorithms. However, the content is somewhat simplified for online learners and doesn’t delve into deep mathematical theories. For a more systematic and in-depth study, consider an undergraduate-level course like Berkeley’s <a href="CS188.md">UCB CS188: Introduction to Artificial Intelligence</a>. This course’s projects feature the classic game “Pac-Man,” allowing you to use AI algorithms to play the game, which is very fun.</p>
<h3 id="Machine-Learning">Machine Learning</h3>
<p>The most significant recent progress in the field of machine learning is the emergence of deep learning, a branch based on deep neural networks. However, many algorithms based on statistical learning are still widely used in data analysis. If you’re new to machine learning and don’t want to get bogged down in complex mathematical proofs, start with Andrew Ng’s (Enda Wu) <a href="ML.md">Coursera: Machine Learning</a>. This course is well-known in the field of machine learning, and Enda Wu, with his profound theoretical knowledge and excellent presentation skills, makes many complex algorithms accessible and practical. The accompanying assignments are also of high quality, helping you get started quickly.</p>
<p>However, completing this course will only give you a general understanding of the field of machine learning. To truly understand the mathematical principles behind these “magical” algorithms or to engage in related research, you need a more “mathematical” course, such as <a href="CS229.md">Stanford CS229: Machine Learning</a> or <a href="CS189.md">UCB CS189: Introduction to Machine Learning</a>.</p>
<h3 id="Deep-Learning">Deep Learning</h3>
<p>The popularity of AlphaGo a few years ago brought deep learning to the public eye, leading many universities to establish related majors. Many other areas of computer science also use deep learning technology for research, so regardless of your field, you will likely encounter some needs related to neural networks and deep learning. For a quick introduction, I again recommend Andrew Ng’s (Enda Wu) <a href="CS230.md">Coursera: Deep Learning</a>, a top-rated course on Coursera. Additionally, if you find English-language courses challenging, consider Professor Hongyi Li’s course <a href="LHY.md">National Taiwan University: Machine Learning</a>. Although titled “Machine Learning,” this course covers almost all areas of deep learning and is very comprehensive, making it suitable for getting a broad overview of the field. The professor is also very humorous, with frequent witty remarks in class.</p>
<p>Due to the rapid development of deep learning, there are now many research branches. For further in-depth study, consider the following representative courses:</p>
<h3 id="Computer-Vision">Computer Vision</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="EECS498-007.md">UMich EECS 498-007 / 598-005: Deep Learning for Computer Vision</a></p>
</li>
<li class="lvl-2">
<p><a href="CS231.md">Stanford CS231n: CNN for Visual Recognition</a></p>
</li>
</ul>
<h3 id="Natural-Language-Processing">Natural Language Processing</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS224n.md">Stanford CS224n: Natural Language Processing</a></p>
</li>
</ul>
<h3 id="Graph-Neural-Networks">Graph Neural Networks</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS224w.md">Stanford CS224w: Machine Learning with Graphs</a></p>
</li>
</ul>
<h3 id="Reinforcement-Learning">Reinforcement Learning</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS285.md">UCB CS285: Deep Reinforcement Learning</a></p>
</li>
</ul>
<h2 id="Customize-Your-Course-Map">Customize Your Course Map</h2>
<blockquote>
<p>Better to teach fishing than to give fish.</p>
</blockquote>
<p>The course map above inevitably carries strong personal preferences and may not suit everyone. It is more intended to serve as a starting point for exploration. If you want to select your own areas of interest for study, you can refer to the following resources:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/">MIT OpenCourseWare</a>: MIT’s open-sharing project for course resources, featuring thousands of courses from various disciplines, including computer science courses numbered <a target="_blank" rel="noopener" href="http://6.xxx">6.xxx</a>.</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="http://student.mit.edu/catalog/m6a.html">MIT CS Course List</a>: List of CS courses at MIT.</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://hkn.eecs.berkeley.edu/courseguides">UC Berkeley EECS Course Map</a>: UC Berkeley’s EECS curriculum plan, presenting the categories and prerequisites of various courses in a course map format, most of which are included in this book.</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www2.eecs.berkeley.edu/Courses/CS/">UC Berkeley CS Course List</a>: List of CS courses at UC Berkeley.</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41220023/article/details/81976967">Stanford CS Course List</a>: List of CS courses at Stanford.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/docs/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/docs/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:15" itemprop="dateModified" datetime="2024-11-13T22:44:15+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>一个仅供参考的 CS 学习规划</h1>
<p>计算机领域方向庞杂，知识浩如烟海，每个细分领域如果深究下去都可以说学无止境。因此，一个清晰明确的学习规划是非常重要的。我在多年自学的尝试中也走过不少弯路，最终提炼出了下面的内容，供大家参考。</p>
<p>不过，在开始学习之前，先向小白们强烈推荐一个科普向系列视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EW411u7th">Crash Course: Computer Science</a>，在短短 8 个小时里非常生动且全面地科普了关于计算机科学的方方面面：计算机的历史、计算机是如何运作的、组成计算机的各个重要模块、计算机科学中的重要思想等等等等。正如它的口号所说的 <em>Computers are not magic!</em>，希望看完这个视频之后，大家能对计算机科学有个全貌性地感知，从而怀着兴趣去面对下面浩如烟海的更为细致且深入的学习内容。</p>
<h2 id="必学工具">必学工具</h2>
<blockquote>
<p>俗话说：磨刀不误砍柴工。如果你是一个刚刚接触计算机的24k纯小白，学会一些工具将会让你事半功倍。</p>
</blockquote>
<p>学会提问：也许你会惊讶，提问也算计算机必备技能吗，还放在第一条？我觉得在开源社区中，学会提问是一项非常重要的能力，它包含两方面的事情。其一是会变相地培养你自主解决问题的能力，因为从形成问题、描述问题并发布、他人回答、最后再到理解回答这个周期是非常长的，如果遇到什么鸡毛蒜皮的事情都希望别人最好远程桌面手把手帮你完成，那计算机的世界基本与你无缘了。其二，如果真的经过尝试还无法解决，可以借助开源社区的帮助，但这时候如何通过简洁的文字让别人瞬间理解你的处境以及目的，就显得尤为重要。推荐阅读<a target="_blank" rel="noopener" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a>这篇文章，这不仅能提高你解决问题的概率和效率，也能让开源社区里无偿提供解答的人们拥有一个好心情。</p>
<p><a href="MIT-Missing-Semester.md">MIT-Missing-Semester</a> 这门课覆盖了这些工具中绝大部分，而且有相当详细的使用指导，强烈建议小白学习。不过需要注意的一点是，在课程中会不时提到一些与开发流程相关的术语。因此推荐至少在学完计算机导论级别的课程之后进行学习。</p>
<p><a href="%E7%BF%BB%E5%A2%99.md">翻墙</a>：由于一些众所周知的原因，谷歌、GitHub 等网站在大陆无法访问。然而很多时候，谷歌和 StackOverflow 可以解决你在开发过程中遇到的 99% 的问题。因此，学会翻墙几乎是一个内地 CSer 的必备技能。（考虑到法律问题，这个文档提供的翻墙方式仅对拥有北大邮箱的用户适用）。</p>
<p>命令行：熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会极大地提高你作为工程师的灵活性以及生产力。<a target="_blank" rel="noopener" href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a>是一份非常经典的教程，它源于 Quora 的一个提问，但在各路大神的贡献努力下已经成为了一个 GitHub 十万 stars 的顶流项目，被翻译成了十几种语言。教程不长，非常建议大家反复通读，在实践中内化吸收。同时，掌握 Shell 脚本编程也是一项不容忽视的技术，可以参考这个<a target="_blank" rel="noopener" href="https://www.shellscript.sh/">教程</a>。</p>
<p>IDE (Integrated Development Environment)：集成开发环境，说白了就是你写代码的地方。作为一个码农，IDE 的重要性不言而喻，但由于很多 IDE 是为大型工程项目设计的，体量较大，功能也过于丰富。其实如今一些轻便的文本编辑器配合丰富的插件生态基本可以满足日常的轻量编程需求。个人常用的编辑器是 VS Code 和 Sublime（前者的插件配置非常简单，后者略显复杂但颜值很高）。当然对于大型项目我还是会采用略重型的 IDE，例如 Pycharm (Python)，IDEA (Java) 等等（免责申明：所有的 IDE 都是世界上最好的 IDE）。</p>
<p><a href="Vim.md">Vim</a>：一款命令行编辑工具。这是一个学习曲线有些陡峭的编辑器，不过学会它我觉得是非常有必要的，因为它将极大地提高你的开发效率。现在绝大多数 IDE 也都支持 Vim 插件，让你在享受现代开发环境的同时保留极客的炫酷（yue）。</p>
<p><a href="Emacs.md">Emacs</a>：与 Vim 齐名的经典编辑器，同样具有极高的开发效率，同时具有更为强大的扩展性，它既可以配置为一个轻量编辑器，也可以扩展成一个个人定制的 IDE，甚至可以有更多奇技淫巧。</p>
<p><a href="Git.md">Git</a>：一款代码版本控制工具。Git的学习曲线可能更为陡峭，但出自 Linux 之父 Linus 之手的 Git 绝对是每个学 CS 的童鞋必须掌握的神器之一。</p>
<p><a href="GitHub.md">GitHub</a>：基于 Git 的代码托管平台。全世界最大的代码开源社区，大佬集聚地。</p>
<p><a href="GNU_Make.md">GNU Make</a>：一款工程构建工具。善用 GNU Make 会让你养成代码模块化的习惯，同时也能让你熟悉一些大型工程的编译链接流程。</p>
<p><a href="CMake.md">CMake</a>：一款功能比 GNU Make 更为强大的构建工具，建议掌握 GNU Make 之后再加以学习。</p>
<p><a href="LaTeX.md">LaTex</a>：<del>逼格提升</del> 论文排版工具。</p>
<p><a href="Docker.md">Docker</a>：一款相较于虚拟机更轻量级的软件打包与环境部署工具。</p>
<p><a href="tools.md">实用工具箱</a>：除了上面提到的这些在开发中使用频率极高的工具之外，我还收集了很多实用有趣的免费工具，例如一些下载工具、设计工具、学习网站等等。</p>
<p><a href="thesis.md">Thesis</a>：毕业论文 Word 写作教程。</p>
<h2 id="好书推荐">好书推荐</h2>
<blockquote>
<p>私以为一本好的教材应当是以人为本的，而不是炫技式的理论堆砌。告诉读者“是什么”固然重要，但更好的应当是教材作者将其在这个领域深耕几十年的经验融汇进书中，向读者娓娓道来“为什么”以及未来应该“怎么做”。</p>
</blockquote>
<p><a href="%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90.md">链接戳这里</a></p>
<h2 id="环境配置">环境配置</h2>
<blockquote>
<p>你以为的开发 —— 在 IDE 里疯狂码代码数小时。</p>
<p>实际上的开发 —— 配环境配几天还没开始写代码。</p>
</blockquote>
<h3 id="PC-端环境配置">PC 端环境配置</h3>
<p>如果你是 Mac 用户，那么你很幸运，这份<a target="_blank" rel="noopener" href="https://sourabhbajaj.com/mac-setup/">指南</a> 将会手把手地带你搭建起整套开发环境。如果你是 Windows 用户，在开源社区的努力下，你同样可以获得与其他平台类似的体验：<a href="Scoop.md">Scoop</a>。</p>
<p>另外大家可以参考一份灵感来自 <a href="MIT-Missing-Semester.md">6.NULL MIT-Missing-Semester</a> 的 <a target="_blank" rel="noopener" href="https://taylover2016.github.io/%E6%96%B0%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%EF%BC%88%E6%96%B0%E6%89%8B%E5%90%91%EF%BC%89/index.html">环境配置指南</a>，重点在于终端的美化配置。此外还包括常用软件源（如 GitHub, Anaconda, PyPI 等）的加速与替换以及一些 IDE 的配置与激活教程。</p>
<h3 id="服务器端环境配置">服务器端环境配置</h3>
<p>服务器端的运维需要掌握 Linux（或者其他类 Unix 系统）的基本使用以及进程、设备、网络等系统相关的基本概念，小白可以参考中国科学技术大学 Linux 用户协会编写的<a target="_blank" rel="noopener" href="https://101.lug.ustc.edu.cn/">《Linux 101》在线讲义</a>。如果想深入学习系统运维相关的知识，可以参考 <a target="_blank" rel="noopener" href="https://stevens.netmeister.org/615/">Aspects of System Administration</a> 这门课程。</p>
<p>另外，如果需要学习某个具体的概念或工具，推荐一个非常不错的 GitHub 项目 <a target="_blank" rel="noopener" href="https://github.com/Tikam02/DevOps-Guide">DevOps-Guide</a>，其中涵盖了非常多的运维方面的基础知识和教程，例如 Docker, Kubernetes, Linux, CI-CD, GitHub Actions 等等。</p>
<h2 id="课程地图">课程地图</h2>
<blockquote>
<p>正如这章开头提到的，这份课程地图仅仅是一个<strong>仅供参考</strong>的课程规划，我作为一个临近毕业的本科生。深感自己没有权利也没有能力向别人宣扬“应该怎么学”。因此如果你觉得以下的课程分类与选择有不合理之处，我全盘接受，并深感抱歉。你可以在下一节<a href="#yourmap">定制属于你的课程地图</a></p>
</blockquote>
<p>以下课程类别中除了含有 <em>基础</em> 和 <em>入门</em> 字眼的以外，并无明确的先后次序，大家只要满足某个课程的先修要求，完全可以根据自己的需要和喜好选择想要学习的课程。</p>
<h3 id="数学基础">数学基础</h3>
<h4 id="微积分与线性代数">微积分与线性代数</h4>
<p>作为大一新生，学好微积分线代是和写代码至少同等重要的事情，相信已经有无数的前人经验提到过这一点，但我还是要不厌其烦地再强调一遍：学好微积分线代真的很重要！你也许会吐槽这些东西岂不是考完就忘，那我觉得你是并没有把握住它们本质，对它们的理解还没有达到刻骨铭心的程度。如果觉得老师课上讲的内容晦涩难懂，不妨参考 MIT 的 <a href="MITmaths.md">Calculus Course</a> 和 <a href="MITLA.md">18.06: Linear Algebra</a> 的课程 notes，至少于我而言，它帮助我深刻理解了微积分和线性代数的许多本质。顺道再安利一个油管数学网红 <a target="_blank" rel="noopener" href="https://www.youtube.com/c/3blue1brown"><strong>3Blue1Brown</strong></a>，他的频道有很多用生动形象的动画阐释数学本质内核的视频，兼具深度和广度，质量非常高。</p>
<h4 id="信息论入门">信息论入门</h4>
<p>作为计算机系的学生，及早了解一些信息论的基础知识，我觉得是大有裨益的。但大多信息论课程都面向高年级本科生甚至研究生，对新手极不友好。而 MIT 的 <a href="information.md">6.050J: Information theory and Entropy</a> 这门课正是为大一新生量身定制的，几乎没有先修要求，涵盖了编码、压缩、通信、信息熵等等内容，非常有趣。</p>
<h3 id="数学进阶">数学进阶</h3>
<h4 id="离散数学与概率论">离散数学与概率论</h4>
<p>集合论、图论、概率论等等是算法推导与证明的重要工具，也是后续高阶数学课程的基础。但我觉得这类课程的讲授很容易落入理论化与形式化的窠臼，让课堂成为定理结论的堆砌，而无法使学生深刻把握理论的本质，进而造成学了就背，考了就忘的怪圈。如果能在理论教学中穿插算法运用实例，学生在拓展算法知识的同时也能窥见理论的力量和魅力。</p>
<p><a href="CS70.md">UCB CS70 : discrete Math and probability theory</a> 和 <a href="CS126.md">UCB CS126 : Probability theory</a> 是 UC Berkeley 的概率论课程，前者覆盖了离散数学和概率论基础，后者则涉及随机过程以及深入的理论内容。两者都非常注重理论和实践的结合，有丰富的算法实际运用实例，后者还有大量的 Python 编程作业来让学生运用概率论的知识解决实际问题。</p>
<h4 id="数值分析">数值分析</h4>
<p>作为计算机系的学生，培养计算思维是很重要的，实际问题的建模、离散化，计算机的模拟、分析，是一项很重要的能力。而这两年开始风靡的，由 MIT 打造的 <a target="_blank" rel="noopener" href="https://julialang.org/">Julia</a> 编程语言以其 C 一样的速度和 Python 一样友好的语法在数值计算领域有一统天下之势，MIT 的许多数学课程也开始用 Julia 作为教学工具，把艰深的数学理论用直观清晰的代码展示出来。</p>
<p><a target="_blank" rel="noopener" href="https://computationalthinking.mit.edu/Spring21/">ComputationalThinking</a> 是 MIT 开设的一门计算思维入门课，所有课程内容全部开源，可以在课程网站直接访问。这门课利用 Julia 编程语言，在图像处理、社会科学与数据科学、气候学建模三个 topic 下带领学生理解算法、数学建模、数据分析、交互设计、图例展示，让学生体验计算与科学的美妙结合。内容虽然不难，但给我最深刻的感受就是，科学的魅力并不是故弄玄虚的艰深理论，不是诘屈聱牙的术语行话，而是用直观生动的案例，用简练深刻的语言，让每个普通人都能理解。</p>
<p>上完上面的体验课之后，如果意犹未尽的话，不妨试试 MIT 的 <a href="numerical.md">18.330 : Introduction to numerical analysis</a>，这门课的编程作业同样会用 Julia 编程语言，不过难度和深度上都上了一个台阶。内容涉及了浮点编码、Root finding、线性系统、微分方程等等方面，整门课的主旨就是让你利用离散化的计算机表示去估计和逼近一个数学上连续的概念。这门课的教授还专门撰写了一本配套的开源教材 <a target="_blank" rel="noopener" href="https://fncbook.github.io/fnc/frontmatter.html">Fundamentals of Numerical Computation</a>，里面附有丰富的 Julia 代码实例和严谨的公式推导。</p>
<p>如果你还意犹未尽的话，还有 MIT 的数值分析研究生课程 <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-335j-introduction-to-numerical-methods-spring-2019/index.htm">18.335: Introduction to numerical method</a> 供你参考。</p>
<h4 id="微分方程">微分方程</h4>
<p>如果世间万物的运动发展都能用方程来刻画和描述，这是一件多么酷的事情呀！虽然几乎任何一所学校的 CS 培养方案中都没有微分方程相关的必修课程，但我还是觉得掌握它会赋予你一个新的视角来审视这个世界。</p>
<p>由于微分方程中往往会用到很多复变函数的知识，所以大家可以参考 <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-04-complex-variables-with-applications-spring-2018/">MIT18.04: Complex variables functions</a> 的课程 notes 来补齐先修知识。</p>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-03sc-differential-equations-fall-2011/unit-i-first-order-differential-equations/">MIT18.03: differential equations</a> 主要覆盖了常微分方程的求解，在此基础之上 <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-152-introduction-to-partial-differential-equations-fall-2011/index.htm">MIT18.152: Partial differential equations</a> 则会深入偏微分方程的建模与求解。掌握了微分方程这一有力工具，相信对于你的实际问题的建模能力以及从众多噪声变量中把握本质的直觉都会有很大帮助。</p>
<h3 id="数学高阶">数学高阶</h3>
<p>作为计算机系的学生，我经常听到数学无用论的论断，对此我不敢苟同但也无权反对，但若凡事都硬要争出个有用和无用的区别来，倒也着实无趣，因此下面这些面向高年级甚至研究生的数学课程，大家按兴趣自取所需。</p>
<h4 id="凸优化">凸优化</h4>
<p><a href="convex.md">Standford EE364A: Convex Optimization</a></p>
<h4 id="信息论">信息论</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-441-information-theory-spring-2016/syllabus/">MIT6.441: Information Theory</a></p>
<h4 id="应用统计学">应用统计学</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-443-statistics-for-applications-spring-2015/index.htm">MIT18.650: Statistics for Applications</a></p>
<h4 id="初等数论">初等数论</h4>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/mathematics/18-781-theory-of-numbers-spring-2012/index.htm">MIT18.781: Theory of Numbers</a></p>
<h4 id="密码学">密码学</h4>
<p><a target="_blank" rel="noopener" href="http://crypto.stanford.edu/~dabo/cs255/">Standford CS255: Cryptography</a></p>
<h3 id="编程入门">编程入门</h3>
<blockquote>
<p>Languages are tools, you choose the right tool to do the right thing. Since there’s no universally perfect tool, there’s no universally perfect language.</p>
</blockquote>
<h4 id="Shell">Shell</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="MIT-Missing-Semester.md">MIT-Missing-Semester</a></p>
</li>
</ul>
<h4 id="Python">Python</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS50P.md">CS50P: CS50’s Introduction to Programming with Python</a></p>
</li>
<li class="lvl-2">
<p><a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/CS50.md">Harvard CS50: This is CS50x</a></p>
</li>
<li class="lvl-2">
<p><a href="CS61A.md">UCB CS61A: Structure and Interpretation of Computer Programs</a></p>
</li>
</ul>
<h4 id="C">C++</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS106B_CS106X.md">Stanford CS106B/X: Programming Abstractions</a></p>
</li>
<li class="lvl-2">
<p><a href="CS106L.md">Stanford CS106L: Standard C++ Programming</a></p>
</li>
</ul>
<h4 id="Rust">Rust</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS110L.md">Stanford CS110L: Safety in Systems Programming</a></p>
</li>
</ul>
<h4 id="OCaml">OCaml</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://cs3110.github.io/textbook/cover.html">Cornell CS3110 textbook: Functional Programming in OCaml</a></p>
</li>
</ul>
<h3 id="电子基础">电子基础</h3>
<h4 id="电路基础">电路基础</h4>
<p>作为计算机系的学生，了解一些基础的电路知识，感受从传感器收集数据到数据分析再到算法预测整条流水线，对于后续知识的学习以及计算思维的培养还是很有帮助的。<a href="EE16.md">EE16A&amp;B: Designing Information Devices and Systems I&amp;II</a> 是伯克利 EE 学生的大一入门课，其中 EE16A 注重通过电路从实际环境中收集和分析数据，而 EE16B 则侧重从这些收集到的数据进行分析并做出预测行为。</p>
<h4 id="信号与系统">信号与系统</h4>
<p>信号与系统是一门我觉得非常值得一上的课，最初学它只是为了满足我对傅里叶变换的好奇，但学完之后我才不禁感叹，傅立叶变换给我提供了一个全新的视角去看待这个世界，就如同微分方程一样，让你沉浸在用数学去精确描绘和刻画这个世界的优雅与神奇之中。</p>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-003-signals-and-systems-fall-2011/lecture-videos/lecture-1-signals-and-systems/">MIT 6.003: signal and systems</a> 提供了全部的课程录影、书面作业以及答案。也可以去看这门课的<a href="Signals_and_Systems_AVO.md">远古版本</a></p>
<p>而 <a href="signal.md">UCB EE120: Signal and Systems</a> 关于傅立叶变换的 notes 写得非常好，并且提供了6 个非常有趣的 Python 编程作业，让你实践中运用信号与系统的理论与算法。</p>
<h3 id="数据结构与算法">数据结构与算法</h3>
<p>算法是计算机科学的核心，也是几乎一切专业课程的基础。如何将实际问题通过数学抽象转化为算法问题，并选用合适的数据结构在时间和内存大小的限制下将其解决是算法课的永恒主题。如果你受够了老师的照本宣科，那么我强烈推荐伯克利的 <a href="CS61B.md">UCB CS61B: Data Structures and Algorithms</a> 和普林斯顿的 <a href="Algo.md">Coursera: Algorithms I &amp; II</a>，这两门课的都讲得深入浅出并且会有丰富且有趣的编程实验将理论与知识结合起来。</p>
<p>以上两门课程都是基于 Java 语言，如果你想学习 C/C++ 描述的版本，可以参考斯坦福的数据结构与基础算法课程 <a href="CS106B_CS106X.md">Stanford CS106B/X: Programming Abstractions</a>。偏好 Python 的同学可以学习 MIT 的算法入门课 <a href="6.006.md">MIT 6.006: Introduction to Algorithms</a></p>
<p>对一些更高级的算法以及 NP 问题感兴趣的同学可以学习伯克利的算法设计与分析课程 <a href="CS170.md">UCB CS170: Efficient Algorithms and Intractable Problems</a> 或者 MIT 的高阶算法 <a href="6.046.md">MIT 6.046: Design and Analysis of Algorithms</a>。</p>
<h3 id="软件工程">软件工程</h3>
<h4 id="入门课">入门课</h4>
<p>一份“能跑”的代码，和一份高质量的工业级代码是有本质区别的。因此我非常推荐低年级的同学学习一下 <a href="6031.md">MIT 6.031: Software Construction</a> 这门课，它会以 Java 语言为基础，以丰富细致的阅读材料和精心设计的编程练习传授如何编写<strong>不易出 bug、简明易懂、易于维护修改</strong>的高质量代码。大到宏观数据结构设计，小到如何写注释，遵循这些前人总结的细节和经验，对于你此后的编程生涯大有裨益。</p>
<h4 id="专业课">专业课</h4>
<p>当然，如果你想系统性地上一门软件工程的课程，那我推荐的是伯克利的 <a href="CS169.md">UCB CS169: software engineering</a>。但需要提醒的是，和大多学校（包括贵校）的软件工程课程不同，这门课不会涉及传统的 <strong>design and document</strong> 模式，即强调各种类图、流程图及文档设计，而是采用近些年流行起来的小团队快速迭代 <strong>Agile Develepment</strong> 开发模式以及利用云平台的 <strong>Software as a service</strong> 服务模式。</p>
<h3 id="体系结构">体系结构</h3>
<h4 id="入门课-2">入门课</h4>
<p>从小我就一直听说，计算机的世界是由 01 构成的，我不理解但大受震撼。如果你的内心也怀有这份好奇，不妨花一到两个月的时间学习 <a href="N2T.md">Coursera: Nand2Tetris</a> 这门无门槛的计算机课程。这门麻雀虽小五脏俱全的课程会从 01 开始让你亲手造出一台计算机，并在上面运行俄罗斯方块小游戏。一门课里涵盖了编译、虚拟机、汇编、体系结构、数字电路、逻辑门等等从上至下、从软至硬的各类知识，非常全面。难度上也是通过精心的设计，略去了众多现代计算机复杂的细节，提取出了最核心本质的东西，力图让每个人都能理解。在低年级，如果就能从宏观上建立对整个计算机体系的鸟瞰图，是大有裨益的。</p>
<h4 id="专业课-2">专业课</h4>
<p>当然，如果想深入现代计算机体系结构的复杂细节，还得上一门大学本科难度的课程 <a href="CS61C.md">UCB CS61C: Great Ideas in Computer Architecture</a>。UC Berkeley 作为 RISC-V 架构的发源地，在体系结构领域算得上首屈一指。其课程非常注重实践，你会在 Project 中手写汇编构造神经网络，从零开始搭建一个 CPU，这些实践都会让你对计算机体系结构有更为深入的理解，而不是仅停留于“取指译码执行访存写回”的单调背诵里。</p>
<h3 id="系统入门">系统入门</h3>
<p>计算机系统是一个庞杂而深刻的主题，在深入学习某个细分领域之前，对各个领域有一个宏观概念性的理解，对一些通用性的设计原则有所知晓，会让你在之后的深入学习中不断强化一些最为核心乃至哲学的概念，而不会桎梏于复杂的内部细节和各种 trick。因为在我看来，学习系统最关键的还是想让你领悟到这些最核心的东西，从而能够设计和实现出属于自己的系统。</p>
<p><a target="_blank" rel="noopener" href="http://web.mit.edu/6.033/www/">MIT6.033: System Engineering</a> 是 MIT 的系统入门课，主题涉及了操作系统、网络、分布式和系统安全，除了知识点的传授外，这门课还会讲授一些写作和表达上的技巧，让你学会如何设计并向别人介绍和分析自己的系统。这本书配套的教材 <em>Principles of Computer System Design: An Introduction</em> 也写得非常好，推荐大家阅读。</p>
<p><a href="CSAPP(CMU%20CS15213).md">CMU 15-213: Introduction to Computer System</a> 是 CMU 的系统入门课，内容覆盖了体系结构、操作系统、链接、并行、网络等等，兼具广度和深度，配套的教材 <em>Computer Systems: A Programmer’s Perspective</em> 也是质量极高，强烈建议阅读。</p>
<h3 id="操作系统">操作系统</h3>
<blockquote>
<p>没有什么能比自己写个内核更能加深对操作系统的理解了。</p>
</blockquote>
<p>操作系统作为各类纷繁复杂的底层硬件虚拟化出一套规范优雅的抽象，给所有应用软件提供丰富的功能支持。了解操作系统的设计原则和内部原理对于一个不满足于当调包侠的程序员来说是大有裨益的。出于对操作系统的热爱，我上过国内外很多操作系统课程，它们各有侧重和优劣，大家可以根据兴趣各取所需。</p>
<p><a href="MIT6.S081.md">MIT 6.S081: Operating System Engineering</a>，MIT 著名 PDOS 实验室出品，11 个 Project 让你在一个实现非常优雅的类Unix操作系统xv6上增加各类功能模块。这门课也让我深刻认识到，做系统不是靠 PPT 念出来的，是得几万行代码一点点累起来的。</p>
<p><a href="CS162.md">UCB CS162: Operating System</a>，伯克利的操作系统课，采用和 Stanford 同样的 Project —— 一个教学用操作系统 Pintos。我作为北京大学2022年和2023年春季学期操作系统实验班的助教，引入并改善了这个 Project，课程资源也会全部开源，具体参见<a target="_blank" rel="noopener" href="https://pku-os.github.io">课程网站</a>。</p>
<p><a href="NJUOS.md">NJU: Operating System Design and Implementation</a>，南京大学的蒋炎岩老师开设的操作系统课程。蒋老师以其独到的系统视角结合丰富的代码示例将众多操作系统的概念讲得深入浅出，此外这门课的全部课程内容都是中文的，非常方便大家学习。</p>
<p><a href="HITOS.md">HIT OS: Operating System</a>，哈尔滨工业大学的李治军老师开设的中文操作系统课程。李老师的课程基于 Linux 0.11 源码，十分注重代码实践，并站在学生视角将操作系统的来龙去脉娓娓道来。</p>
<h3 id="并行与分布式系统">并行与分布式系统</h3>
<p>想必这两年各类 CS 讲座里最常听到的话就是“摩尔定律正在走向终结”，此话不假，当单核能力达到上限时，多核乃至众核架构如日中天。硬件的变化带来的是上层编程逻辑的适应与改变，要想充分利用硬件性能，编写并行程序几乎成了程序员的必备技能。与此同时，深度学习的兴起对计算机算力与存储的要求都达到了前所未有的高度，大规模集群的部署和优化也成为热门技术话题。</p>
<h4 id="并行计算">并行计算</h4>
<p><a href="CS149.md">CMU 15-418/Stanford CS149: Parallel Computing</a></p>
<h4 id="分布式系统">分布式系统</h4>
<p><a href="MIT6.824.md">MIT 6.824: Distributed System</a></p>
<h3 id="系统安全">系统安全</h3>
<p>不知道你当年选择计算机是不是因为怀着一个中二的黑客梦想，但现实却是成为黑客道阻且长。</p>
<h4 id="理论课程">理论课程</h4>
<p><a href="CS161.md">UCB CS161: Computer Security</a> 是伯克利的系统安全课程，会涵盖栈攻击、密码学、网站安全、网络安全等等内容。</p>
<p><a href="CSE365.md">ASU CSE365: Introduction to Cybersecurity</a> 亚利桑那州立大学的 Web 安全课程，主要涉及注入、汇编与密码学的内容。</p>
<p><a href="CSE466.md">ASU CSE466: Computer Systems Security</a> 亚利桑那州立大学的系统安全课程，涉及内容全面。门槛较高，需要对 Linux, C 与 Python 充分熟悉。</p>
<p><a href="SEEDLabs.md">SU SEED Labs</a>  雪城大学的网安课程，由 NSF 提供130万美元的资金支持，为网安教育开发了动手实践性的实验练习（称为 SEED Lab）。课程理论教学和动手实践并重，包含详细的开源讲义、视频教程、教科书（被印刷为多种语言）、开箱即用的基于虚拟机和 docker 的攻防环境等。目前全球有1050家研究机构在使用该项目。涵盖计算机和信息安全领域的广泛主题，包括软件安全、网络安全、Web 安全、操作系统安全和移动应用安全。</p>
<h4 id="实践课程">实践课程</h4>
<p>掌握这些理论知识之后，还需要在实践中培养和锻炼这些“黑客素养”。<a target="_blank" rel="noopener" href="https://ctf-wiki.org/">CTF 夺旗赛</a>是一项比较热门的系统安全比赛，赛题中会融会贯通地考察你对计算机各个领域知识的理解和运用。北大今年也成功举办了<a target="_blank" rel="noopener" href="https://geekgame.pku.edu.cn/">第 0 届和第 1 届</a>，鼓励大家后期踊跃参与，在实践中提高自己。下面列举一些我平时学习（摸鱼）用到的资源：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/">CTF-wiki</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf101.org/">CTF-101</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ctf.hacker101.com/">Hacker-101</a></p>
</li>
</ul>
<h3 id="计算机网络">计算机网络</h3>
<blockquote>
<p>没有什么能比自己写个 TCP/IP 协议栈更能加深对计算机网络的理解了。</p>
</blockquote>
<p>大名鼎鼎的 <a href="CS144.md">Stanford CS144: Computer Network</a>，8 个 Project 带你实现整个 TCP/IP 协议栈。</p>
<p>如果你只是想在理论上对计算机网络有所了解，那么推荐计网著名教材《自顶向下方法》的配套学习资源 <a href="topdown.md">Computer Networking: A Top-Down Approach</a>。</p>
<h3 id="数据库系统">数据库系统</h3>
<blockquote>
<p>没有什么能比自己写个关系型数据库更能加深对数据库系统的理解了。</p>
</blockquote>
<p>CMU 的著名数据库神课 <a href="Database-Systems(CMU%2015-445).md">CMU 15-445: Introduction to Database System</a> 会通过 4 个 Project 带你为一个用于教学的关系型数据库 <a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">bustub</a> 添加各种功能。实验的评测框架也免费开源了，非常适合大家自学。此外课程实验会用到 C<ins>11 的众多新特性，也是一个锻炼 C</ins> 代码能力的好机会。</p>
<p>Berkeley 作为著名开源数据库 postgres 的发源地也不遑多让，[UCB CS186: Introduction to Database System](Introduction%20to%20Database%20System(.md) 会让你用 Java 语言实现一个支持 SQL 并发查询、B+ 树索引和故障恢复的关系型数据库。</p>
<h3 id="编译原理">编译原理</h3>
<blockquote>
<p>没有什么能比自己写个编译器更能加深对编译器的理解了。</p>
</blockquote>
<p><a href="CS143.md">Stanford CS143: Compilers</a> 带你手写编译器。</p>
<h3 id="Web开发">Web开发</h3>
<p>前后端开发很少在计算机的培养方案里被重视，但其实掌握这项技能还是好处多多的，例如搭建自己的个人主页，抑或是给自己的课程项目做一个精彩的展示网页。</p>
<h4 id="两周速成版">两周速成版</h4>
<p><a href="mitweb.md">MIT web development course</a></p>
<h4 id="系统学习版">系统学习版</h4>
<p><a href="CS142.md">Stanford CS142: Web Applications</a></p>
<h3 id="计算机图形学">计算机图形学</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="CS148.md">Stanford CS148</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES101.md">Games101</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES103.md">Games103</a></p>
</li>
<li class="lvl-2">
<p><a href="GAMES202.md">Games202</a></p>
</li>
</ul>
<h3 id="数据科学">数据科学</h3>
<p>其实数据科学和机器学习与深度学习有着很紧密的联系，但可能更侧重于实践。Berkeley 的 <a href="Data100.md">UCB Data100: Principles and Techniques of Data Science</a> 通过丰富的编程练习让你在实践中掌握各类数据分析工具和算法，并带领你体验从海量的数据集中提取出想要的结果，并对未来的数据或用户的行为做出相应的预测。但这只是一门基础课，如果想学习工业级别的数据挖掘与分析技术，可以尝试 Stanford 的大数据挖掘课程 <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs246/">CS246: Mining Massive Data Sets</a>。</p>
<h3 id="人工智能">人工智能</h3>
<p>近十年人工智能应该算是计算机界最火爆的领域。如果你不满足于整日听各路媒体争相报道人工智能相关的进展，而想真正一探究竟，那么非常推荐学习 Harvard 神课 CS50 系列的人工智能课程 <a href="%E5%AD%A6%E4%B9%A0/CS-Learning/cs-self-learning/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CS50.md">Harvard CS50: Introduction to AI with Python</a>。课程短小精悍，覆盖了传统人工智能领域的几大分支，并配有丰富有趣的 Python 编程练习来巩固你对人工智能算法的理解。美中不足的是这门课因为面向在线自学者的缘故内容较为精简，并且不会涉及特别深入的数学理论，如果想要系统深入地学习还需要一门本科生难度的课程，例如 Berkeley 的<br>
<a href="CS188.md">UCB CS188: Introduction to Artificial Intelligence</a>。这门课的 Project 复刻了经典游戏糖豆人，让你运用人工智能算法玩游戏，非常有趣。</p>
<h3 id="机器学习">机器学习</h3>
<p>机器学习领域近些年最重要的进展就是发展出了基于神经网络的深度学习分支，但其实很多基于统计学习的算法依然在数据分析领域有着广泛的应用。如果你之前从未接触过机器学习的相关知识，而且不想一开始就陷入艰深晦涩的数学证明，那么不妨先从 Andrew Ng （吴恩达）的 <a href="ML.md">Coursera: Machine Learning</a> 学起。这门课在机器学习领域基本无人不晓，吴恩达以其深厚的理论功底和出色的表达能力把很多艰深的算法讲得深入浅出，并且非常实用。其配套的作业也是质量相当上乘，可以帮助你快速入门。</p>
<p>但上过这门课只能让你从宏观上对机器学习这一领域有一定了解，如果想真正理解那些“神奇”算法背后的数学原理甚至从事相关领域的科研工作，那么还需要一门更“数学”的课程，例如 <a href="CS229.md">Stanford CS229: Machine Learning</a> 或者 <a href="CS189.md">UCB CS189: Introduction to Machine Learning</a>。</p>
<h3 id="深度学习">深度学习</h3>
<p>前几年 AlphaGo 的大热让深度学习进入了大众的视野，不少大学甚至专门成立了相关专业。很多计算机的其他领域也会借助深度学习的技术来做研究，因此基本不管你干啥多少都会接触到一些神经网络、深度学习相关的技术需求。如果想快速入门，同样推荐 Andrew Ng （吴恩达）的 <a href="CS230.md">Coursera: Deep Learning</a>，质量无需多言，Coursera 上罕见的满分课程。此外如果你觉得英文课程学习起来有难度，推荐李宏毅老师的 <a href="LHY.md">国立台湾大学：机器学习</a> 课程。这门课打着机器学习的名号，却囊括了深度学习领域的几乎所有方向，非常全面，很适合你从宏观上对这个领域有一个大致的了解。而且老师本人也非常幽默，课堂金句频出。</p>
<p>当然因为深度学习领域发展非常迅速，已经拥有了众多研究分支，如果想要进一步深入，可以按需学习下面罗列的代表课程，</p>
<h4 id="计算机视觉">计算机视觉</h4>
<p><a href="EECS498-007.md">UMich EECS 498-007 / 598-005: Deep Learning for Computer Vision</a></p>
<p><a href="CS231.md">Stanford CS231n: CNN for Visual Recognition</a></p>
<h4 id="自然语言处理">自然语言处理</h4>
<p><a href="CS224n.md">Stanford CS224n: Natural Language Processing</a></p>
<h4 id="图神经网络">图神经网络</h4>
<p><a href="CS224w.md">Stanford CS224w: Machine Learning with Graphs</a></p>
<h4 id="强化学习">强化学习</h4>
<p><a href="CS285.md">UCB CS285: Deep Reinforcement Learning</a></p>
<h2 id="a-id-yourmap-定制属于你的课程地图-a"><a id="yourmap">定制属于你的课程地图</a></h2>
<blockquote>
<p>授人以鱼不如授人以渔。</p>
</blockquote>
<p>以上的课程规划难免带有强烈的个人偏好，不一定适合所有人，更多是起到抛砖引玉的作用。如果你想挑选自己感兴趣的方向和内容加以学习，可以参考我在下面列出来的资源。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/">MIT OpenCourseWare</a>: 麻省理工学院的课程资源开放共享项目，收录了数以千计的各科课程资源，其中计算机类的课号是 <a target="_blank" rel="noopener" href="http://6.xxx">6.xxx</a>。</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="http://student.mit.edu/catalog/m6a.html">MIT CS Course List</a>: 麻省理工学院的 CS 课程列表。</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://hkn.eecs.berkeley.edu/courseguides">UC Berkeley EECS Course Map</a>: UC Berkeley 的 EECS 培养方案，以课程地图的方式将各门课程的类别和先修关系一目了然地呈现，其中绝大多数课程本书中均有收录。</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www2.eecs.berkeley.edu/Courses/CS/">UC Berkeley CS Course List</a>: UC Berkeley 的 CS 课程列表。</p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41220023/article/details/81976967">Stanford CS Course List</a>: 斯坦福的 CS 课程列表。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/template.en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/template.en/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:12" itemprop="dateModified" datetime="2024-11-13T22:44:12+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>Course Code: Course Name</h1>
<h2 id="Descriptions">Descriptions</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Offered by:</p>
</li>
<li class="lvl-2">
<p>Prerequisites:</p>
</li>
<li class="lvl-2">
<p>Programming Languages:</p>
</li>
<li class="lvl-2">
<p>Difficulty: 🌟🌟🌟</p>
</li>
<li class="lvl-2">
<p>Class Hour:</p>
</li>
</ul>
<!-- 
        Introduce the course in a paragraph or two, including but not limited to:
        (1) The technical knowledge covered in lectures
        (2) Its differences and features compared to similar courses
        (3) Your personal experiences and feelings after studying this course
        (4) Caveats about studying this course on your own (pitfalls, difficulty warnings, etc.)
        (5) ... ...
-->
<h2 id="Course-Resources">Course Resources</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Course Website:</p>
</li>
<li class="lvl-2">
<p>Recordings:</p>
</li>
<li class="lvl-2">
<p>Textbooks:</p>
</li>
<li class="lvl-2">
<p>Assignments:</p>
</li>
</ul>
<h2 id="Personal-Resources">Personal Resources</h2>
<p>All the resources and assignments used by @XXX in this course are maintained in <a target="_blank" rel="noopener" href="https://github.com/user/repo">user/repo - GitHub</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/template/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:44:13" itemprop="dateModified" datetime="2024-11-13T22:44:13+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>课程名称</h1>
<h2 id="课程简介">课程简介</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>所属大学：</p>
</li>
<li class="lvl-2">
<p>先修要求：</p>
</li>
<li class="lvl-2">
<p>编程语言：</p>
</li>
<li class="lvl-2">
<p>课程难度：🌟🌟🌟</p>
</li>
<li class="lvl-2">
<p>预计学时：</p>
</li>
</ul>
<!-- 用一两段话介绍这门课程，内容包括但不限于：
    （1）课程覆盖的知识点范围
    （2）与同类课程相比它的优势与特点
    （3）学习这门课程的体验与感受
    （4）自学这门课的注意点（踩过的坑、难度预警等等）
    （5）... ...
-->
<h2 id="课程资源">课程资源</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>课程网站：</p>
</li>
<li class="lvl-2">
<p>课程视频：</p>
</li>
<li class="lvl-2">
<p>课程教材：</p>
</li>
<li class="lvl-2">
<p>课程作业：</p>
</li>
</ul>
<h2 id="资源汇总">资源汇总</h2>
<p>@XXX 在学习这门课中用到的所有资源和作业实现都汇总在 <a target="_blank" rel="noopener" href="https://github.com/user/repo">user/repo - GitHub</a> 中。</p>
<h2 id="备注">备注</h2>
<p>编写文档时尽量遵守 <a target="_blank" rel="noopener" href="https://github.com/markdownlint/markdownlint/blob/master/docs/RULES.md">Markdown Rules</a> 与 <a target="_blank" rel="noopener" href="https://github.com/selfteaching/markdown-writing-with-mixed-cn-en">Markdown 简体中文与西文混排要点</a>，前者可以通过 VS Code 插件 <em>markdownlint</em> 提示并处理。</p>
<p>正文中请删除该节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/CS-Learning/cs-self-learning/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/08/CS-Learning/cs-self-learning/README/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:05" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:05+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:40:17" itemprop="dateModified" datetime="2024-11-13T22:40:17+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div align="center">
  <img src="./docs/images/title.png" />
</div>
![](./docs/images/title.png)
# CS 自学指南
<blockquote>
<p><em>Everyone should enjoy CS if you have a good teacher to teach you a good course.</em></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/blob/master/LICENSE"><img src="https://img.shields.io/github/license/PKUFlyingPig/cs-self-learning" alt="License"></a><br>
<a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/issues"><img src="https://img.shields.io/github/issues/PKUFlyingPig/cs-self-learning" alt="Issues"></a><br>
<a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning"><img src="https://img.shields.io/github/stars/PKUFlyingPig/cs-self-learning" alt="Stars"></a></p>
<p>新冠肆虐，网课当道，CS 爆火，这一系列的事件都让自学计算机成为了一种潮流。</p>
<p>随着欧美众多名校将质量极高的计算机课程全部开源，自学 CS 成了一件可操作性极强的事情。毫不夸张地说，只要你有毅力和兴趣，自学的成果完全不亚于你在国内任何一所大学受到的本科 CS 教育（当然，这里单指计算机专业领域，大学带给你的显然不止是专业知识）。</p>
<p>我很庆幸在自己大一的时候就选择了自学 CS 这条路，它让我爱上了计算机这门学科，也无比丰富了我的视野。</p>
<p>但同时，自学这条路也有很多困难和阻力：课程繁多不知如何选择，资料零散甚至残缺，作业难度不知深浅，课内任务还需要花时间应付······这些主客观因素叠加到一起，使得好课虽多，却只能在收藏夹里吃灰。</p>
<p>在大学的第四个年头，我想把这一路自学走来的经验和教训，把那些让我受益终身的课程记录下来，分享给大家，形成了这本CS自学指南，以期能给所有想自学计算机的朋友一点帮助。</p>
<p>我的目标是让一个刚刚接触计算机的小白，可以完全凭借这些开源社区的优质资源，少走弯路，在 2-3 年内成长为一个有扎实的数学功底和代码能力，经历过数十个千行代码量的 Project 的洗礼，掌握至少 C/C++/Java/JS/Python/Go/Rust 等主流语言，对算法、电路、体系、网络、操统、编译、人工智能、机器学习、计算机视觉、自然语言处理、强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、Web 开发、云服务、超算等等方面均有所涉猎的全能程序员。此后，无论是选择科研还是就业，我相信你都会有相当的竞争力。</p>
<p>你可以<a target="_blank" rel="noopener" href="https://csdiy.wiki">在线免费阅读这本书</a>。英文版请移步<a target="_blank" rel="noopener" href="https://csdiy.wiki/en/">这里</a>。</p>
<h2 id="如何成为贡献者">如何成为贡献者</h2>
<p>一个人的力量终究是有限的，对于书中任意章节你若有想要补充的内容，欢迎各位提出 <a target="_blank" rel="noopener" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork">Pull Request</a>。如果你想贡献一门新的课程，可以参考目前 repo 中的 <a href="template.md">template</a> 文件作为模版，并在 <a href="mkdocs.yml">mkdocs.yml</a> 文件中添加其navigation，当然你还可以在 <a href="CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.md">CS 学习规划</a> 里的对应模块为其添加言简意赅的导语。如果你有想推荐的书籍，请参考 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/PKUFlyingPig/cs-self-learning/master/docs/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90.md">好书推荐</a> 模块上方的注释按相应格式添加内容。</p>
<p>对于中英混合排版的要点规范，可以参考<a target="_blank" rel="noopener" href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-Hans.md">这个仓库</a>，我们将会对您的 Pull Request 做相应的校对，具体原因参见这个 <a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/issues/114">issue</a>。</p>
<p>本书支持英文版，因此贡献的内容需要提供对应的英文翻译，具体流程可以参考这个 <a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/issues/222">issue</a>。</p>
<p>同时由于个人水平有限，书中难免有笔误甚至概念错误之处，也请各位不吝赐教，在 issue 中提出来。</p>
<h2 id="关于交流社区的建立">关于交流社区的建立</h2>
<p>本书支持页面评论功能，因此如果你想自学某课程，可以自己建立群聊后（QQ 微信皆可）在对应的课程页面下方发表评论，注明你的学习目标以及加入交流群的途径。此外，过去已有不少朋友在 issue 里建立了类似群聊，可以自行选择直接加入。</p>
<h2 id="Star-History">Star History</h2>
<p><a target="_blank" rel="noopener" href="https://star-history.com/#PKUFlyingPig/cs-self-learning&amp;Timeline"><img src="https://api.star-history.com/svg?repos=PKUFlyingPig/cs-self-learning&amp;type=Timeline" alt="Star History Chart"></a></p>
<h2 id="✨-鸣谢">✨ 鸣谢</h2>
<p>特别感谢 @<a target="_blank" rel="noopener" href="https://github.com/AlfredThiel">AlfredThiel</a> 为项目制作了精美的 Logo。</p>
<!--  support by https://contrib.rocks -->
<a target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/cs-self-learning/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=PKUFlyingPig/cs-self-learning"/>
</a>
<h2 id="许可">许可</h2>
<p>项目贡献者编写的部分依照 <a target="_blank" rel="noopener" href="https://www.tawesoft.co.uk/kb/article/mit-license-faq">MIT LICENSE</a>。</p>
<p>其余部分（包括但不限于书中提到的课程资源、开源书籍以及视频内容）遵循原作者规定的许可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/53/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><span class="page-number current">54</span><a class="page-number" href="/page/55/">55</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/55/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">听</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">653</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">听</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
