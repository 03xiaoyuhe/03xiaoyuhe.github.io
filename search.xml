<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Daily Words</title>
    <url>/posts/4c75609f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<p>campus /'kæmpəs/  n. 大学，大学生活；</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>写在前面</title>
    <url>/posts/55009.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>写在前面</h1>
<p>这个博客用于发布一些笔者认为需要多端查看的各种笔记，或者用于记录想要分享的各种知识</p>
<p>另外，由于笔者还并没有完全掌握<code>hexo</code>的各种用法，这个博客同时也会记录一些在使用<code>hexo</code>时的个人心得。</p>
<span id="more"></span>
<h2 id="博客支持的callout块"><a class="header-anchor" href="#博客支持的callout块">¶</a>博客支持的callout块</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&quot;important&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">&quot;warning&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">&quot;caution&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">&quot;success&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">&quot;note&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">&quot;tip&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<div class="callout callout-important">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">IMPORTANT</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
</p>
    </div>
</div>
<div class="callout callout-caution">
    <div class="callout-head">
        <span class="callout-head-icon">❌</span>
        <span class="callout-head-text" style="color:#d32f2f">CAUTION</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
</p>
    </div>
</div>
<div class="callout callout-success">
    <div class="callout-head">
        <span class="callout-head-icon">✔️</span>
        <span class="callout-head-text" style="color:#2e7d32">SUCCESS</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>好吧，typora支持的内容有点少了</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太好了，typora支持<code>note</code></p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>测试callout</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h2>测试一下是否支持应该支持的 md 语法</h2>
<p>警告！</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p>     $\uparrow  \ \ \ \      \uparrow  \ \ \ \     \uparrow$ 其他所有人</p>
<p>     $\uparrow  \ \ \ \      \uparrow$ 用户组</p>
<p>      $\uparrow$ 文件所有者</p>
<p>普通文本内容，其他段落不受影响。</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p><strong>Markdown 语法支持</strong>：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>列表项 1</p>
</li>
<li class="lvl-2">
<p>列表项 2</p>
</li>
</ul>
<blockquote>
<p>嵌套引用块</p>
</p>
    </div>
</div><p>普通文本内容，其他段落不受影响。</p>
</blockquote>
<h2 id="关于博客中自定义渲染callout块的部分"><a class="header-anchor" href="#关于博客中自定义渲染callout块的部分">¶</a>关于博客中自定义渲染<code>callout</code>块的部分</h2>
<h3 id="首先是callout语法"><a class="header-anchor" href="#首先是callout语法">¶</a>首先是<code>callout</code>语法</h3>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; [!tag]</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content2</span></span><br></pre></td></tr></table></figure>
<p>由于笔者在编写此博客时使用的编写工具是<code>typora</code>，故将原来<code>obsidian</code>的语法做了一些改动，因为<code>typora</code>的引用块，行与行之间也会自动添加空行。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>渲染器部分，详见<a href="/posts/4179">关于callout块渲染</a></p>
</p>
    </div>
</div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!info] 信息头</span><br><span class="line">这是第一行内容。</span><br><span class="line">这是第二行内容。</span><br></pre></td></tr></table></figure>
<p><a href="https://mermaid.nodejs.cn/syntax/zenuml.html">ZenUML | Mermaid 中文网</a>Mermaind使用</p>
]]></content>
  </entry>
  <entry>
    <title>考试时间统计</title>
    <url>/posts/28f58f35.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<ul class="lvl-0">
<li class="lvl-2">计组：25号</li>
</ul>
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown中latex的使用记录</title>
    <url>/posts/3d12274.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>总结一些在<code>markdown</code>中书写<code>Latex</code>公式的用法</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="一些常用的希腊字母"><a class="header-anchor" href="#一些常用的希腊字母">¶</a>一些常用的希腊字母</h2>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>LaTex形式</th>
<th>希腊字母</th>
<th>LaTex形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\alpha$ $\Alpha$</td>
<td>\alpha</td>
<td>$\mu$ $\Mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$\beta$ $\Beta$</td>
<td>\beta</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$\gamma$ $\Gamma$</td>
<td>\gamma</td>
<td>$\rho$ $\varrho$ $\Rho$</td>
<td>\rho \varrho \Rho</td>
</tr>
<tr>
<td>$\delta$ $\Delta$</td>
<td>\delta</td>
<td>$\sigma$ $\Sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\epsilon$ $\varepsilon$ $\Epsilon$</td>
<td>\epsilon \varepsilon \Epsilon</td>
<td>$\tau$ $\Tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\zeta$ $\Zeta$</td>
<td>\zeta</td>
<td>$\upsilon$ $\Upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\eta$ $\Eta$</td>
<td>\eta</td>
<td>$\phi$ $\varphi$ $\Phi$</td>
<td>\phi \varphi \Phi</td>
</tr>
<tr>
<td>$\theta$ $\vartheta$ $\Theta$</td>
<td>\theta \vartheta \Theta</td>
<td>$\chi$ $\Chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\omega$ $\Omega$</td>
<td>\omega</td>
<td>$\psi$ $\Psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\kappa$ $\Kappa$</td>
<td>\kappa</td>
<td>$\iota$ $\Iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$\lambda$ $\Lambda$</td>
<td>\lambda</td>
<td>$\theta$ $\Theta$</td>
<td>\theta</td>
</tr>
</tbody>
</table>
<h2 id="上标下标"><a class="header-anchor" href="#上标下标">¶</a>上标下标</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>上标$a^2$： <code>a^2</code></p>
</li>
<li class="lvl-2">
<p>下标$H_2O$：<code>H_2O</code></p>
</li>
</ul>
<h2 id="顶标"><a class="header-anchor" href="#顶标">¶</a>顶标</h2>
<p>通用标签：<code>\overset&#123;顶标&#125;&#123;字体&#125;</code>：$\overset{顶标}{字体}$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于通用顶标的拓展尝试</h4>
<ul class="lvl-1">
<li class="lvl-3">
<p>$\overset{_}{a}$ ：<code>\overset&#123;\_&#125;&#123;a&#125;</code></p>
</li>
<li class="lvl-2">
<p>$\overset{·}{a}$：<code>\overset&#123;·&#125;&#123;a&#125;</code></p>
<p><small>这里的<code>·</code>是中文的<big><big>`</big></big></small></p>
</li>
<li class="lvl-2">
<p>$\overset{~}{a}$：失败的尝试，若不使用<code>\</code>转义，则<code>~</code>不会显示，就像这样$\overset{~}{a}$</p>
</li>
<li class="lvl-2">
<p>$\overset{^}{a}$：<code>$\overset&#123;\^&#125;&#123;a&#125;</code></p>
</li>
</ul>
</p>
    </div>
</div><p>常用顶标：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>\hat&#123;1&#125;</code> : $\hat{1}$</p>
</li>
<li class="lvl-2">
<p><code>\overline&#123;1&#125;</code> : $\overline{1}$</p>
</li>
<li class="lvl-2">
<p><code>\dot&#123;1&#125;</code> : $\dot{1}$</p>
</li>
<li class="lvl-2">
<p><code>\widetilde&#123;1&#125;</code> : $\widetilde{1}$</p>
</li>
</ul>
<h2 id="分数"><a class="header-anchor" href="#分数">¶</a>分数</h2>
<p>$5/6$ <code>5/6</code>，美中不足，不同渲染器渲染结果不同，比如<code>typora</code>就是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121457874.png" alt="image-20241212145726822"></p>
<center><small>这显然不是我们想要的样子</small></center>
<p>规范的分式写法：</p>
<p>$\frac{a}{b}$:<code>\frac&#123;a&#125;&#123;b&#125;</code></p>
<p>但其实也不太必要。😰</p>
<h2 id="求和与积分"><a class="header-anchor" href="#求和与积分">¶</a>求和与积分</h2>
<p>$\sum_{i=1}^n i^2$</p>
<p><code>\sum_&#123;i=1&#125;^n i^2</code></p>
<p>$ \int_a^b x^2 , dx$</p>
<p><code> \int_a^b x^2 \, dx</code></p>
<blockquote>
<p>有趣🎃</p>
<p>$,$<small>：<code>$,$</code></small>是会被<code>latex</code>渲染出来的，</p>
<p>$,$<small>$\leftarrow$这里有东西</small><small>：<code>$\,$</code></small>就像会把 ’ ,’ 忽略一样，可能只渲染出一个空格吧</p>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实就是$\sum$：<code>$\sum$</code>加个上标，加个下标$\sum_a^b$<code>$\sum_a^b$</code>，就变成求和的这个了</p>
<p>积分符号<code>$\int$</code><small>：$\int$</small> ，同理，加个上标加个下标就好了，$\int_a^b$<code>$\int_a^b$</code></p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>感觉需要补一下知识</h4>
<p>例如，我们可以很方便的将一个字母或者数字作为上标或者下标：</p>
<p>$a_2, b^3$ <code>$a_2, b^3$</code></p>
<p>而我们想将$(n-1)$<code>$(n-1)$</code>作为上标或者下标时，我们就会涉及到将$(n-1)$作为一个整体，当作下标和上标。</p>
<p>在$\LaTeX$中如果想将一组符号<small>如$n-1$</small>，就需要用到<code>$&#123;&#125;$</code></p>
<p>例如，$a_{n-1}$：<code>$a_&#123;n-1&#125;$</code>，就将<code>n-1</code>用<code>&#123;&#125;</code>括起来，当成一个整体。</p>
</p>
    </div>
</div><h2 id="逻辑符号"><a class="header-anchor" href="#逻辑符号">¶</a>逻辑符号</h2>
<p>$\forall, \exists, \neg, \land, \lor, \implies, \iff$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$\forall$：<code>$forall$</code></p>
</li>
<li class="lvl-2">
<p>$\exists$：<code>$\exists$</code></p>
</li>
<li class="lvl-2">
<p>$\neg$：<code>$\neg$</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="negative 英 /ˈneɡətɪv/ 否定的，拒绝的；">[1]</span></a></sup></p>
</li>
<li class="lvl-2">
<p>$\land$：<code>$\land$</code><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="logical AND">[2]</span></a></sup> l-and</p>
</li>
<li class="lvl-2">
<p>$\lor$：<code>$\lor$</code><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="logical OR">[3]</span></a></sup> l-or</p>
</li>
<li class="lvl-2">
<p>$\implies$：<code>$\implies$</code></p>
</li>
<li class="lvl-2">
<p>$\iff$：<code>$\iff$</code></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>贴张趣图:happy:</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121530568.png" alt="image-20241212153056632"></p>
</p>
    </div>
</div><h2 id="方程"><a class="header-anchor" href="#方程">¶</a>方程</h2>
<p>$$<br>
\begin{aligned}<br>
x &amp;= y + z \\<br>
a &amp;= b + c<br>
\end{aligned}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x <span class="built_in">&amp;</span>= y + z <span class="keyword">\\</span><span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span>= b + c</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>因为<code>hexo</code>渲染器问题，<code>\\</code>会被转成<code>\</code>无论是不是在公式块中，而<code>\</code>在latex中是空格的意思，而<code>\\</code>是换行的意思，但是在被渲染处理后<code>\\</code>就会变成<code>\</code>，这样在mathjax渲染是可就bug了🙁</p>
<p>网上并没有好的解决方案，有修改渲染器源代码的，有用个分割块让渲染器强制不处理的，但是这样在正文块还正常，在引用块中就出现各种问题了</p>
</p>
    </div>
</div><p>哎，还得是这个没办法的方案了</p>
<p>就是，hexo不是会吧<code>\\</code>转义成<code>\</code>吗，那就索性让他转义，我们直接<code>\\\\</code>不就好了，<code>\\\\</code>就会变成<code>\\</code>，不过这样在自己的编辑器中就会中间多一行空行了</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121555139.png" alt="image-20241212155459686"></p>
<center><small>会中间多一行空行</small></center>
<p>但其实无伤大雅对吧。</p>
<p>另外，用<code>&amp;</code>可以对其方程，<code>&amp;</code>所在的位置会被上下对齐</p>
<h2 id="矩阵"><a class="header-anchor" href="#矩阵">¶</a>矩阵</h2>
<p>$$<br>
\begin{bmatrix}<br>
a &amp; b \\<br>
c &amp; d<br>
\end{bmatrix}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="keyword">\\</span><span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向量与点积"><a class="header-anchor" href="#向量与点积">¶</a>向量与点积</h2>
<p>$\vec{a}, \vec{b}, \cdot$</p>
<p><code>$\vec&#123;a&#125;, \vec&#123;b&#125;, \cdot$</code></p>
<h2 id="根号"><a class="header-anchor" href="#根号">¶</a>根号</h2>
<p>$\sqrt{a}, \sqrt[3]{b}, \sqrt{x^2 + y^2}$</p>
<p><code>$\sqrt&#123;a&#125;, \sqrt[3]&#123;b&#125;, \sqrt&#123;x^2 + y^2&#125;$</code></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">negative 英 /ˈneɡətɪv/ 否定的，拒绝的；<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">logical AND<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3" class="footnote-item"><span class="footnote-content">logical OR<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>typora破解</title>
    <url>/posts/8fcf3ec6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太逆天了，笔者是在花<big><big>89</big></big>米😕 之后，偶然搜到了这个，虽然已经没用了，但还是摘一下</p>
</p>
    </div>
</div><span id="more"></span>
<p><small>放个error以表愤怒！</small>😠</p>

<div class="callout callout-error">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">ERROR</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>Typora 是一款由 Abner Lee 开发的轻量级 Markdown 编辑器，适用于 OS X、Windows 和 Linux 三种操作系统。</p>
<p>与其他 Markdown 编辑器不同的是，Typora 没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p>
<p>该软件目前只有 15 天免费试用，后续使用续费付费才行！这里分享一个自己破解的方法！不再从网上下载破解版或者补丁了！</p>
<p>免责声明：本文内容仅为技术分享、交流、探讨，推荐大家支持官方正版软件！</p>
<h2>官网地址</h2>
<p>国外：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmEuaW8v">https://typora.io/</a></p>
<p>国内：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmFpby5jbi8=">https://typoraio.cn/</a></p>
<h2>省流步骤</h2>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 <code>\ resources\page-dist\static\js\LicenseIndex.xxxxxxxxx.xxxxxxx.chunk.js</code>，激活主程序</p>
</li>
</ol>
<p>查找：<code>e.hasActivated=&quot;true&quot;==e.hasActivated,</code></p>
<p>替换：<code>e.hasActivated=&quot;true&quot;==&quot;true&quot;,</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\page-dist\license.html，关闭每次启动时的已激活弹窗</p>
</li>
</ol>
<p>查找：<code>&lt;/body&gt;&lt;/html&gt;</code>替换：<code>&lt;/body&gt;&lt;script&gt;window.onload=function()&#123;setTimeout(()=&gt;&#123;window.close();&#125;,5);&#125;&lt;/script&gt;&lt;/html&gt;</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\locales\zh-Hans.lproj\Panel.json，去除左下角 “未激活” 提示（不完美方案，仅去除文字，小框框还在）</p>
</li>
</ol>
<p>查找：<code>&quot;UNREGISTERED&quot;:&quot;未激活&quot;</code></p>
<p>替换：<code>&quot;UNREGISTERED&quot;:&quot; &quot;</code></p>
<h2>最后总结</h2>
<ul class="lvl-1">
<li class="lvl-2">
<p>我的许可证页面无法查看</p>
</li>
<li class="lvl-2">
<p>左下角关闭的小框还存在</p>
</li>
<li class="lvl-2">
<p>其他平台如 MAC，Linux 参考本文自己摸索一下</p>
</li>
<li class="lvl-2">
<p>一旦程序启动崩溃，可能是替换时有误操作，重新安装再尝试</p>
</li>
<li class="lvl-2">
<p>随着新版本更新，可能该方法会失效，亲测 1.7.6 没有问题</p>
</li>
</ul>
<p>—— <a href="https://blog.captainz.cc/posts/typora_crack.html">自己动手破解 Markdown 软件 Typora，支持官网最新版 | Hyper Tech</a></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/posts/42cbd3c8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>CMake</strong> 是一种跨平台的构建工具，用于管理软件项目的构建流程。它通过使用配置文件（<code>CMakeLists.txt</code>）来生成适合特定平台的原生构建系统文件，如 <strong>Makefile</strong>（Linux）或 <strong>Visual Studio 工程文件</strong>（Windows）。</p>
<p>CMake 的目标是让开发者在不同的操作系统和编译器之间轻松地构建、测试和打包软件项目。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CMake-简介"><a class="header-anchor" href="#CMake-简介">¶</a>CMake 简介</h3>
<p><strong>CMake</strong> 是一种跨平台的构建工具，用于管理软件项目的构建流程。它通过使用配置文件（<code>CMakeLists.txt</code>）来生成适合特定平台的原生构建系统文件，如 <strong>Makefile</strong>（Linux）或 <strong>Visual Studio 工程文件</strong>（Windows）。</p>
<p>CMake 的目标是让开发者在不同的操作系统和编译器之间轻松地构建、测试和打包软件项目。</p>
<hr>
<h3 id="CMake-的主要特点"><a class="header-anchor" href="#CMake-的主要特点">¶</a>CMake 的主要特点</h3>
<ol>
<li class="lvl-3">
<p><strong>跨平台支持</strong>：支持 Windows、Linux、macOS，以及嵌入式系统开发。</p>
</li>
<li class="lvl-3">
<p><strong>生成原生构建文件</strong>：通过 <code>CMakeLists.txt</code>，生成适合平台的构建系统文件。</p>
</li>
<li class="lvl-3">
<p><strong>模块化管理</strong>：支持分模块编译和依赖关系管理。</p>
</li>
<li class="lvl-3">
<p><strong>灵活的配置</strong>：支持多种构建选项（如 Debug/Release）。</p>
</li>
<li class="lvl-3">
<p><strong>集成测试工具</strong>：可以通过 CTest 实现测试自动化。</p>
</li>
<li class="lvl-3">
<p><strong>广泛支持的工具链</strong>：支持多种编译器（GCC、Clang、MSVC 等）和工具链（Ninja 等）。</p>
</li>
</ol>
<hr>
<h3 id="CMake-的基本使用流程"><a class="header-anchor" href="#CMake-的基本使用流程">¶</a>CMake 的基本使用流程</h3>
<ol>
<li class="lvl-3">
<p><strong>安装 CMake</strong>：在系统中安装 CMake，可通过包管理工具（如 apt、yum、brew）或官网下载安装包。</p>
</li>
<li class="lvl-3">
<p><strong>创建 CMakeLists.txt</strong>：编写一个 <code>CMakeLists.txt</code> 文件，描述项目的构建流程。</p>
</li>
<li class="lvl-3">
<p><strong>运行 CMake</strong>：使用 <code>cmake</code> 命令生成构建系统文件（如 Makefile）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>构建项目</strong>：使用生成的构建文件进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="一个简单的-CMake-示例"><a class="header-anchor" href="#一个简单的-CMake-示例">¶</a>一个简单的 CMake 示例</h3>
<p>假设有以下项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br></pre></td></tr></table></figure>
<h4 id="1-编写-main-cpp"><a class="header-anchor" href="#1-编写-main-cpp">¶</a>1. 编写 <code>main.cpp</code></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, CMake!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-编写-CMakeLists-txt"><a class="header-anchor" href="#2-编写-CMakeLists-txt">¶</a>2. 编写 <code>CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 的最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(HelloCMake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br></pre></td></tr></table></figure>
<h4 id="3-构建项目"><a class="header-anchor" href="#3-构建项目">¶</a>3. 构建项目</h4>
<p>在项目根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成构建系统文件</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>运行生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/hello</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="CMake-的核心命令"><a class="header-anchor" href="#CMake-的核心命令">¶</a>CMake 的核心命令</h3>
<ol>
<li class="lvl-3">
<p><code>project</code>：定义项目名称及支持的语言。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject LANGUAGES CXX)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>add_executable</code>：添加可执行文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_program main.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>add_library</code>：添加库文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_library STATIC lib.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>target_include_directories</code>：指定头文件路径。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(my_program PRIVATE <span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>target_link_libraries</code>：链接库文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_program PRIVATE my_library)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="CMake-的优势"><a class="header-anchor" href="#CMake-的优势">¶</a>CMake 的优势</h3>
<ol>
<li class="lvl-3">
<p><strong>自动化管理依赖关系</strong>：轻松管理第三方库和自定义模块。</p>
</li>
<li class="lvl-3">
<p><strong>适应性强</strong>：支持不同编译器和平台。</p>
</li>
<li class="lvl-3">
<p><strong>模块支持</strong>：自带许多模块（如查找库、设置编译选项）</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接库</title>
    <url>/posts/29b48e9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>动态链接库（Dynamic Link Library，简称DLL）是包含可以由多个程序共享使用的代码和数据的文件。这种技术使程序能够高效地复用资源、减少重复代码以及节省内存空间。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="动态链接库的特点："><a class="header-anchor" href="#动态链接库的特点：">¶</a>动态链接库的特点：</h3>
<ol>
<li class="lvl-3">
<p><strong>动态加载</strong>：程序运行时，DLL文件才会被加载到内存中。</p>
</li>
<li class="lvl-3">
<p><strong>共享资源</strong>：多个程序可以同时使用同一个DLL文件，减少重复代码占用的磁盘和内存资源。</p>
</li>
<li class="lvl-3">
<p><strong>模块化开发</strong>：通过动态链接库，可以将应用程序拆分为多个模块，方便独立开发、测试和部署。</p>
</li>
<li class="lvl-3">
<p><strong>可更新性</strong>：更新程序时，只需替换DLL文件，无需更改主程序。</p>
</li>
</ol>
<hr>
<h3 id="DLL的应用场景："><a class="header-anchor" href="#DLL的应用场景：">¶</a>DLL的应用场景：</h3>
<ol>
<li class="lvl-3">
<p><strong>共享代码和功能</strong>：如Windows的系统功能（<code>user32.dll</code>、<code>kernel32.dll</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>插件系统</strong>：支持动态加载的插件，提供功能扩展。</p>
</li>
<li class="lvl-3">
<p><strong>跨语言调用</strong>：通过DLL，允许不同编程语言的程序共享同一段功能代码。</p>
</li>
<li class="lvl-3">
<p><strong>节省资源</strong>：避免重复代码的加载。</p>
</li>
</ol>
<hr>
<h3 id="使用动态链接库的注意事项："><a class="header-anchor" href="#使用动态链接库的注意事项：">¶</a>使用动态链接库的注意事项：</h3>
<ol>
<li class="lvl-3">
<p><strong>版本兼容性</strong>：更新DLL时必须保证接口兼容，否则可能导致主程序崩溃。</p>
</li>
<li class="lvl-3">
<p><strong>依赖问题</strong>：动态链接库可能依赖其他库，必须确保相关库也被正确部署。</p>
</li>
<li class="lvl-3">
<p><strong>安全性</strong>：动态链接库容易受到DLL劫持（DLL Hijacking）攻击，加载DLL时需指定明确路径或使用签名校验。</p>
</li>
</ol>
<hr>
<h4 id="如何创建和使用动态链接库？"><a class="header-anchor" href="#如何创建和使用动态链接库？">¶</a>如何创建和使用动态链接库？</h4>
<p><strong>C++（Windows平台示例）</strong><br>
创建一个简单的动态链接库（<code>.dll</code>）并调用。</p>
<h5 id="创建DLL："><a class="header-anchor" href="#创建DLL：">¶</a>创建DLL：</h5>
<ol>
<li class="lvl-3">
<p>创建<code>mydll.cpp</code>文件：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World from DLL!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>使用命令行编译为DLL：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cl /LD mydll.cpp</span><br></pre></td></tr></table></figure>
<p>生成的<code>mydll.dll</code>就是动态链接库。</p>
<h5 id="调用DLL："><a class="header-anchor" href="#调用DLL：">¶</a>调用DLL：</h5>
<ol>
<li class="lvl-3">
<p>创建<code>main.cpp</code>文件：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HelloWorldFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;mydll.dll&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (hModule) &#123;</span><br><span class="line">        HelloWorldFunc hello = (HelloWorldFunc)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hello) &#123;</span><br><span class="line">            <span class="built_in">hello</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hModule);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to load DLL&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>编译并运行，确保<code>mydll.dll</code>在同一目录下。</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接库与CMake</title>
    <url>/posts/376b14fc.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>CMake 和动态链接库（DLL 或共享库）关系密切，因为 CMake 是一种构建工具，可以用来生成、管理和使用动态链接库。通过 CMake，可以轻松地定义动态库的构建规则，并在项目中加载或链接这些库。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CMake-与动态链接库的关系"><a class="header-anchor" href="#CMake-与动态链接库的关系">¶</a>CMake 与动态链接库的关系</h3>
<p>CMake 和动态链接库（DLL 或共享库）关系密切，因为 CMake 是一种构建工具，可以用来生成、管理和使用动态链接库。通过 CMake，可以轻松地定义动态库的构建规则，并在项目中加载或链接这些库。</p>
<hr>
<h3 id="CMake-如何生成动态链接库"><a class="header-anchor" href="#CMake-如何生成动态链接库">¶</a>CMake 如何生成动态链接库</h3>
<p>动态链接库（Dynamic Link Library，Windows 下通常是 <code>.dll</code>，Linux 下是 <code>.so</code>，macOS 下是 <code>.dylib</code>）的构建需要指定库的类型。CMake 提供了灵活的机制来创建动态库。</p>
<h4 id="示例：创建动态链接库"><a class="header-anchor" href="#示例：创建动态链接库">¶</a>示例：创建动态链接库</h4>
<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── library/</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── my_library.cpp</span><br><span class="line">│   └── my_library.h</span><br><span class="line">├── app/</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.cpp</span><br></pre></td></tr></table></figure>
<h4 id="1-编写动态库的代码"><a class="header-anchor" href="#1-编写动态库的代码">¶</a>1. 编写动态库的代码</h4>
<p><code>library/my_library.h</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>library/my_library.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-编写-library-CMakeLists-txt"><a class="header-anchor" href="#2-编写-library-CMakeLists-txt">¶</a>2. 编写 <code>library/CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_library SHARED my_library.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置库的输出名称（可选）</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(my_library PROPERTIES OUTPUT_NAME <span class="string">&quot;my_dynamic_library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库头文件供外部使用</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_library PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><code>SHARED</code> 标志表示生成动态链接库。如果需要生成静态库，可以将其替换为 <code>STATIC</code>。</p>
<hr>
<h3 id="3-使用动态链接库"><a class="header-anchor" href="#3-使用动态链接库">¶</a>3. 使用动态链接库</h3>
<p><code>app/main.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 + 3 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-编写-app-CMakeLists-txt"><a class="header-anchor" href="#4-编写-app-CMakeLists-txt">¶</a>4. 编写 <code>app/CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE my_library)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="5-根目录-CMakeLists-txt"><a class="header-anchor" href="#5-根目录-CMakeLists-txt">¶</a>5. 根目录 <code>CMakeLists.txt</code></h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(DynamicLibraryExample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(library)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(app)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-构建和运行"><a class="header-anchor" href="#6-构建和运行">¶</a>6. 构建和运行</h3>
<p>在项目根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成构建系统</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建项目</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>运行生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/app/my_app</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="CMake-使用动态库的常见场景"><a class="header-anchor" href="#CMake-使用动态库的常见场景">¶</a>CMake 使用动态库的常见场景</h3>
<ol>
<li class="lvl-3">
<p><strong>动态加载动态库</strong><br>
通过操作系统接口（如 <code>dlopen</code> 和 <code>LoadLibrary</code>）加载动态库并调用其函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span> <span class="comment">// Linux/macOS</span></span></span><br><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;my_dynamic_library.so&quot;</span>, RTLD_LAZY);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查找系统动态库</strong><br>
使用 CMake 的 <code>find_library</code> 命令查找系统中已安装的动态库。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(MY_LIB my_library PATHS /usr/lib /usr/local/lib)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE <span class="variable">$&#123;MY_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>安装动态库</strong><br>
配置安装规则，将动态库安装到指定路径。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS my_library DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES my_library.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>控制动态库版本</strong><br>
CMake 支持为动态库设置版本号，用于兼容性管理。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(my_library PROPERTIES VERSION <span class="number">1.0</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="动态库的优点通过-CMake-放大"><a class="header-anchor" href="#动态库的优点通过-CMake-放大">¶</a>动态库的优点通过 CMake 放大</h3>
<ol>
<li class="lvl-3">
<p><strong>模块化构建</strong><br>
动态库可与多个项目共享，CMake 管理动态库的构建和链接更加简单。</p>
</li>
<li class="lvl-3">
<p><strong>跨平台兼容</strong><br>
CMake 抽象了不同平台的动态库细节（如 <code>.dll</code> 和 <code>.so</code> 的差异），开发者只需专注于库的功能实现。</p>
</li>
<li class="lvl-3">
<p><strong>依赖关系管理</strong><br>
CMake 能自动处理动态库的依赖，确保库按正确顺序链接。</p>
</li>
<li class="lvl-3">
<p><strong>动态库的安装和部署</strong><br>
使用 CMake，可以轻松地将动态库与项目一起打包并分发。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>CMake 与动态链接库密切相关，是开发和管理动态库的理想工具。通过 CMake，可以轻松完成动态库的创建、链接、加载、安装和跨平台管理，显著简化复杂项目的开发流程。</p>
<p>如需进一步了解动态库的特定实现或动态加载，可以提供更详细的场景！</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>footnote使用</title>
    <url>/posts/64648fb9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>关于 callout 块渲染</title>
    <url>/posts/4179.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下<code>callout</code>支持过程。</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="初期想法"><a class="header-anchor" href="#初期想法">¶</a>初期想法</h2>
<p>因为<code>hexo</code>支持<code>markdown</code>基础语法，而笔者在使用<code>hexo</code>之前，恰好使用过<code>Obsidian</code>笔记软件，非常喜欢使用<code>Obsidian</code>中的<code>Callout</code>块。</p>
<p>但发现网上并没有相关解决方案，虽然可以使用自定义代码块的方式书写类似<code>callout</code>块的效果，但是这样就和当前使用的<code>markdown</code>编辑器不兼容，而且自定义代码块的样式并不好看。<small><del>笔者还是比较喜欢即写即渲染的编辑模式</del></small></p>
<p>所以，笔者就想提供一个专门用于渲染<code>callout</code>块的自定义渲染器，<small>笔者曾经写过一个<code>python</code>的<code>md</code>渲染器，就在书写本文章不久前，也是为了解决<code>callout</code>块问题</small></p>
<p><small><del>笔者对<code>callout</code>还是非常喜爱的</del></small></p>
<h2 id="实际实现"><a class="header-anchor" href="#实际实现">¶</a>实际实现</h2>
<p>首先，安装<code>hexo-renderer-markdown-it</code> 以及 <code>markdown-it-container</code> 插件来扩展 <code>Markdown</code> 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-container --save</span><br></pre></td></tr></table></figure>
<p>在 <code>hexo-renderer-markdown-it</code> 配置中启用容器解析： 修改 <code>Hexo</code> 的 <code>_config.yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-container</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时，<code>hexo</code>已经支持运行自定义的<code>markdown</code>了。</p>
<p>接下来，我们书写<code>callout</code>渲染器。</p>
<p><small><del>其实笔者在该部分废了老大的劲</del></small></p>
<p>我先贴下代码</p>
<h3 id="自定义渲染器代码"><a class="header-anchor" href="#自定义渲染器代码">¶</a>自定义渲染器代码</h3>
<p><small>二编了🤡代码最终还是没躲过bug，当然鲁棒性肯定更高了</small></p>
<p><small>三编了，这次是加了支持表情符的功能，这个也是typora支持的😴</small></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iconConfig = &#123;</span><br><span class="line">    <span class="string">&quot;important&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;warning&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;caution&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;success&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;note&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;tip&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadIcon</span>(<span class="params">iconName</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[iconName] || iconConfig[<span class="string">&quot;important&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;span class=&quot;callout-head-icon&quot;&gt;<span class="subst">$&#123;iconInfo.icon&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateCalloutHTML</span>(<span class="params">type, tokens, state</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化 markdown-it 实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MarkdownIt</span> = <span class="built_in">require</span>(<span class="string">&#x27;markdown-it&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> md = <span class="keyword">new</span> <span class="title class_">MarkdownIt</span>(&#123;</span><br><span class="line">        <span class="attr">html</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">linkify</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">typographer</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">breaks</span>: <span class="literal">true</span></span><br><span class="line">    &#125;).<span class="title function_">use</span>(<span class="built_in">require</span>(<span class="string">&#x27;markdown-it-emoji&#x27;</span>)); <span class="comment">// 添加 Emoji 插件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并渲染参数</span></span><br><span class="line">    <span class="keyword">const</span> options = &#123; ...state.<span class="property">options</span>, <span class="attr">breaks</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> wrappedTokens = [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_open&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: <span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        ...tokens,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_close&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: -<span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染 Callout 内容</span></span><br><span class="line">    <span class="keyword">let</span> calloutBody = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        calloutBody = md.<span class="property">renderer</span>.<span class="title function_">render</span>(wrappedTokens, options, state.<span class="property">env</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Callout rendering error:&quot;</span>, error);</span><br><span class="line">        calloutBody = <span class="string">&quot;&lt;!-- Render Error --&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[type] || iconConfig[<span class="string">&quot;important&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;callout callout-<span class="subst">$&#123;type&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-head&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;loadIcon(type)&#125;</span></span></span><br><span class="line"><span class="string">        &lt;span class=&quot;callout-head-text&quot; style=&quot;color:<span class="subst">$&#123;iconInfo.color&#125;</span>&quot;&gt;<span class="subst">$&#123;type.toUpperCase()&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-contents&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;calloutBody&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Hexo 的 markdown-it 渲染器扩展</span></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown-it:renderer&#x27;</span>, <span class="keyword">function</span> (<span class="params">md</span>) &#123;</span><br><span class="line">    md.<span class="property">core</span>.<span class="property">ruler</span>.<span class="title function_">push</span>(<span class="string">&#x27;render_callout&#x27;</span>, <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tokens = state.<span class="property">tokens</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历 token，找到 blockquote 块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = tokens.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> token = tokens[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测到 blockquote_open 类型</span></span><br><span class="line">            <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;blockquote_open&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> blockquoteTokens = [];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 收集 blockquote 内容</span></span><br><span class="line">                <span class="keyword">while</span> (tokens[j] &amp;&amp; tokens[j].<span class="property">type</span> !== <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    blockquoteTokens.<span class="title function_">push</span>(tokens[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 确保找到了 blockquote_close</span></span><br><span class="line">                <span class="keyword">if</span> (tokens[j]?.<span class="property">type</span> === <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> calloutType = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">const</span> calloutBodyTokens = [];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 检测 blockquote 内容中的 callout 类型</span></span><br><span class="line">                    blockquoteTokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;inline&#x27;</span> &amp;&amp; !calloutType) &#123;</span><br><span class="line">                            <span class="keyword">const</span> match = token.<span class="property">content</span>.<span class="title function_">match</span>(<span class="regexp">/\[!(\w+)]/</span>);</span><br><span class="line">                            <span class="keyword">if</span> (match) calloutType = match[<span class="number">1</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            calloutBodyTokens.<span class="title function_">push</span>(token);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果检测到了合法的 callout 类型</span></span><br><span class="line">                    <span class="keyword">if</span> (calloutType) &#123;</span><br><span class="line">                        <span class="keyword">const</span> calloutHtml = <span class="title function_">generateCalloutHTML</span>(calloutType, calloutBodyTokens, state);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 替换 blockquote_open 类型为 html_block</span></span><br><span class="line">                        token.<span class="property">type</span> = <span class="string">&#x27;html_block&#x27;</span>;</span><br><span class="line">                        token.<span class="property">content</span> = calloutHtml;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 删除多余的 token</span></span><br><span class="line">                        tokens.<span class="title function_">splice</span>(i + <span class="number">1</span>, j - i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><small>其实在阅读这段代码我们能够发现，这段脚本支持用户自定义自己喜欢的callout块，这是后话</small></p>
<p><small>二编：发现有<code>hexo</code>有时候会报<code>breaks</code>和<code>xhtmlOut</code>的错，最后看了一下详细的报错信息发现和这个<code>callout</code>脱不了干系，果不其然要改了😰</small></p>
<h3 id="代码放置位置"><a class="header-anchor" href="#代码放置位置">¶</a>代码放置位置</h3>
<p><strong>然后就是代码的放置位置</strong>，虽然笔者并不了解<code>hexo</code></p>
<ol>
<li class="lvl-3">
<p>总之，在你的<em>博客根目录</em><br>
<small>(虽然不知道博客根目录是否难懂，但如果跟着教程配好了博客的人一定都很聪明)</small></p>
</li>
<li class="lvl-3">
<p>新建一个<code>scripts</code>文件夹<small>当然，也可能有的大佬已经有了，<del>萌新瑟瑟发抖</del></small></p>
</li>
<li class="lvl-3">
<p>然后在该文件夹下新建文件<code>markdown-it-callout.js</code><small>当然，笔者的文件名取的是这个，但并不清楚其他名字是否可用</small></p>
</li>
<li class="lvl-3">
<p>然后把上面那段<code>callout</code>渲染代码贴进去</p>
</li>
</ol>
<h3 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义css样式</h3>
<p>然后由于笔者使用的callout块是自己渲染的，需要<strong>自定义css样式</strong></p>
<p>这个部分在<a href="/posts/d9cd1415">客制化css</a>有详细介绍</p>
<h3 id="支持表情符部分"><a class="header-anchor" href="#支持表情符部分">¶</a>支持表情符部分</h3>
<h4 id="安装-markdown-it-emoji-插件"><a class="header-anchor" href="#安装-markdown-it-emoji-插件">¶</a>安装 <code>markdown-it-emoji</code> 插件</h4>
<p>使用 npm 安装 <code>markdown-it-emoji</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install markdown-it-emoji</span><br></pre></td></tr></table></figure>
<p>当然，如果不喜欢表情符的话，可以把<code>.use(require('markdown-it-emoji')</code>删除。</p>
<hr>
<p>然后！<big>然后！<big>然后！</big></big>你就获得了一个可以渲染<code>callout</code>的<code>hexo</code></p>
<h2 id="然后就是效果展示了"><a class="header-anchor" href="#然后就是效果展示了">¶</a>然后就是效果展示了</h2>
<p>其实看<a href="/posts/55009">写在前面</a>就可以了</p>
<hr>
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
]]></content>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo插件hexo-graph的使用</title>
    <url>/posts/1bd5413e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记一下文章&quot;关于&quot;页的书写</p>
<p>插件地址<a href="https://github.com/codepzj/hexo-graph">codepzj/hexo-graph: hexo-graph，一个基于echarts，集成博客热力图，博客月份统计图，分类统计图，标签统计图的多元化插件。</a></p>
</p>
    </div>
</div><span id="more"></span>
<p>略</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>折腾 hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客中使用的脚注功能</title>
    <url>/posts/c6910d47.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下博客中脚注配置的相关内容</p>
</p>
    </div>
</div><span id="more"></span>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<ol>
<li class="lvl-3">打开 hexo 官方插件页面 <a href="https://hexo.io/plugins/">Plugins</a></li>
<li class="lvl-3">搜索 <code>footnotes</code> 并安装 <a href="https://github.com/kchen0x/hexo-reference">hexo-reference</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure>
<p>配置根目录 <code>_config.yml</code> 文件，新增一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-reference</span><br></pre></td></tr></table></figure>
<h4>参考文档</h4>
<p><a href="https://kchen.cc/2016/11/10/footnotes-in-hexo/#fnref:4">Hexo 里的脚注插件</a></p>
<p>—— 摘自 <a href="https://toypipi.github.io/2024/05/10/hexo-%E5%A2%9E%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%8A%9F%E8%83%BD/">hexo 增加脚注功能 | Toypipi’s blog</a></p>
</p>
    </div>
</div><h2 id="修改footnote脚注样式"><a class="header-anchor" href="#修改footnote脚注样式">¶</a>修改footnote脚注样式</h2>
<p>由于笔者实在是不太喜欢<code>hexo-reference</code>提供的红色的<code>footnote</code>然后鉴于笔者是使用插件渲染<code>footnote</code>的，所以笔者就准备对插件的代码做一下改造：</p>
<ol>
<li class="lvl-3">
<p>我们先进入博客根目录下的<code>/node_modules/hexo-reference</code></p>
<p><small>没错，笔者准备对这个插件进行修改</small></p>
</li>
<li class="lvl-3">
<p>然后查看文件<code>index.js</code></p>
<p><small>不出意外的话这个一般是插件的入口文件</small></p>
<p>我们看到这个文件前有一段<code>js</code>引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renderFootnotes = <span class="built_in">require</span>(<span class="string">&#x27;./src/footnotes&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没错，笔者在看完其后代码之后认为核心渲染程序应该在</p>
<p><code>./src/footnotes</code></p>
</li>
<li class="lvl-3">
<p>然后我们找到这个文件，即插件根目录下的<code>/src/footnotes.js</code>文件，笔者打开了它并把<code>hint--error</code>给删了</p>
</li>
<li class="lvl-3">
<p>然后就好了</p>
</li>
</ol>
<p><small>其实笔者在记录过程是一边做一边写的，<u>所幸笔者猜对了</u></small></p>
<p><small>Oops! 笔者在阅读代码的时候发现这个插件好像依赖插件<code>markdown-it</code></small></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>折腾hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本博客的客制化css</title>
    <url>/posts/d9cd1415.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>当然是记一些关于本博客客制化<code>css</code>相关的内容啦</p>
</p>
    </div>
</div><span id="more"></span>
<p><strong>由于之前说到<a href="/posts/4179">用自定义渲染器渲染<code>callout</code></a></strong></p>
<p>但是其中其实还有一个问题有待解决：</p>
<p><big>如何将自定义的<code>callout</code>样式块渲染出来</big></p>
<p><small>这里指的是，<code>Markdown</code>已经成功的转换成显示在网站中的<code>html</code>代码块了</small></p>
<p>但是实际上我们发现，解析的<code>html</code>我们确实有了，但是<code>callout</code>并非是我们想要的样式，而是一个并没有进行任何着色的状态。</p>
<h2 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义<code>css</code>样式</h2>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>2.1 添加客制化css</h3>
<p>虽然在<code>css</code>目录下任意<code>.styl</code>下添加<code>css</code>样式代码可以生效，但是为了方便以后修改，最好创建一个新的<code>.styl</code>文件记录自己的修改。</p>
<ol>
<li class="lvl-3">
<p>在<code>themes/next/source/css/main.styl</code>最后加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;_custom/custom&quot;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>在<code>themes/next/source/css</code>目录下创建<code>_custom</code>文件夹；</p>
</li>
<li class="lvl-3">
<p>在目录<code>themes/next/source/css/_custom</code>下新建文件<code>custom.styl</code>。</p>
</li>
<li class="lvl-3">
<p>在<code>custom.styl</code>中添加<code>css</code>样式修改博客的<code>css</code>。</p>
</li>
</ol>
<p>—— 摘自 <a href="https://zachary116699.github.io/2024/05/09/hexo-next-css/">hexo-next主题配置css | 大水笔✰档案室</a></p>
</p>
    </div>
</div><p>然后就是将自己自定义的<code>css</code>样式放在里面</p>
<p>这里贴一下<code>callout</code>样式部分：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基础样式 */</span></span><br><span class="line"><span class="selector-class">.callout</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">4px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Info 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-info</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#3178c6</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e3f2fd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Warning 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-warning</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#e5a700</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff3e0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Error 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-error</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#d32f2f</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffebee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Success 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-success</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#2e7d32</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e8f5e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-note</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#673ab7</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ede7f6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tip 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-tip</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#009688</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0f2f1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，就好了，现在整个<code>callout</code>块的部分就完整了🙌</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾hexo</title>
    <url>/posts/8dc8b2ab.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>OS-习题精析</title>
    <url>/posts/ac0632b5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一些操作系统课堂习题的思考</p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<ol>
<li class="lvl-3">
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231033601.png" alt="image-20241219191642448"></p>
<p>正解B，</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>程序是否能够运行，除了装入主存（RAM）以外，还需要满足以下几个条件：</p>
<ol>
<li class="lvl-3">
<p><strong>程序必须经过编译或解释</strong></p>
<ul class="lvl-3">
<li class="lvl-5">如果是编译型语言（如 C、C++、Java 等），程序需要先被编译为可执行的机器码。</li>
<li class="lvl-5">如果是解释型语言（如 Python、JavaScript），需要一个解释器在运行时逐行解释代码。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>依赖的操作系统和环境支持</strong></p>
<ul class="lvl-3">
<li class="lvl-5">程序需要运行在支持的操作系统环境下，例如 Windows、Linux 或 macOS。</li>
<li class="lvl-5">如果程序依赖特定的运行时环境（如 Java 的 JVM 或 .NET 的 CLR），必须确保这些环境已安装且版本兼容。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>所需资源的可用性</strong></p>
<ul class="lvl-3">
<li class="lvl-5">程序运行需要 CPU 时间片、内存空间和其他硬件资源。如果系统资源不足，程序可能无法正常运行。</li>
<li class="lvl-5">如果程序依赖外部文件、数据库或网络服务，这些资源也需要可用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>入口地址或执行点明确</strong></p>
<ul class="lvl-3">
<li class="lvl-5">程序需要有明确的入口点（如主函数 <code>main()</code> 或脚本的起始点）。在操作系统加载程序时，它需要知道从哪里开始执行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>程序权限满足要求</strong></p>
<ul class="lvl-3">
<li class="lvl-5">程序需要足够的权限访问主存、外部设备或系统功能。如果权限不足，可能无法运行或只能部分功能正常。</li>
</ul>
</li>
</ol>
<p>如果仅仅是装入主存而未满足以上条件，程序将无法正确运行。</p>
<p>——GPT</p>
</p>
    </div>
</div><ol start="2">
<li class="lvl-3">
<p>程序获得CPU执行的两个条件是？</p>
<ul class="lvl-2">
<li class="lvl-5">程序进入内存</li>
<li class="lvl-5">程序待执行指令的内存地址设为PC寄存器的值</li>
</ul>
</li>
<li class="lvl-3">
<p>在程序执行时，如果两个并发程序同时访问并修改同一个全局变量时，程序结果会不确定，但如果程序并不相互干涉及，就不会影响程序结果</p>
</li>
<li class="lvl-3">
<p>程序在并发运行的过程中并不具有封闭性，这是因为多个程序会共享资源，导致他们的执行相互影响</p>
</li>
<li class="lvl-3">
<p>A、B两个程序并发执行必须先满足的条件：即每个程序的写集均与其他进程的读/写集均无交集</p>
</li>
<li class="lvl-3">
<p>进程可以并发执行，而程序像是进程的规则，由程序可以创建很多可以运行的进程，以执行程序所规定的任务</p>
</li>
<li class="lvl-3">
<p>若系统为单处理机系统，现在共有$n$个用户进程</p>
<p>则处于就绪状态的用户进程最多有$n-1$个<small>（如果所有进程均处于就绪状态，则一定有一个进程会被CPU拿去执行）</small></p>
<p>处于阻塞的进程一共有$n$个<small>（发生死锁）</small></p>
</li>
<li class="lvl-3">
<p>一个进程被唤醒，仅意味着该进程变为就绪状态，并不意味着进程重新占用CPU</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/posts/cd647b6c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>操作系统复习笔记的章节目录</p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131555663.png" alt="image-20241213155517713"></p>
<h4 id="操作系统章节目录"><a class="header-anchor" href="#操作系统章节目录">¶</a>操作系统章节目录</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/posts/6070b0ed">第五章</a></p>
</li>
<li class="lvl-2">
<p><a href="/posts/b90b7ae5">第六章</a></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>速成笔记</title>
    <url>/posts/1f328572.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一些选择填空会出的点</p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="操作系统概述"><a class="header-anchor" href="#操作系统概述">¶</a>操作系统概述</h2>
<h3 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h3>
<h6 id="操作系统四个基本特征"><a class="header-anchor" href="#操作系统四个基本特征">¶</a>操作系统四个基本特征</h6>
<p>并发、共享、虚拟、异步</p>
<h5 id="操作系统的主要功能包括"><a class="header-anchor" href="#操作系统的主要功能包括">¶</a>操作系统的主要功能包括</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>处理机管理</p>
</li>
<li class="lvl-2">
<p>存储管理</p>
</li>
<li class="lvl-2">
<p>设备管理</p>
</li>
<li class="lvl-2">
<p>文件管理</p>
</li>
<li class="lvl-2">
<p>用户接口</p>
</li>
</ul>
<h6 id="人机交互的历程"><a class="header-anchor" href="#人机交互的历程">¶</a>人机交互的历程</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>手工操作阶段</p>
<ul class="lvl-2">
<li class="lvl-4">人机速度矛盾</li>
</ul>
</li>
<li class="lvl-2">
<p>单道批处理阶段</p>
<ul class="lvl-2">
<li class="lvl-4">系统资源利用率还是很低</li>
</ul>
</li>
<li class="lvl-2">
<p>多道批处理阶段</p>
<ul class="lvl-2">
<li class="lvl-4">缺乏人机交互，进程运行无法终止</li>
</ul>
</li>
<li class="lvl-2">
<p>分时操作系统</p>
<ul class="lvl-2">
<li class="lvl-4">不支持插队，不能处理紧急事件</li>
<li class="lvl-4">分时系统中，时间片一定，用户数越多，响应时间越长
<ul class="lvl-4">
<li class="lvl-6"><small>分时系统中，像是给每个用户分一个时间片，排队的进行访问，故用户数越多，排到的时间越长，响应时间越长</small></li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>实时操作系统</p>
</li>
</ul>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特权指令</strong>：不允许用户程序使用（只允许操作系统使用）如IO指令，中断进程</p>
</li>
<li class="lvl-2">
<p><strong>非特权指令</strong>：普通的运算指令</p>
</li>
<li class="lvl-2">
<p><strong>内核程序</strong>：系统的管理者，可执行一切指令、运行在核心态</p>
</li>
<li class="lvl-2">
<p><strong>应用程序</strong>：普通引用程序只能执行非特权指令，运行在用户态</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>还有一个**“访管指令”**，访管指令是在用户态使用的，该指令的还以是用户资源进入核心态。</p>
<p>核心态无需再次进入核心态</p>
<p>故，CPU处于核心态时，它可以执行出“访管”指令外的全部指令</p>
</p>
    </div>
</div><h3 id="处理机状态"><a class="header-anchor" href="#处理机状态">¶</a>处理机状态</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户态（目态）：CPU只能执行非特权指令</p>
</li>
<li class="lvl-2">
<p>核心态（又称管态、内核态）：可以执行所有指令</p>
</li>
<li class="lvl-2">
<p>用户态到核心态：通过中断（是硬件完成的）</p>
</li>
</ul>

<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>用户态到核心态的转换时通过中断，即硬件完成的，并不是操作系统，也不是中断处理程序。</p>
<p>核心态到用户态的转换，是通过操作系统完成的。</p>
</p>
    </div>
</div><h3 id="原语"><a class="header-anchor" href="#原语">¶</a>原语</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>处在操作系统最底层，是最接近硬件的部分</p>
</li>
<li class="lvl-2">
<p>这些程序的运行具有原子性其操作只能一气喝成</p>
</li>
<li class="lvl-2">
<p>这些程序的运行时间都较短，而且调用频繁</p>
</li>
</ul>
<h3 id="中断、系统调用、体系结构"><a class="header-anchor" href="#中断、系统调用、体系结构">¶</a>中断、系统调用、体系结构</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内中断（异常，信号来自内部）</p>
<ul class="lvl-2">
<li class="lvl-4">自愿中断————指令中断</li>
<li class="lvl-4">强迫中断：硬件中断、软件中断（eg：0/0）</li>
</ul>
</li>
<li class="lvl-2">
<p>外中断（中断，信号来自于外部）：外设请求、人工干预（打印机）</p>
</li>
<li class="lvl-2">
<p>系统调用：</p>
<ul class="lvl-2">
<li class="lvl-4">系统给程序员（应用程序）提供的唯一接口，可获得OS的服务，在用户态发生核心态处理</li>
</ul>
</li>
<li class="lvl-2">
<p>体系结构：大内核、微内核</p>
</li>
</ul>
<h2 id="进程管理"><a class="header-anchor" href="#进程管理">¶</a>进程管理</h2>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>进程的组成</h4>
<p>包括程序、数据、进程控制块</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412241452727.png" alt="image-20241224145205278"></p>
<h3 id="处理机调度"><a class="header-anchor" href="#处理机调度">¶</a>处理机调度</h3>
<p>是对处理机进行分配，即从就绪队列中按照指定的算法，选择一个进程并将处理机分配给它运行，以实现进程并发的执行</p>
<h4 id="分类"><a class="header-anchor" href="#分类">¶</a>分类</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>高级调度（作业调度</p>
</li>
<li class="lvl-2">
<p>中级调度（内存置换</p>
</li>
<li class="lvl-2">
<p>多级调度（进程调度</p>
</li>
</ul>
<h3 id="进程同步"><a class="header-anchor" href="#进程同步">¶</a>进程同步</h3>
<h4 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>协调进程之间相互制约关系</p>
</li>
</ul>
<h4 id="制约关系"><a class="header-anchor" href="#制约关系">¶</a>制约关系</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>同步</strong>：进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作层次而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作</p>
</li>
<li class="lvl-2">
<p><strong>互斥</strong>：也称间接制约关系。当一个进程进入临界区使用临界资源时，另给进程必须等待，当占用临界资源的进程退出临界区后，另进程才允许去访问此临界资源</p>
</li>
</ul>
<h4 id="临界资源"><a class="header-anchor" href="#临界资源">¶</a>临界资源</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>一次仅允许一个进程使用的资源</p>
</li>
</ul>
<h4 id="临界区"><a class="header-anchor" href="#临界区">¶</a>临界区</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>在每个进程访问临界资源的那段程序，当多个线程并发执行时，如果它们都能够访问和修改同一资源，就可能导致数据的不一致和程序的错误行为。为了避免这种情况，临界区通常通过限制同时执行这段代码的线程数量，来确保对共享资源的访问是互斥的</p>
</li>
</ul>
<h5 id="临界区的作用"><a class="header-anchor" href="#临界区的作用">¶</a>临界区的作用</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>保护共享资源</p>
</li>
<li class="lvl-2">
<p>防止竞态条件</p>
</li>
<li class="lvl-2">
<p>提高程序稳定性</p>
</li>
</ul>
<p>临界区的实现通常依赖于同步机制，如互斥锁、信号量、或条件变量</p>
<h4 id="同步机制"><a class="header-anchor" href="#同步机制">¶</a>同步机制</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥锁</strong>（Mutex）：互斥锁是最常用的同步机制之一。当一个线程进入临界区时，它会获取一个互斥锁；当进程退出临界区时，它会释放互斥锁。其他进程进入临界区时，如果锁已被占用，则会被阻塞，直到互斥锁被释放</p>
</li>
<li class="lvl-2">
<p><strong>信号量</strong>（Semaphore）：信号量是一种<em>更通用</em>的同步机制，它可以用来控制多个线程对多个资源的访问。在临界区场景中，信号量可以被设置为1，以模拟互斥锁的行为</p>
</li>
<li class="lvl-2">
<p><strong>条件变量</strong>（Condition Variable）：条件变量通常与互斥锁一起使用，用于在多个进程之间传递信号。虽然条件变量不直接用于实现临界区，但它可以在线程鞥带进入临界区时提供有效的等待和唤醒机制</p>
</li>
</ul>
<h4 id="临界区互斥"><a class="header-anchor" href="#临界区互斥">¶</a>临界区互斥</h4>
<h5 id="原则"><a class="header-anchor" href="#原则">¶</a>原则</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>空闲让进</p>
</li>
<li class="lvl-2">
<p>忙则等待</p>
</li>
<li class="lvl-2">
<p>有限等待</p>
</li>
<li class="lvl-2">
<p>让权等待</p>
</li>
</ul>
<h4 id="PV操作"><a class="header-anchor" href="#PV操作">¶</a>PV操作</h4>
<blockquote>
<p>PV必须成对出现</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412241626925.png" alt="image-20241224162602748"></p>
<h4 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h4>
<h5 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h5>
<p>多个进程因争夺资源而造成的一种僵局，如果没有外力，这些进程将无法推进</p>
<h5 id="产生的原因"><a class="header-anchor" href="#产生的原因">¶</a>产生的原因</h5>
<p>非剥夺资源的竞争和进程的不恰当推进顺序</p>
<h5 id="必要的条件"><a class="header-anchor" href="#必要的条件">¶</a>必要的条件</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>互斥</p>
</li>
<li class="lvl-2">
<p>环路等待</p>
</li>
<li class="lvl-2">
<p>不可剥夺</p>
</li>
<li class="lvl-2">
<p>请求和保持</p>
</li>
</ul>
<h5 id="解决方法"><a class="header-anchor" href="#解决方法">¶</a>解决方法</h5>
<ol>
<li class="lvl-3">
<p>预防死锁</p>
<ul class="lvl-2">
<li class="lvl-5">破坏互斥条件</li>
<li class="lvl-5">破坏不剥夺条件</li>
<li class="lvl-5">破坏请求和保持条件</li>
<li class="lvl-5">破坏循环等待条件</li>
</ul>
</li>
<li class="lvl-3">
<p>避免死锁</p>
<ul class="lvl-2">
<li class="lvl-5">安全状态、银行家算法</li>
</ul>
</li>
<li class="lvl-3">
<p>检测死锁</p>
<ul class="lvl-2">
<li class="lvl-5">利用死锁定理</li>
</ul>
</li>
<li class="lvl-3">
<p>解除死锁</p>
<ul class="lvl-2">
<li class="lvl-5">资源剥夺法</li>
<li class="lvl-5">撤销进程法</li>
<li class="lvl-5">进程回退法</li>
</ul>
</li>
</ol>
<h2 id="内存管理"><a class="header-anchor" href="#内存管理">¶</a>内存管理</h2>
<h3 id="内存管理的目的和意义"><a class="header-anchor" href="#内存管理的目的和意义">¶</a>内存管理的目的和意义</h3>
<h4 id="引入目的"><a class="header-anchor" href="#引入目的">¶</a>引入目的</h4>
<p>更好的至此多道程序的并发执行，提高系统性能</p>
<h4 id="主要功能"><a class="header-anchor" href="#主要功能">¶</a>主要功能</h4>
<ol>
<li class="lvl-3">
<p>内存空间的分配与回收</p>
</li>
<li class="lvl-3">
<p>存储的保护与共享</p>
<p><small>保证各道作业在各自的存储空间内运行，互不干扰</small></p>
</li>
<li class="lvl-3">
<p>地址变换</p>
<p><small>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</small></p>
</li>
<li class="lvl-3">
<p>内存扩充</p>
<p><small>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</small></p>
</li>
</ol>
<h3 id="用户程序的主要处理阶段"><a class="header-anchor" href="#用户程序的主要处理阶段">¶</a>用户程序的主要处理阶段</h3>
<ol>
<li class="lvl-3">
<p><strong>编辑阶段</strong>：创建源文件</p>
</li>
<li class="lvl-3">
<p><strong>编译阶段</strong>：由编译程序将用户进程源代码编译成若干目标模块，生成目标文件</p>
</li>
<li class="lvl-3">
<p><strong>链接阶段</strong>：由链接程序编译后形成的一组目标模块及所需的库函数链接到一起，形成一个完整的装入模块，生成可执行文件</p>
</li>
<li class="lvl-3">
<p><strong>装入阶段</strong>：由装入程序将装入模块装入内存运行</p>
</li>
<li class="lvl-3">
<p><strong>运行阶段</strong>：</p>
</li>
</ol>
<h3 id="相关概念"><a class="header-anchor" href="#相关概念">¶</a>相关概念</h3>
<h4 id="程序的装入"><a class="header-anchor" href="#程序的装入">¶</a>程序的装入</h4>
<h5 id="绝对装入"><a class="header-anchor" href="#绝对装入">¶</a>绝对装入</h5>
<p>在编译时，如果知道程序将驻留在内存什么位置，那么，编译程序将产生绝对地址的目标代码。即按照物理内存的位置赋予实际的物理地址</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优点</strong>：在时间上效率很高</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：</p>
<ol>
<li class="lvl-5">由于内存大小限制，能够装入内存的并发执行的进程大大减少</li>
<li class="lvl-5">编译程序必须知道内存当前空闲地址部分和其地址，而在多道程序下，编译程序根本不可能知道当前空闲地址的部分，因此绝对装入方式只适用于弹道程序环境</li>
</ol>
</li>
</ul>
<h5 id="静态重定位"><a class="header-anchor" href="#静态重定位">¶</a>静态重定位</h5>
<p>在程序装入对目标代码装入内存的过程中完成，是指在程序开始运行前，程序中指令数据的各个地址均已完成重定位，即完成虚拟地址到内存地址的映射。地址变换通常是在装入时一次完成的，以后不会改变</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优点</strong>：不需要硬件支持（这里的硬件，指的是后文提到的重定位寄存器）（对比动态重定位）</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：程序在静态重定位之后就不能在内存中搬动了，并且要求程序的存储空间是连续的（对比动态重定位）</p>
</li>
</ul>
<h5 id="动态重定位"><a class="header-anchor" href="#动态重定位">¶</a>动态重定位</h5>
<p>动态重定位的方式是把地址转换推迟到程序真正执行时才进行。但这种方式需要硬件支持，也就是重定位寄存器的支持，否则会影响指令执行速度</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>优点</strong>：可以解决碎片问题。（因为不需要像静态重定位一样要求程序装入，每个模块之间的存储位置不一定需要相联，只需要由自己的重定位寄存器就行）</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：需要硬件支持</p>
</li>
</ul>
<h4 id="程序的链接"><a class="header-anchor" href="#程序的链接">¶</a>程序的链接</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>静态链接</strong>：在程序运行之前，先将各目标及他们所需要的库函数链接生成一个完整的可执行程序，以后不在拆开</p>
</li>
<li class="lvl-2">
<p><strong>装入式链接</strong>：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式</p>
</li>
<li class="lvl-2">
<p><strong>运行时链接</strong>：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点时便于修改和更新，便于实现对目标模块的共享。</p>
</li>
</ul>
<h3 id="内存空间的分配与回收"><a class="header-anchor" href="#内存空间的分配与回收">¶</a>内存空间的分配与回收</h3>
<h4 id="连续分配管理方式"><a class="header-anchor" href="#连续分配管理方式">¶</a>连续分配管理方式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>单一连续分配</strong>：分配到内存固定的区域（单用户/单任务的操作系统）</p>
</li>
<li class="lvl-2">
<p><strong>固定连续分配</strong>：分配到内存不同的固定区域，分区可以相等可以不等，但要求一定是固定。</p>
</li>
<li class="lvl-2">
<p><strong>动态连续分区</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">最佳适应</li>
<li class="lvl-4">最坏适应</li>
<li class="lvl-4">邻近适应</li>
</ul>
</li>
</ul>
<h4 id="分页分段"><a class="header-anchor" href="#分页分段">¶</a>分页分段</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242008474.png" alt="image-20241224200835246"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242008621.png" alt="image-20241224200851462"></p>
<h4 id="页面置换算法"><a class="header-anchor" href="#页面置换算法">¶</a>页面置换算法</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242012043.png" alt="image-20241224201231675"></p>
<h2 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h2>
<p>文件是以计算机硬盘为载体的存储在计算机上的信息集合</p>
<p>文件系统：就是操作系统中负责操纵和管理文件的一整套设施，它实现文件的共享和保护，方便文件“<strong>按名</strong>存取”</p>
<h3 id="功能"><a class="header-anchor" href="#功能">¶</a>功能</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件管理</p>
</li>
<li class="lvl-2">
<p>目录管理</p>
</li>
<li class="lvl-2">
<p>文件空间管理</p>
</li>
<li class="lvl-2">
<p>文件共享和保护</p>
</li>
<li class="lvl-2">
<p>提供方便的接口</p>
</li>
</ul>
<h3 id="文件的逻辑结构"><a class="header-anchor" href="#文件的逻辑结构">¶</a>文件的逻辑结构</h3>
<ol>
<li class="lvl-3">
<p>无结构文件</p>
<ul class="lvl-2">
<li class="lvl-5">无结构文件按顺序组织起记录并积累保存，他是有序相关信息项的集合，以字节为单位（或称，字节流文件）</li>
</ul>
</li>
<li class="lvl-3">
<p>有结构文件（记录式文件）</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>顺序文件</strong>：文件中的记录一个接一个的顺序排列，在访问时需要顺序搜索文件</li>
<li class="lvl-5"><strong>索引文件</strong>：通过一个索引表来检索文件</li>
<li class="lvl-5"><strong>索引顺序文件</strong>：上述两者结合</li>
</ul>
</li>
</ol>
<h3 id="目录和目录结构"><a class="header-anchor" href="#目录和目录结构">¶</a>目录和目录结构</h3>
<h4 id="文件控制块"><a class="header-anchor" href="#文件控制块">¶</a>文件控制块</h4>
<p>在文件系统内部给每个文件唯一的设置一个文件控制块，它用于描述和控制文件的数据结构，与文件一一对应</p>
<p><strong>FCB</strong>中包含了文件的基本信息（文件名，物理地址，逻辑地址，物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p>
<p>最重要，最基本的还是文件名、文件存放的物理地址。</p>
<h4 id="目录结构"><a class="header-anchor" href="#目录结构">¶</a>目录结构</h4>
<p>单级目录，二级目录，树形目录，图形目录</p>
<h3 id="文件实现"><a class="header-anchor" href="#文件实现">¶</a>文件实现</h3>
<h4 id="文件分配方式"><a class="header-anchor" href="#文件分配方式">¶</a>文件分配方式</h4>
<p>连续分配，链接分配，索引分配</p>
<p>对应的结构分别是顺序结构，链式结构，索引结构</p>
<h4 id="文件存储空间管理"><a class="header-anchor" href="#文件存储空间管理">¶</a>文件存储空间管理</h4>
<ol>
<li class="lvl-3">
<p>空闲表法</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242040875.png" alt="image-20241224204044181"></p>
</li>
<li class="lvl-3">
<p>空闲链表法</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242041014.png" alt="image-20241224204144283"></p>
</li>
<li class="lvl-3">
<p>位示图法</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412242042366.png" alt="image-20241224204252872"></p>
</li>
</ol>
<h3 id="磁盘管理"><a class="header-anchor" href="#磁盘管理">¶</a>磁盘管理</h3>
<h4 id="磁盘的物理结构"><a class="header-anchor" href="#磁盘的物理结构">¶</a>磁盘的物理结构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>柱面号、盘面号、扇面号</p>
</li>
</ul>
<h4 id="磁盘调度算法"><a class="header-anchor" href="#磁盘调度算法">¶</a>磁盘调度算法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>先来先服务（FCFS</p>
</li>
<li class="lvl-2">
<p>最短查找时间优先算法（SSTF</p>
</li>
<li class="lvl-2">
<p>扫描算法（电梯算法（SCAN</p>
</li>
<li class="lvl-2">
<p>循环扫描算法（CSCAN</p>
</li>
</ul>
<h2 id="设备管理"><a class="header-anchor" href="#设备管理">¶</a>设备管理</h2>
<h3 id="目标"><a class="header-anchor" href="#目标">¶</a>目标</h3>
<p>使用方便、与设备无关、效率高、管理统一</p>
<h3 id="IO设备"><a class="header-anchor" href="#IO设备">¶</a>IO设备</h3>
<h4 id="分类-2"><a class="header-anchor" href="#分类-2">¶</a>分类</h4>
<p>存储设备或者输入输出设备、块设备或字节设备、低速中高速设备。</p>
<h4 id="IO控制方式"><a class="header-anchor" href="#IO控制方式">¶</a>IO控制方式</h4>
<ol>
<li class="lvl-3">
<p><strong>程序直接控制方式</strong>（查询方式</p>
<p>CPU不断的去查询设备控制器是否将数据放到了数据存储器中，或者从数据存储器存到设备中，当完成IO时CPU才能去干别的事</p>
</li>
<li class="lvl-3">
<p><strong>中断方式</strong>：</p>
<p>这种方式当CPU发出指令后就可以去干别的时，当设备控制器把数据存在数据寄存器后向CPU发出中断请求，然后CPU再来处理这部分数据。</p>
</li>
<li class="lvl-3">
<p><strong>DMA方式</strong>：</p>
<p>虽然中断方式提高了CPU的利用率，但是数据基础器有限，中断是<em>以字节单位进行中断</em>，也就是说读取或存储一个字节后就需要进行中断，那么其实CPU的利用率还是很低的，所以就诞生了DMA方式，这种方式由DMA控制器直接将设备中的数据<strong>以数据块为单位</strong>直接传输到内存中，当传输结束后才向CPU发起总段</p>
</li>
<li class="lvl-3">
<p><strong>IO通道控制方式</strong>：</p>
<p>DMA虽然大大提升了CPU的利用率，但是DMA只能传输一个连续的数据块。所以引入了IO通道的控制方式，IO通道控制方式可以传输不连续的数据块，减少了CPU干预。CPU通过对IO通道发出指令，然后让IO通道自己工作，等待数据传输完才向CPU发起中断</p>
</li>
</ol>
<h3 id="缓冲区"><a class="header-anchor" href="#缓冲区">¶</a>缓冲区</h3>
<h4 id="引入目的-2"><a class="header-anchor" href="#引入目的-2">¶</a>引入目的</h4>
<ol>
<li class="lvl-3">
<p>缓和CPU与外设间速度不匹配的矛盾</p>
</li>
<li class="lvl-3">
<p>提高CPU与外设之间的并行性</p>
</li>
<li class="lvl-3">
<p>减少CPU的中断次数</p>
</li>
</ol>
<h4 id="设置方式"><a class="header-anchor" href="#设置方式">¶</a>设置方式</h4>
<ol>
<li class="lvl-3">
<p><strong>单缓冲</strong></p>
<p>当数据到达率与离去率相差很大时，可采用单缓冲方式</p>
</li>
<li class="lvl-3">
<p><strong>双缓冲</strong></p>
<p>当信息输入和输出率相同（或相差不大）时，可利用双缓冲区，实现两者的并行</p>
</li>
<li class="lvl-3">
<p><strong>多缓冲</strong></p>
<p>对应阵发性的输入、输出，为了解决速度不匹配问题，可以建立多个缓冲区</p>
</li>
</ol>
<h3 id="设备的分类"><a class="header-anchor" href="#设备的分类">¶</a>设备的分类</h3>
<ol>
<li class="lvl-3">
<p>独占设备：</p>
<p>不能共享的设备，即：在一段时间内，该设备只允许一个进程独占。如打印机</p>
</li>
<li class="lvl-3">
<p><strong>共享设备</strong>：</p>
<p>可由若干各进程同时共享的设备，如磁盘</p>
</li>
<li class="lvl-3">
<p><strong>虚拟设备</strong>：</p>
<p>是利用某种技术把独占设备改造成可由多个进程共享的设备</p>
</li>
</ol>
<h3 id="三种分配技术"><a class="header-anchor" href="#三种分配技术">¶</a>三种分配技术</h3>
<ol>
<li class="lvl-3">
<p><strong>独占分配技术</strong></p>
</li>
<li class="lvl-3">
<p><strong>共享分配技术</strong>：通常用于高速、大容量的直接存取存储设备</p>
</li>
<li class="lvl-3">
<p><strong>虚拟分配技术</strong>：利用共享设备去模拟独占设备，从而使独占设备变成可共享的、快速IO的设备。实现虚拟分配的最有名的是SPOOLing技术，也称作假脱机操作</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>
]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计组-补</title>
    <url>/posts/9b5bdad6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一些散装知识点</p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h4 id="变量所占的存储长度"><a class="header-anchor" href="#变量所占的存储长度">¶</a>变量所占的存储长度</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>double：占64位</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>计网-章节复习目录</title>
    <url>/posts/74ea9067.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/posts/f4cb0304">1.1计算机网络概论</a></p>
</li>
<li class="lvl-2">
<p><a href="/posts/ec7daff7">1.2 网络体系结构与网络协议</a></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>计网复习</title>
    <url>/posts/1be102e0.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>根据PPT复习一下计网知识</p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="计算题"><a class="header-anchor" href="#计算题">¶</a>计算题</h2>
<h3 id="奈奎斯特定理和香农定理的计算"><a class="header-anchor" href="#奈奎斯特定理和香农定理的计算">¶</a>奈奎斯特定理和香农定理的计算</h3>
<ol>
<li class="lvl-3">
<p>奈奎斯特定理：$R_b = 2H*log_2V \ (bps)$</p>
</li>
<li class="lvl-3">
<p>香农定理：$R_b = H*log_2(1+S/N)\ (bps)$</p>
</li>
</ol>
<p>$R_b$：信道的最高数据传输速率</p>
<p>$V$：码元状态数</p>
<p>$H$：信道带宽</p>
<p>$S/N$：信噪比</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>信噪比$S/N$单位较小，通常以<span style="color:red">分贝</span>的形式给出，需要转换</p>
<h4>分贝</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271334036.png" alt="image-20241227133452940"></p>
</p>
    </div>
</div><h3 id="CRC校验码"><a class="header-anchor" href="#CRC校验码">¶</a>CRC校验码</h3>
<ol>
<li class="lvl-3">
<p>已知：被传输数据块<em>DATA</em>，除数<em>P</em>或<em>生成多项式$G(X)$</em></p>
<ol>
<li class="lvl-6">求CRC校验码</li>
<li class="lvl-6">求最终被传送的数据</li>
</ol>
</li>
<li class="lvl-3">
<p>已知：接收方收到的数据和除数P，判断该数是否出错</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>余数比校验码少一位！</p>
</p>
    </div>
</div><blockquote>
<p><strong>例题</strong> <strong>P112 3-07 3-08</strong></p>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h6>例题 P112 3-07</h6>
<p>要发送的数据为 $101110$ 。采用 $CRC$ 校验码的生成多项式是 $P(X) = X^3 + 1$ 试求添加在数据后面的余数</p>
<p><mark>注意！$X^3 + 1$ 对应的校验码为 $\overset31 \overset20 \overset10 \overset01$ 而非 $\overset21 \overset10 \overset01$。</mark></p>
</p>
    </div>
</div><h3 id="CSMA-CD协议中最段帧长度的计算"><a class="header-anchor" href="#CSMA-CD协议中最段帧长度的计算">¶</a>CSMA/CD协议中最段帧长度的计算</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>P113 3-20 冲突窗口的计算</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h6>以太网最小帧长度问题</h6>
<p>$$<br>
\underset{\text帧的传播时长}t = \text数据帧长度 / \text数据传输速率\<br>
\underset{\text信号传播时延}T = \text两站点的距离 / \text信号传播速度\<br>
\underset{\text保证在帧的传输过程中检测到冲突}{t &gt;= 2*T}<br>
$$</p>
<p>即，保证在冲突信号发回时，帧还没有发完</p>
<p>即帧的发送时长大于信号传播时延的两倍</p>
</p>
    </div>
</div><h3 id="发送时延和传播时延的计算"><a class="header-anchor" href="#发送时延和传播时延的计算">¶</a>发送时延和传播时延的计算</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>P39 1-17</p>
</li>
</ul>
<h3 id="已知IP地址和子网掩码，判断两个IP地址是否在同一个网络内，或者计算广播地址、可用地址范围等"><a class="header-anchor" href="#已知IP地址和子网掩码，判断两个IP地址是否在同一个网络内，或者计算广播地址、可用地址范围等">¶</a>已知IP地址和子网掩码，判断两个IP地址是否在同一个网络内，或者计算广播地址、可用地址范围等</h3>
<h4 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h4>
<p>已知主机1的IP地址为146.26.27.71；</p>
<p>主机2的地址为146.26.27.170；</p>
<p>子网掩码均为255.255.255.192；</p>
<p>判断：主机1与主机2是否处于同一个网段</p>
<h3 id="CDMA的计算"><a class="header-anchor" href="#CDMA的计算">¶</a>CDMA的计算</h3>
<p>P70 2-16</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>CDMA</h5>
<p>即，码分复用</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个站分配的码片序列不仅必须各不相同，并且还必须相互<strong>正交</strong></p>
</li>
<li class="lvl-2">
<p>两个不同站的码片序列正交，就是向量 $S$ 和 $T$ 的内积都是 $0$ (向量 $S$ 和 $T$ 的反码内积也为 $0$)<br>
$$<br>
S*T = \frac{1}{m} \overset{m}{\underset{i=1}{\sum}}S_iT_i = 0<br>
$$</p>
</li>
</ul>
<p>在求当前发送的信号对于特定的码片序列是否为1或0时，只需要将发送的信号与码片序列点乘<small><span style="color:red;">注意：要除以码片长度</span></small>。得到的结果如果是-1则为0，为1则为1，如果为0，则当前该码片序列并没有发送任何消息。</p>
</p>
    </div>
</div><h2 id="问答题"><a class="header-anchor" href="#问答题">¶</a>问答题</h2>
<h5 id="TCP-IP或OSI参考模型传递数据的过程，会根据具体网络应用分析数据的走向、封装过程"><a class="header-anchor" href="#TCP-IP或OSI参考模型传递数据的过程，会根据具体网络应用分析数据的走向、封装过程">¶</a>TCP/IP或OSI参考模型传递数据的过程，会根据具体网络应用分析数据的走向、封装过程</h5>
<p>P33 图1-17</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271518269.jpg" alt="f54b32298a5f86ba737ec2496093cea"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271518753.jpg" alt="2749cc5d931c064bab3d7bd2d129a25"></p>
<h5 id="多路复用技术的作用、分类、理解各类实现的原理"><a class="header-anchor" href="#多路复用技术的作用、分类、理解各类实现的原理">¶</a>多路复用技术的作用、分类、理解各类实现的原理</h5>
<p>信道复用是指在一条物理线路上同时传输多路信息</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>目的</strong>：提高通信线路的利用效率，降低通信成本</p>
</li>
<li class="lvl-2">
<p><strong>分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">频分多路复用（FDM）</li>
<li class="lvl-4">波分多路复用（WDM）</li>
<li class="lvl-4">时分多路复用（TDM）</li>
<li class="lvl-4"><span style="color:red;">码分多路复用（CDM）</span></li>
</ul>
</li>
</ul>
<h6 id="频分多路复用"><a class="header-anchor" href="#频分多路复用">¶</a>频分多路复用</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>原理</strong>：把传输介质的可用带宽分割为多个频段（子信道），分配给每一路输入信号，输入信号被调制成不同频率的信号，在子信道中传输。在子频段之间要留有一定的空闲频带，作为保护频带，减少各路信号之间的相互干扰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271532110.png" alt="image-20241227153201031"></p>
</li>
</ul>
<h6 id="波分多路复用"><a class="header-anchor" href="#波分多路复用">¶</a>波分多路复用</h6>
<p>光的频分多路复用</p>
<h6 id="时分多路复用"><a class="header-anchor" href="#时分多路复用">¶</a>时分多路复用</h6>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271623144.png" alt="image-20241227162314036"></p>
<p>P56</p>
<h5 id="CSMA-CD协议作用、工作原理、实现技术"><a class="header-anchor" href="#CSMA-CD协议作用、工作原理、实现技术">¶</a>CSMA/CD协议作用、工作原理、实现技术</h5>
<h6 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h6>
<p>解决多个站点链接到一条总线上，竞争使用总线时，碰撞冲突问题</p>
<h6 id="基本思想"><a class="header-anchor" href="#基本思想">¶</a>基本思想</h6>
<ol>
<li class="lvl-3">
<p>某站点想要发送数据，它必须首先侦听信道；</p>
</li>
<li class="lvl-3">
<p>如果信道空闲，立即发送数据；如果信道忙，则继续侦听信道，直到信道变为空闲，立即发送数据；</p>
</li>
<li class="lvl-3">
<p>站点在发送数据过程中继续检测信道，若一直未检测到碰撞，则把该数据成功发送完毕；如果检测到冲突，立即停止发送数据，发送干扰信号，然后执行指数退避算法，等待一随机长的时间重新侦听信道，返回第2步。</p>
</li>
</ol>
<h6 id="技术实现"><a class="header-anchor" href="#技术实现">¶</a>技术实现</h6>
<ol>
<li class="lvl-3">
<p>先听后发：<strong>载波侦听技术</strong></p>
<p>以太网采用<strong>曼彻斯特编码</strong>传送数据</p>
<p>编码本身带有同步信号</p>
</li>
<li class="lvl-3">
<p>边发边听：<strong>碰撞检测技术</strong></p>
</li>
<li class="lvl-3">
<p>冲突停止：<strong>发送干扰信号</strong></p>
</li>
<li class="lvl-3">
<p>延迟重发：<strong>截断二进制指数退避算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271640656.png" alt="image-20241227164013552"></p>
</li>
</ol>
<h5 id="能够根据题目要求，根据用户需求划分多个子网，且每个子网都能容纳足够多的主机，会求子网的网络地址、子网掩码、子网内可用IP地址范围、广播地址"><a class="header-anchor" href="#能够根据题目要求，根据用户需求划分多个子网，且每个子网都能容纳足够多的主机，会求子网的网络地址、子网掩码、子网内可用IP地址范围、广播地址">¶</a>能够根据题目要求，根据用户需求划分多个子网，且每个子网都能容纳足够多的主机，会求子网的网络地址、子网掩码、子网内可用IP地址范围、广播地址</h5>
<h5 id="路由表的查找、在构建路由表时会添加网络路由，特定主机路由和默认路由"><a class="header-anchor" href="#路由表的查找、在构建路由表时会添加网络路由，特定主机路由和默认路由">¶</a>路由表的查找、在构建路由表时会添加网络路由，特定主机路由和默认路由</h5>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h6>练习</h6>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261046404.png" alt="image-20241226104636869"></p>
</p>
    </div>
</div><h5 id="RIP路由协议的工作原理"><a class="header-anchor" href="#RIP路由协议的工作原理">¶</a>RIP路由协议的工作原理</h5>
<p>一种分布式的<strong>基于距离向量的路由选择协议</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>距离矢量路由选择算法</strong></p>
<ol>
<li class="lvl-5">
<p>路由表的结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271655358.png" alt="image-20241227165559264"></p>
</li>
<li class="lvl-5">
<p>路由表的初始化</p>
<p>初始时，每个路由器测量到达它周围邻居的距离，路由表中只有到邻居的信息；</p>
<p>通过与邻居不断交换路由表，最终获得到达全部路由器的距离和传输线路</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271659979.png" alt="image-20241227165905889"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271659394.png" alt="image-20241227165930314"></p>
</li>
<li class="lvl-5">
<p>路由表的更新</p>
<p>每个路由器不断与邻居交换路由表，获取最新的路由信息，更新自己的路由表</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271700099.png" alt="image-20241227170055986"></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>什么时候交换路由表？</p>
<p>周期性交换：每隔T时间路由器向邻居发送路由表</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>无穷计算问题（慢收敛）</p>
<p>距离矢量算法对拓扑变化的好消息反应迅速</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271705152.png" alt="image-20241227170512048"></p>
<p>距离矢量算法对拓扑变化的坏消息反应迟钝</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271706623.png" alt="image-20241227170614515"></p>
<ul class="lvl-4">
<li class="lvl-7">
<p>慢收敛的解决办法1：限定无穷大</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271707831.png" alt="image-20241227170700716"></p>
</li>
<li class="lvl-7">
<p>慢收敛解决办法2：水平分割</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271707087.png" alt="image-20241227170752875"></p>
</li>
<li class="lvl-7">
<p>慢收敛解决办法3：毒性反转+触发更新</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412271709543.png" alt="image-20241227170947448"></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h6 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>RIP协议是一种分布式的基于<strong>距离矢量路由选择算法</strong>的路由选择协议</p>
</li>
<li class="lvl-2">
<p>RIP协议中的“距离”也称为“<strong>跳数</strong>，每经过一个路由器，跳数就加1，优先选择到达目的的网络需要的跳数最少的路由</p>
</li>
<li class="lvl-2">
<p>RIP允许一条路径最多只能包含 15 个路由器。距离最大值为 16 。</p>
<p>当距离为 16 时，即相当于不可达</p>
<p><small>可见，RIP只适用于小型互联网</small></p>
</li>
</ul>
<p>P160 P4-37题</p>
<h5 id="交换机的数据转发机制"><a class="header-anchor" href="#交换机的数据转发机制">¶</a>交换机的数据转发机制</h5>
<ol>
<li class="lvl-3">
<p>交换机从端口X接收到数据帧A，获取其目的MAC地址MAC-A，判断帧A是否是广播域</p>
</li>
<li class="lvl-3">
<p>若帧A是广播帧，交换机向其他所有端口转发帧A</p>
</li>
<li class="lvl-3">
<p>若帧A不是广播帧：</p>
<p>根据帧A目的地址，搜索交换机表，查找MAC-A所连接的端口</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>查到MAC-A对应端口Y</strong></p>
<p>若XY为不同的端口，交换机将数据帧A转发到Y端口的缓冲队列；</p>
<p>若XY为同一端口，交换机丢失数据帧A（过滤）</p>
</li>
<li class="lvl-5">
<p><strong>查不到MAC-A对应的端口</strong></p>
<p>将数据帧A广播到除了输入端口外的其他所有端口</p>
<p><small>（若交换机表信息不足，网络将有大量的广播帧）</small></p>
</li>
</ul>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>对指定MAC单播时，只会像该IP对应端口进行转发，缩小了冲突域</p>
</li>
<li class="lvl-2">
<p>广播或转发表中找不到合适的转发端口时，才会对所有端口广播</p>
</li>
</ul>
<h6 id="交换机表的生成与维护"><a class="header-anchor" href="#交换机表的生成与维护">¶</a>交换机表的生成与维护</h6>
<ol>
<li class="lvl-3">
<p>交换机表初始为空</p>
</li>
<li class="lvl-3">
<p>当有主机生成数据帧发送到交换机某一端口，若表中没有关于该元MAC地址的记录，记录<mark>到达数据帧的源MAC地址、进入端口、到达时间</mark>，更新该记录（端口和时间）；</p>
<p><strong>如果每一个主机都发送过数据帧，在表中将有每个主机的记录</strong></p>
</li>
<li class="lvl-3">
<p>每当插入一条新纪录或更新一条记录时，就会设置一个定时器，当定时器超时，记录任没有被更新，就视为”过时“，删除</p>
<p><strong>有利于节省存储空间，及时反应当前网络状况</strong></p>
</li>
</ol>
<h6 id="避免环路——生成树协议（STP）"><a class="header-anchor" href="#避免环路——生成树协议（STP）">¶</a>避免环路——生成树协议（STP）</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>生成树协议STP</strong>要点：</p>
<p><strong>不改变</strong>网路实际拓扑，但<strong>在逻辑上</strong>则切断某些链路，使得从一台主机到所有其他主机的路径是**无环路的树形结构，**从而消除了兜圈子现象</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412280022082.png" alt="image-20241228002200973"></p>
</li>
</ul>
<p>P114 3-33</p>
<h5 id="理解并记忆TCP的“慢启动、拥塞避免”拥塞控制策略，会计算拥塞窗口cwnd的大小"><a class="header-anchor" href="#理解并记忆TCP的“慢启动、拥塞避免”拥塞控制策略，会计算拥塞窗口cwnd的大小">¶</a>理解并记忆TCP的“慢启动、拥塞避免”拥塞控制策略，会计算拥塞窗口cwnd的大小</h5>
<h6 id="拥塞控制"><a class="header-anchor" href="#拥塞控制">¶</a>拥塞控制</h6>
<ol>
<li class="lvl-3">
<p><strong>拥塞避免</strong>：拥塞发生前发送放采取的预防措施，即发送方在发送速度增加到一定数值时主动减缓发送速度的<strong>增速</strong>的一种预防措施</p>
</li>
<li class="lvl-3">
<p><strong>拥塞控制</strong>：拥塞发生后发送方采取的措施，即发送方探测到网络拥塞状况后，降低自身的发送速率</p>
</li>
</ol>
<p><strong>如何探测网络的拥塞状况</strong>：发送方根据超时重传事件的发生，判定网络拥塞。</p>
<p><strong>发送方如何控制发送速率</strong>：利用拥塞窗口变量（cwnd）控制发送速度<br>
$$<br>
\underset{\text{（未获确认可连发多少数据）}}{\text发送窗口大小} = Min(cwnd,rwnd)\<br>
cwnd: 拥塞窗口变量\<br>
rwnd: 接收方反馈的窗口大小<br>
$$<br>
<strong>TCP拥塞控制算法</strong>：慢开始、拥塞避免、快速重传、快速回复</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>TCP为每条连接维持的两个变量</strong>：<br>
$$<br>
\text{拥塞窗口变量} cwnd\<br>
\text{慢开始门限} ssthresh<br>
$$</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p><strong>慢启动</strong>：TCP刚建立连接时将拥塞窗口变量cwnd设置为2至4个报文段大小,然后以指数方式放大cwnd,直到大于等于ssthresh,进入拥塞避免阶段</p>
</li>
<li class="lvl-3">
<p><strong>拥塞避免</strong>：TCP采用线性增加方式放大cwnd</p>
</li>
<li class="lvl-3">
<p>无论是慢启动阶段还是拥塞避免阶段</p>
<p>如果<strong>发生重传定时器超时</strong>的现象,</p>
<p><strong>ssthresh设置为</strong>出现拥塞时拥塞窗口值<strong>cwnd的一半</strong></p>
<p>c<strong>wnd设置为1</strong>个报文段大小,重新进入慢启动阶段。</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h6>实现举例</h6>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281128393.png" alt="image-20241228112841280"></p>
<p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。</p>
<p>慢开始门限的初始值设置为 16 个报文段，即<br>
ssthresh = 16。</p>
<p>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281129265.png" alt="image-20241228112957151"></p>
<p>在执行<strong>慢开始</strong>算法时，拥塞窗口 cwnd=1，发送第一个报文段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281130713.png" alt="image-20241228113040589"></p>
<p>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1</p>
<p><small>因为ACK即发送数据的确认报文，每一轮发送的每一个数据均会有一个确认报文；</small></p>
<p>这样，<strong>所有分组的确认报文返回后，就相当于拥塞窗口翻倍了</strong></p>
<p>然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281134718.png" alt="image-20241228113457608"></p>
<p>当拥塞窗口 cwnd 增长到慢开始门限值ssthresh 时（图中的点，此时拥塞窗口cwnd = 16），就改为执行<strong>拥塞避免算法</strong>，拥塞窗口<strong>按线性规律增长</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281135143.png" alt="image-20241228113545024"></p>
<p>当拥塞窗口 cwnd = 24 时，网络出现了<strong>超时</strong>（图中的点2），发送方判断为网络拥塞。于是<strong>调整门限值</strong> ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入<strong>慢开始</strong>阶段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281136371.png" alt="image-20241228113657249"></p>
<p>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。当拥塞窗口cwnd = ssthresh = 12时（图中的点3，这是新的ssthresh值），改为执行<strong>拥塞避免</strong>算法，拥塞窗口<strong>按线性规律增大</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281137580.png" alt="image-20241228113755466"></p>
<p>当拥塞窗口cwnd = 16时（图中的点），出现了一个新的情况，就是发送方一连收到 <strong>3 个对同一个报文段的重复确认</strong>（图中记为3-ACK）。发送方改为执行<strong>快重传和快恢复算法</strong>。</p>
</p>
    </div>
</div><h5 id="理解下列协议或服务的作用："><a class="header-anchor" href="#理解下列协议或服务的作用：">¶</a>理解下列协议或服务的作用：</h5>
<p>ARP、DHCP、STP、DNS、NAT、HTTP、SMTP、OSTF、RIP</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ARP：地址解析协议</p>
<p><small>根据IP地址解析目的MAC</small></p>
</li>
<li class="lvl-2">
<p>DHCP：动态主机配置协议</p>
<p><small>为上网的主机动态配置上网所需的IP，子网掩码，默认网关<small>默认路由器IP地址</small>，域名解析服务器IP</small></p>
</li>
<li class="lvl-2">
<p>STP：生成树协议</p>
<p><small>防止网桥网络中的<a href="https://baike.baidu.com/item/%E5%86%97%E4%BD%99%E9%93%BE%E8%B7%AF/1080266?fromModule=lemma_inlink">冗余链路</a><strong>形成环路工作</strong></small></p>
</li>
<li class="lvl-2">
<p>DNS：域名解析协议</p>
</li>
<li class="lvl-2">
<p>NAT：网络地址转换技术</p>
<p><small>将私网地址映射为公网地址</small></p>
</li>
<li class="lvl-2">
<p>HTTP：超文本传输协议</p>
</li>
<li class="lvl-2">
<p>SMTP：简单邮件传送协议</p>
</li>
<li class="lvl-2">
<p>OSTF：链路状态路由选择算法及路由选择协议</p>
</li>
<li class="lvl-2">
<p>RIP：基于距离矢量路由选择算法的路由选择协议</p>
</li>
</ul>
<h6 id="ARP"><a class="header-anchor" href="#ARP">¶</a>ARP</h6>
<p>地址解析协议</p>
<blockquote>
<h6 id="为什么需要地址解析"><a class="header-anchor" href="#为什么需要地址解析">¶</a>为什么需要地址解析</h6>
<p>集线器网络中，主机只会接收目的MAC地址与自己MAC地址相同的数据。</p>
<p>无论是主机到主机，还是主机到路由器、路由器到路由器、主机到路由器的通信，实质都是网卡之间的数据传递。</p>
<p>为了传输成功，都需要在已知对方IP地址的前提下获取对方的MAC地址</p>
</blockquote>
<p>主机或路由器每一个网络接口都有一个ARP模块，将在<strong>同一网段</strong>上的IP地址作为输入，返回其MAC地址，作为封装数据帧的目的物理地址。</p>
<p><strong>ARP表</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281159922.png" alt="image-20241228115948797"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281200983.png" alt="image-20241228120030875"></p>
<blockquote>
<h6 id="举例-2"><a class="header-anchor" href="#举例-2">¶</a>举例</h6>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281201012.png" alt="image-20241228120122897"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281204603.png" alt="image-20241228120138752"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281202454.png" alt="image-20241228120237346"></p>
</blockquote>
<h6 id="DHCP"><a class="header-anchor" href="#DHCP">¶</a>DHCP</h6>
<p>动态主机配置协议</p>
<p>为连接到互联网的主机提供：IP地址、子网掩码、默认路由器IP地址、域名服务器IP地址</p>
<blockquote>
<p>使用<strong>客户服务器</strong>方式，采用<strong>请求/应答</strong>方式工作。</p>
<p>DHCP基于UDP工作，DHCP服务器运行在67端口，DHCP客户端运行在68号端口。</p>
</blockquote>
<h6 id="STP"><a class="header-anchor" href="#STP">¶</a>STP</h6>
<p>STP（Spanning Tree Protocol）是<a href="https://baike.baidu.com/item/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE/1309781?fromModule=lemma_inlink">生成树协议</a>的英文缩写，可应用于<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18763?fromModule=lemma_inlink">计算机网络</a>中树形<a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/1488219?fromModule=lemma_inlink">拓扑结构</a>建立，主要作用是防止网桥网络中的<a href="https://baike.baidu.com/item/%E5%86%97%E4%BD%99%E9%93%BE%E8%B7%AF/1080266?fromModule=lemma_inlink">冗余链路</a>形成环路工作。但某些特定因素会导致STP失败，要排除故障可能非常困难，这取决于网络设计 [1]。生成树协议适合所有厂商的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/7667828?fromModule=lemma_inlink">网络设备</a>，在配置上和体现功能强度上有所差别，但是在原理和应用效果是一致的。</p>
<h6 id="DNS"><a class="header-anchor" href="#DNS">¶</a>DNS</h6>
<p>域名解析服务</p>
<p>将域名解析为目的IP地址</p>
<h6 id="NAT"><a class="header-anchor" href="#NAT">¶</a>NAT</h6>
<p>网络地址转换技术</p>
<blockquote>
<p>由于公用IP地址资源匮乏, 因特网管理机构定义了专用内部网络地址（即私有地址）来满足内部网络通信需求.这些网络地址在单位或组织内部使用，局部唯一即可，且无需申请</p>
</blockquote>
<p><strong>当内部网络需要与外部公网通信时</strong></p>
<p><strong>由于因特网上的路由器都不转发目的地址是私网地址的IP数据报</strong></p>
<p><strong>所以需要利用NAT技术</strong></p>
<p>**将内部网络地址转换为全球唯一的公网地址.  **</p>
<blockquote>
<h6 id="NAT私网地址块"><a class="header-anchor" href="#NAT私网地址块">¶</a>NAT私网地址块</h6>
<p>10.0.0.0-10.255.255.255;</p>
<p>172.16.0.0-172.31.255.255</p>
<p>192.168.0.0-192.168.255.255</p>
</blockquote>
<h6 id="HTTP"><a class="header-anchor" href="#HTTP">¶</a>HTTP</h6>
<p>超文本传输协议</p>
<p>定义了浏览器与万维网服务器之间通信的格式和规则。</p>
<p>是万维网上能够<strong>可靠地交换文件</strong>（包括文本、声音、图像等各种多媒体文件）的重要基础</p>
<h6 id="SMTP"><a class="header-anchor" href="#SMTP">¶</a>SMTP</h6>
<h6 id="RIP"><a class="header-anchor" href="#RIP">¶</a>RIP</h6>
<p>分布式的基于<strong>距离矢量路由选择算法</strong>的路由选择协议，用来解决路由器的路由表生成问题</p>
<h6 id="OSPF"><a class="header-anchor" href="#OSPF">¶</a>OSPF</h6>
<p>链路状态路由选择算法及路由选择选择协议</p>
<ol>
<li class="lvl-3">
<p>发现邻居</p>
</li>
<li class="lvl-3">
<p>测试到邻居的距离</p>
</li>
<li class="lvl-3">
<p>组装链路状态分组</p>
</li>
<li class="lvl-3">
<p>发布链路状态分组</p>
</li>
<li class="lvl-3">
<p>计算新路由</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281149283.png" alt="image-20241228114912157"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412281151433.png" alt="image-20241228115141334"></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>CISC架构</title>
    <url>/posts/7436c65f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>CISC（Complex Instruction Set Computer）<strong>架构是一种处理器设计理念，其特点是提供</strong>复杂且多样化的指令集</strong></p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CISC架构的定义"><a class="header-anchor" href="#CISC架构的定义">¶</a><strong>CISC架构的定义</strong></h3>
<p>**CISC（Complex Instruction Set Computer）*<em>架构是一种处理器设计理念，其特点是提供*<em>复杂且多样化的指令集</em></em>，每条指令可以完成多种复杂操作。这种设计理念的目标是通过简化程序的指令数目，减少程序代码量，提高开发效率。</p>
<p>CISC是传统计算机架构的典型代表，如<strong>x86架构</strong>和早期的<strong>VAX</strong>、<strong>IBM System/360</strong>等处理器。</p>
<hr>
<h3 id="CISC架构的特点"><a class="header-anchor" href="#CISC架构的特点">¶</a><strong>CISC架构的特点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>复杂指令集</strong></p>
<ul class="lvl-2">
<li class="lvl-5">每条指令的功能非常强大，可能同时执行多个步骤（如取数、运算、存储）。</li>
<li class="lvl-5">如<code>MOV</code>, <code>ADD</code>, <code>MULT</code>等指令，不仅支持寄存器操作，还支持直接对内存操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令长度不固定</strong></p>
<ul class="lvl-2">
<li class="lvl-5">指令可以是不同长度的字节组合，使得编码更加灵活，但解码复杂。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>丰富的寻址模式</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提供多种内存寻址模式，如立即寻址、直接寻址、间接寻址、基址寻址等，支持对复杂数据结构的直接操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>微码实现</strong></p>
<ul class="lvl-2">
<li class="lvl-5">通常使用**微程序控制器（Microcode Control Unit）**来解码复杂指令，这种方式简化了硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令执行时间较长</strong></p>
<ul class="lvl-2">
<li class="lvl-5">单条指令可能需要多个时钟周期完成，因为其内部可能包含多个微操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>高度依赖内存</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构允许指令直接操作内存，而不是先将数据加载到寄存器，这增加了对内存访问的频率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的优点"><a class="header-anchor" href="#CISC架构的优点">¶</a><strong>CISC架构的优点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>程序代码紧凑</strong></p>
<ul class="lvl-2">
<li class="lvl-5">强大的指令集可以用更少的指令实现复杂功能，减少程序代码量。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>易于编写高层语言编译器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">高级语言中复杂的语句可以直接映射为CISC指令，简化了编译器的设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>向后兼容性强</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构通过扩展指令集可以保持对旧程序的兼容性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适合复杂的计算任务</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令和多样化的寻址模式使其适合复杂的数据处理任务。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的缺点"><a class="header-anchor" href="#CISC架构的缺点">¶</a><strong>CISC架构的缺点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>指令解码复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">不固定的指令长度和复杂的指令集增加了CPU解码指令的难度，降低了效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>执行速度较慢</strong></p>
<ul class="lvl-2">
<li class="lvl-5">一条CISC指令可能需要多个时钟周期完成，无法充分发挥现代高速硬件的性能。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>硬件设计复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">支持多样化指令和寻址模式需要更复杂的硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>能耗较高</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令的实现通常需要更多的电力支持。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC与RISC的对比"><a class="header-anchor" href="#CISC与RISC的对比">¶</a><strong>CISC与RISC的对比</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CISC</strong></th>
<th><strong>RISC（Reduced Instruction Set Computer）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令集</strong></td>
<td>复杂、多样化</td>
<td>简单、固定长度</td>
</tr>
<tr>
<td><strong>指令执行时间</strong></td>
<td>单条指令执行时间长，可能需要多个时钟周期</td>
<td>单条指令执行时间短，通常一个时钟周期完成</td>
</tr>
<tr>
<td><strong>硬件设计</strong></td>
<td>复杂的硬件支持复杂指令集</td>
<td>简化的硬件设计，执行更高效</td>
</tr>
<tr>
<td><strong>代码密度</strong></td>
<td>高，程序代码量少</td>
<td>低，通常需要更多指令完成相同的功能</td>
</tr>
<tr>
<td><strong>能耗</strong></td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td><strong>典型代表</strong></td>
<td>x86, VAX</td>
<td>ARM, MIPS, RISC-V</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="CISC架构的实际应用"><a class="header-anchor" href="#CISC架构的实际应用">¶</a><strong>CISC架构的实际应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>x86处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">现代的PC和服务器大多基于x86架构，该架构是CISC的典型代表。</li>
<li class="lvl-5">如Intel和AMD的处理器均采用该架构。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>嵌入式系统中的老一代处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">如8086、80286处理器，广泛应用于工业控制和嵌入式系统中。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>专用硬件系统</strong></p>
<ul class="lvl-2">
<li class="lvl-5">需要复杂数据处理的场景，如传统银行机房的大型机。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="现代CISC的改进"><a class="header-anchor" href="#现代CISC的改进">¶</a><strong>现代CISC的改进</strong></h3>
<p>尽管CISC架构在指令执行效率上不如RISC，但现代CISC处理器通过以下方式提升性能：</p>
<ol>
<li class="lvl-3">
<p><strong>指令解码优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">使用硬件将CISC复杂指令拆解为更简单的微操作（micro-operations）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>流水线设计</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构中引入RISC的流水线思想，提高指令执行效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多核技术</strong></p>
<ul class="lvl-2">
<li class="lvl-5">增加多核处理能力，弥补单核执行速度的不足。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>缓存优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提高指令和数据缓存的命中率，减少内存访问延迟。</li>
</ul>
</li>
</ol>
<hr>
<p>总结来说，CISC架构通过强大的指令集提供了高度灵活性，特别适合某些需要复杂指令处理的应用场景。尽管其在效率和硬件设计方面有一定劣势，但通过现代优化技术，CISC架构依然在许多领域保持了强大的竞争力。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理中固定分区的地址重定位与存储保护</title>
    <url>/posts/1c6fec2c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在内存管理的固定分区方法中，地址重定位和存储保护是两个关键概念，它们确保程序正确执行并保护内存数据的完整性。以下是对这两个方面的详细解释：</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="1-地址重定位（Address-Relocation）"><a class="header-anchor" href="#1-地址重定位（Address-Relocation）">¶</a>1. 地址重定位（Address Relocation）</h3>
<p><strong>地址重定位</strong>是指将程序的逻辑地址转换为物理地址的过程。在固定分区内存管理中，内存被划分为若干固定大小的分区，每个分区都可能被一个进程占用。当程序装载到某个分区时，逻辑地址需要被调整为物理地址，以正确访问内存中的数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>逻辑地址与物理地址</strong></p>
<ul class="lvl-2">
<li class="lvl-4"><strong>逻辑地址</strong>：由程序生成，通常从 0 开始，描述程序内部的内存访问。</li>
<li class="lvl-4"><strong>物理地址</strong>：程序实际运行时的内存地址，由操作系统或硬件计算得出。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>重定位的方式</strong></p>
<ol>
<li class="lvl-5">静态重定位：
<ul class="lvl-4">
<li class="lvl-7">程序在装载时由操作系统将逻辑地址加上分区的起始地址，转换为物理地址。</li>
<li class="lvl-7">该方法简单，但程序装载后地址固定，无法移动。</li>
</ul>
</li>
<li class="lvl-5">动态重定位：
<ul class="lvl-4">
<li class="lvl-7">程序运行时，通过硬件中的**重定位寄存器（Base Register）**实时完成地址转换。</li>
<li class="lvl-7">在访问内存时，硬件会将逻辑地址加上分区的起始地址来计算物理地址。</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>示例</strong>： 如果一个程序需要访问逻辑地址 100，而该程序被加载到起始地址为 1000 的分区中，则：</p>
<ul class="lvl-2">
<li class="lvl-4">物理地址 = 分区起始地址 + 逻辑地址 = 1000 + 100 = 1100</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-存储保护（Memory-Protection）"><a class="header-anchor" href="#2-存储保护（Memory-Protection）">¶</a>2. 存储保护（Memory Protection）</h3>
<p><strong>存储保护</strong>的目的是防止一个程序访问到其他程序或操作系统的内存，确保内存安全性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>实现方法</strong>：</p>
<ol>
<li class="lvl-5">界限寄存器（Limit Register）：
<ul class="lvl-4">
<li class="lvl-7">每个分区设置一个界限寄存器，记录该分区的最大地址范围。</li>
<li class="lvl-7">在访问内存时，硬件检查物理地址是否在分区范围内，超出范围则触发保护异常（Protection Fault）。</li>
</ul>
</li>
<li class="lvl-5">重定位寄存器和界限寄存器联合使用：
<ul class="lvl-4">
<li class="lvl-7"><strong>重定位寄存器</strong>保存分区的起始地址，用于地址转换。</li>
<li class="lvl-7"><strong>界限寄存器</strong>保存分区大小，用于检查是否越界。</li>
<li class="lvl-7">访问内存时，实际地址需满足：<br>
<code>实际地址 &gt;= 起始地址</code> 且 <code>实际地址 &lt; 起始地址 + 分区大小</code></li>
</ul>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>保护机制的作用</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">防止一个程序越界访问其他分区的内存。</li>
<li class="lvl-4">避免意外覆盖操作系统或其他程序的关键数据。</li>
<li class="lvl-4">在多道程序系统中，保障各进程互不干扰。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>示例</strong>： 假设分区起始地址为 1000，分区大小为 500：</p>
<ul class="lvl-2">
<li class="lvl-4">合法范围：1000 ≤ 地址 &lt; 1500</li>
<li class="lvl-4">如果程序试图访问地址 1600，硬件会检测到越界并触发保护异常。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-地址重定位与存储保护的结合"><a class="header-anchor" href="#3-地址重定位与存储保护的结合">¶</a>3. 地址重定位与存储保护的结合</h3>
<p>在固定分区中，地址重定位和存储保护通常通过硬件协作实现：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个分区分配一个<strong>重定位寄存器</strong>和一个<strong>界限寄存器</strong>。</p>
</li>
<li class="lvl-2">
<p>在程序访问内存时：</p>
<ol>
<li class="lvl-5">重定位寄存器负责将逻辑地址转换为物理地址。</li>
<li class="lvl-5">界限寄存器确保转换后的物理地址在合法范围内。</li>
</ol>
</li>
<li class="lvl-2">
<p>若地址转换或越界检查失败，操作系统会终止相关程序，并防止内存损坏。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>地址重定位</strong>解决了程序在不同内存分区中的装载问题，使逻辑地址转换为物理地址。</p>
</li>
<li class="lvl-2">
<p><strong>存储保护</strong>通过限制内存访问范围，确保程序运行的安全性和稳定性。</p>
</li>
<li class="lvl-2">
<p>在固定分区方法中，这两者结合通过硬件（如寄存器）实现高效的内存管理和保护。</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>一条指令在执行期间，可能产生多次缺页中断</title>
    <url>/posts/52e033e8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>一条指令在执行期间，可能产生多次缺页中断 的详细解析</p>
</p>
    </div>
</div><span id="more"></span>
<p>是的，一条指令在执行期间<strong>可能产生多次缺页中断</strong>。这是因为指令的执行可能涉及到多个内存地址的访问，而每个地址的访问都有可能导致缺页中断。以下是几种可能导致这种情况的场景：</p>
<hr>
<h3 id="1-指令本身产生的缺页中断"><a class="header-anchor" href="#1-指令本身产生的缺页中断">¶</a><strong>1. 指令本身产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>指令取指</strong><br>
CPU在执行一条指令时，需要从内存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="2-操作数访问导致的缺页中断"><a class="header-anchor" href="#2-操作数访问导致的缺页中断">¶</a><strong>2. 操作数访问导致的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>直接操作数</strong><br>
如果指令使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>间接访问（如指针或数组访问）</strong><br>
指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="3-指令操作多次访问内存"><a class="header-anchor" href="#3-指令操作多次访问内存">¶</a><strong>3. 指令操作多次访问内存</strong></h3>
<p>一些复杂指令（尤其在CISC架构中）可能在执行期间涉及多个内存访问，每次访问都可能触发缺页中断。例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<hr>
<h3 id="4-页表访问产生的缺页中断"><a class="header-anchor" href="#4-页表访问产生的缺页中断">¶</a><strong>4. 页表访问产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="5-内存管理器的间接操作"><a class="header-anchor" href="#5-内存管理器的间接操作">¶</a><strong>5. 内存管理器的间接操作</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
<hr>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h3>
<p>假设有一条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i] = b[j] + c[k];</span><br></pre></td></tr></table></figure>
<p>执行这条指令可能涉及以下几个内存访问：</p>
<ol>
<li class="lvl-3">
<p>取出指令本身（指令所在页面可能触发缺页中断）。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>a</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>b</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>c</code>的地址。</p>
</li>
<li class="lvl-3">
<p>访问<code>b[j]</code>的值。</p>
</li>
<li class="lvl-3">
<p>访问<code>c[k]</code>的值。</p>
</li>
<li class="lvl-3">
<p>写入<code>a[i]</code>。</p>
</li>
</ol>
<p>如果这些访问的页面都未加载到主存，则可能触发<strong>多次缺页中断</strong>。</p>
<hr>
<h3 id="如何缓解缺页中断带来的开销"><a class="header-anchor" href="#如何缓解缺页中断带来的开销">¶</a><strong>如何缓解缺页中断带来的开销</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>预取机制</strong><br>
操作系统可预测程序的访问模式，提前将相关页面加载到主存，减少缺页中断。</p>
</li>
<li class="lvl-3">
<p><strong>使用更大的页面（大页）</strong><br>
使用大页面（如2MB或1GB）可以减少页表项数量，降低缺页中断概率。</p>
</li>
<li class="lvl-3">
<p><strong>优化程序内存访问模式</strong><br>
开发者可以优化数据结构和算法，尽量减少跨页面访问。</p>
</li>
<li class="lvl-3">
<p><strong>TLB优化</strong><br>
提高页表缓存（TLB）的命中率，加快地址转换速度。</p>
</li>
</ol>
<hr>
<p>综上，虽然一条指令可能导致多次缺页中断，但通过合理的内存管理策略和优化，可以有效降低缺页中断的频率，提高系统性能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>在地址转换过程中会访问两次页表嘛？</title>
    <url>/posts/c38ea43e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3><strong>总结</strong></h3>
<ol>
<li class="lvl-3">
<p>没有 TLB 的情况下，单级页表访问一次，多级页表可能需要访问两次甚至更多次。</p>
</li>
<li class="lvl-3">
<p>使用 TLB 后，大部分情况下只需访问一次页表（命中情况下直接完成转换），未命中的情况下才需访问页表的所有层级。</p>
</li>
</ol>
<p>通过 TLB 缓解页表访问延迟是现代虚拟存储管理的重要优化手段。</p>
</p>
    </div>
</div><span id="more"></span>
<hr>
<h3 id="1-单级页表的地址转换"><a class="header-anchor" href="#1-单级页表的地址转换">¶</a><strong>1. 单级页表的地址转换</strong></h3>
<p>在单级页表中，虚拟地址通过以下步骤转换为物理地址：</p>
<ol>
<li class="lvl-3">
<p><strong>页号查找</strong>：通过虚拟地址中的页号部分访问页表，找到对应的页表项，获取物理页号。</p>
</li>
<li class="lvl-3">
<p><strong>偏移量加法</strong>：将物理页号与虚拟地址中的页内偏移量结合，得到物理地址。</p>
</li>
</ol>
<p>此时，页表只需访问一次。但由于页表存储在主存中，这次访问本身也需要访问主存一次，增加了访问延迟。</p>
<hr>
<h3 id="2-多级页表的地址转换"><a class="header-anchor" href="#2-多级页表的地址转换">¶</a><strong>2. 多级页表的地址转换</strong></h3>
<p>在多级页表中（例如二级页表），为了减小页表占用的内存，页表被分解为多个层级。虚拟地址的转换过程如下：</p>
<ol>
<li class="lvl-3">
<p>从虚拟地址中提取多级页号（如一级页号和二级页号）。</p>
</li>
<li class="lvl-3">
<p><strong>第一级页表访问</strong>：使用一级页号查找一级页表，找到指向二级页表的地址。</p>
</li>
<li class="lvl-3">
<p><strong>第二级页表访问</strong>：使用二级页号查找二级页表，找到对应的物理页号。</p>
</li>
<li class="lvl-3">
<p><strong>偏移量加法</strong>：将物理页号与页内偏移量结合，生成最终物理地址。</p>
</li>
</ol>
<p>此时，由于需要分别访问一级页表和二级页表，因此需要两次内存访问。</p>
<hr>
<h3 id="3-TLB-的作用"><a class="header-anchor" href="#3-TLB-的作用">¶</a><strong>3. TLB 的作用</strong></h3>
<p>为了避免多次访问页表带来的性能开销，现代系统中通常会使用 <strong>TLB</strong> 来缓存常用的页表项。如果虚拟地址对应的页表项已经在 TLB 中：</p>
<ol>
<li class="lvl-3">
<p>地址转换直接通过 TLB 完成，只需访问一次主存。</p>
</li>
<li class="lvl-3">
<p>如果 TLB 未命中，则需要按上述流程访问多级页表，并更新 TLB。</p>
</li>
</ol>
<hr>
<h3 id="4-具体分析"><a class="header-anchor" href="#4-具体分析">¶</a><strong>4. 具体分析</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>单级页表</strong>：理论上只需访问一次页表（加上实际的数据访问总共两次主存访问）。</p>
</li>
<li class="lvl-2">
<p><strong>多级页表</strong>：可能需要访问页表两次（或更多次），再加上最终的数据访问，总计三次或更多主存访问。</p>
</li>
<li class="lvl-2">
<p><strong>带 TLB 的多级页表</strong>：在 TLB 命中的情况下，地址转换和数据访问总共只需两次主存访问。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<ol>
<li class="lvl-3">
<p>没有 TLB 的情况下，单级页表访问一次，多级页表可能需要访问两次甚至更多次。</p>
</li>
<li class="lvl-3">
<p>使用 TLB 后，大部分情况下只需访问一次页表（命中情况下直接完成转换），未命中的情况下才需访问页表的所有层级。</p>
</li>
</ol>
<p>通过 TLB 缓解页表访问延迟是现代虚拟存储管理的重要优化手段。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-LFU</title>
    <url>/posts/78bb016d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>最少使用置换算法 (LFU, Least Frequently Used)</strong> 是一种基于页面访问频率的页面置换算法，其核心思想是将内存中使用频率最少的页面作为置换候选，确保较少被访问的页面优先被淘汰。LFU 算法适用于需要精确控制页面访问频率的场景，但在实际应用中常常因为实现复杂性和性能瓶颈而需要进行优化。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="LFU-算法原理"><a class="header-anchor" href="#LFU-算法原理">¶</a><strong>LFU 算法原理</strong></h3>
<p>LFU 算法通过记录每个页面的访问频率（即页面被访问的次数）来决定哪些页面应该被淘汰。当需要替换页面时，选择访问频率最少的页面进行替换。如果有多个页面的访问频率相同，则通常按照其他规则（如 FIFO）进一步选择页面。</p>
<h3 id="LFU-的实现步骤"><a class="header-anchor" href="#LFU-的实现步骤">¶</a><strong>LFU 的实现步骤</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>初始化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">为每个页面分配一个计数器，用于记录该页面的访问次数。</li>
<li class="lvl-5">页面访问时，计数器加一。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>页面访问</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">如果页面在内存中，增加页面的访问频率（计数器加一）。</li>
<li class="lvl-5">如果页面不在内存中：
<ul class="lvl-4">
<li class="lvl-7">若内存已满，则选择访问频率最少的页面进行置换。</li>
<li class="lvl-7">将新页面加载到内存，并设置访问频率为 1。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>页面置换</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在内存已满时，选择访问频率最小的页面进行淘汰。</li>
<li class="lvl-5">如果有多个页面的访问频率相同，则使用其他策略（如 FIFO）进一步确定淘汰页面。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>优化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在实际应用中，为了避免频繁淘汰的情况，可以引入衰减机制，即定期减少页面的访问频率，使得较久未访问的页面可以逐渐“过期”。</li>
<li class="lvl-5">结合其他策略（如时间局部性）可以进一步优化 LFU 的效果。</li>
</ul>
</li>
</ol>
<h3 id="LFU-的优缺点"><a class="header-anchor" href="#LFU-的优缺点">¶</a><strong>LFU 的优缺点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：</p>
<ul class="lvl-2">
<li class="lvl-4">LFU 更能反映页面的实际使用情况，尤其适合处理那些经常使用的页面和较少访问的页面之间的差异。</li>
<li class="lvl-4">与 FIFO 不同，LFU 会根据页面的访问历史来判断哪些页面应该继续留在内存中，从而避免了 FIFO 在某些场景下的缺陷（如热点页面被淘汰的情况）。</li>
</ul>
</li>
<li class="lvl-2">
<p>缺点：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>实现复杂性</strong>：LFU 算法需要为每个页面维护一个访问计数器，这增加了系统的开销。</li>
<li class="lvl-4"><strong>性能瓶颈</strong>：每次访问页面时，都需要更新访问计数器，并且置换时需要遍历所有页面，找到访问频率最小的页面，这在大规模系统中可能会导致性能问题。</li>
<li class="lvl-4"><strong>长时间未使用页面</strong>：LFU 在某些情况下可能会保留一些长期未访问但仍然有高访问频率的页面，这在时间局部性较强的场景中可能不适用。</li>
</ul>
</li>
</ul>
<h3 id="优化方法"><a class="header-anchor" href="#优化方法">¶</a><strong>优化方法</strong></h3>
<p>由于 LFU 算法容易受到高频页面占用内存的影响，现代系统中往往采用以下优化方法：</p>
<ol>
<li class="lvl-3">
<p><strong>衰减机制</strong>：定期减小页面的访问计数，使得长期未访问的页面计数器值会逐渐降低，避免低频页面被长期保留。</p>
</li>
<li class="lvl-3">
<p><strong>结合其他算法</strong>：例如，结合 LRU（最近最久未使用）策略，使用 LFU+LRU（如 LFU 结合链表）来同时考虑页面的访问频率和最近的访问时间，提升整体性能。</p>
</li>
</ol>
<h3 id="LFU-与-FIFO-比较"><a class="header-anchor" href="#LFU-与-FIFO-比较">¶</a><strong>LFU 与 FIFO 比较</strong></h3>
<p>LFU 算法是 FIFO 算法的一种改进。FIFO 仅根据页面进入内存的顺序来决定置换，而 LFU 则考虑了页面的使用频率，从而能更精确地反映页面的实际需求。相比 FIFO，LFU 更能避免热点页面被淘汰的情况，但其实现和维护的复杂性较高。</p>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h3>
<p>假设我们有一个大小为 3 的页面框，页面访问序列如下：<code>1, 2, 3, 1, 2, 4, 5</code>。初始时，所有页面的访问频率为 0。每次访问时，页面的频率会增加，最终进行置换时会选择频率最小的页面。</p>
<ol>
<li class="lvl-3">
<p>访问页面 <code>1</code>：内存中插入页面 <code>1</code>，频率为 <code>[1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>2</code>：内存中插入页面 <code>2</code>，频率为 <code>[1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>3</code>：内存中插入页面 <code>3</code>，频率为 <code>[1, 1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>再次访问页面 <code>1</code>：频率更新为 <code>[2, 1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>再次访问页面 <code>2</code>：频率更新为 <code>[2, 2, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>4</code>：页面 <code>3</code> 被淘汰（频率最小），插入页面 <code>4</code>，频率为 <code>[2, 2, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>5</code>：页面 <code>1</code> 被淘汰（频率最小），插入页面 <code>5</code>，频率为 <code>[2, 2, 1]</code>。</p>
</li>
</ol>
<p>在这个过程中，LFU 根据访问频率选择淘汰页面，相比 FIFO 更能有效管理频繁访问的页面。</p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<p>LFU 算法是一种有效的页面置换策略，适用于处理那些访问频率差异较大的场景。它相比 FIFO 更能反映页面的实际使用情况，但其实现复杂度和性能问题可能需要结合其他策略进行优化。在现代操作系统中，LFU 和其改进版本（如 LFU+LRU）通常会与其他页面管理策略一起使用，以达到更好的性能效果。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-LRU的实际实现过程</title>
    <url>/posts/f041ded5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现</h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><span id="more"></span>
<p>以下是使用<strong>移位寄存器</strong>和<strong>栈</strong>实现最近最久未使用（LRU）算法的详细过程：</p>
<hr>
<h3 id="1-用移位寄存器实现-LRU"><a class="header-anchor" href="#1-用移位寄存器实现-LRU">¶</a><strong>1. 用移位寄存器实现 LRU</strong></h3>
<p>移位寄存器通过记录页面的访问历史，来跟踪最近最久未使用的页面。</p>
<h4 id="基本原理"><a class="header-anchor" href="#基本原理">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页面框对应一个寄存器（n 位宽）。</p>
</li>
<li class="lvl-2">
<p>每次访问页面时：</p>
<ol>
<li class="lvl-5">将对应寄存器的最高位设置为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ol>
</li>
<li class="lvl-2">
<p>随着时间推移，未被访问的页面寄存器的值会逐渐变小。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面（即最久未使用的页面）。</p>
</li>
</ul>
<h4 id="实现步骤"><a class="header-anchor" href="#实现步骤">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化寄存器</strong>：为每个页面框分配一个寄存器，初始值为全 0。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">找到访问的页面对应的寄存器。</li>
<li class="lvl-5">设置寄存器的最高位为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">在页面不在内存中且内存已满时，找到寄存器值最小的页面并将其替换。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>更新寄存器</strong>：置换完成后，初始化新页面的寄存器值为最高位为 1，其他位为 0。</p>
</li>
</ol>
<h4 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h4>
<p>假设有 4 个页面框，对应 4 个 4 位寄存器，初始值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并对所有寄存器右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>再次访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1100  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R2 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0110  R2: 1000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-用栈实现-LRU"><a class="header-anchor" href="#2-用栈实现-LRU">¶</a><strong>2. 用栈实现 LRU</strong></h3>
<p>栈结构利用最近使用的页面总是在栈顶，而最久未使用的页面总是在栈底的特点，实现页面置换。</p>
<h4 id="基本原理-2"><a class="header-anchor" href="#基本原理-2">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用一个栈存储页面框号，栈顶是最近访问的页面。</p>
</li>
<li class="lvl-2">
<p>页面访问时：</p>
<ol>
<li class="lvl-5">如果页面已在栈中，将其移到栈顶。</li>
<li class="lvl-5">如果页面不在栈中：
<ul class="lvl-4">
<li class="lvl-7">栈未满时，将页面直接插入栈顶。</li>
<li class="lvl-7">栈已满时，移除栈底页面（最久未使用），然后插入新页面到栈顶。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="实现步骤-2"><a class="header-anchor" href="#实现步骤-2">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化栈</strong>：创建一个空栈，大小等于内存页面框数。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">检查页面是否在栈中：
<ul class="lvl-4">
<li class="lvl-7">如果在，将该页面从原位置移到栈顶。</li>
<li class="lvl-7">如果不在：
<ul class="lvl-6">
<li class="lvl-9">栈未满时，直接将页面插入栈顶。</li>
<li class="lvl-9">栈已满时，移除栈底页面，插入新页面到栈顶。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">置换操作在栈已满时，删除<strong>栈底</strong>页面，插入新页面到栈顶。</li>
</ul>
</li>
</ol>
<h4 id="示例-2"><a class="header-anchor" href="#示例-2">¶</a><strong>示例</strong></h4>
<p>假设有 3 个页面框，初始栈为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[]</span><br></pre></td></tr></table></figure>
<p>访问页面 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[1]</span><br></pre></td></tr></table></figure>
<p>访问页面 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p>再次访问页面 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将页面 2 移到栈顶：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 3, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 4（超出容量，需要置换）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>移除栈底页面（1），插入 4：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[4, 2, 3]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="比较与选择"><a class="header-anchor" href="#比较与选择">¶</a><strong>比较与选择</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>移位寄存器</strong>实现简单，占用较少存储资源，但适合小型固定容量系统。</p>
</li>
<li class="lvl-2">
<p><strong>栈</strong>灵活性更高，适合动态管理和较大规模的页面置换问题。</p>
</li>
</ul>
<p>以上两种实现可以结合实际需求与硬件条件选择【18】【19】。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配算法</title>
    <url>/posts/8ba68849.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配算法<strong>对比总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在物理块分配中，操作系统通过不同的分配算法将内存中的页面框分配给各个进程，以提高内存利用率和系统性能。以下是这些算法的详细解释：</p>
<hr>
<h3 id="1-平均分配算法"><a class="header-anchor" href="#1-平均分配算法">¶</a><strong>1. 平均分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">系统将所有的物理块平均分配给当前运行的进程。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个页面框和 <code>M</code> 个进程，则每个进程分配到的页面框数量为 <code>N / M</code>，如果有余数，可以通过某种方式分配剩余的页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">简单易实现，适用于所有进程的内存需求大致相同的场景。</li>
<li class="lvl-4">对于需求量大的进程可能导致页面置换频繁（抖动问题），而需求量小的进程可能浪费内存。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：公平、实现简单。</p>
<p><strong>缺点</strong>：无法动态适应进程的实际需求，可能导致资源分配不合理。</p>
<hr>
<h3 id="2-按比例分配算法"><a class="header-anchor" href="#2-按比例分配算法">¶</a><strong>2. 按比例分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">根据每个进程所需的页面数占比，按比例分配物理块。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个物理块，<code>M</code> 个进程，进程 <code>i</code> 所需页面数为 <code>Si</code>，则分配给进程 <code>i</code> 的页面框数为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{S_i}{\sum_{j=1}^{M} S_j}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">进程内存需求较大时分配更多页面框，内存需求较小时分配更少。</li>
<li class="lvl-4">适用于进程内存需求差异较大的场景，能较好地满足高需求进程的性能。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：充分利用资源，能够根据需求动态调整分配。</p>
<p><strong>缺点</strong>：计算复杂度较高，对需求量估计不准确时可能影响性能。</p>
<hr>
<h3 id="3-考虑优先权的分配算法"><a class="header-anchor" href="#3-考虑优先权的分配算法">¶</a><strong>3. 考虑优先权的分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">在按比例分配的基础上，结合进程的优先级分配物理块。</li>
<li class="lvl-4">系统会为高优先级进程分配更多的页面框，而低优先级进程分配较少。</li>
<li class="lvl-4">假设优先级为 <code>Pi</code>，则分配公式可以扩展为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{P_i \cdot S_i}{\sum_{j=1}^{M} (P_j \cdot S_j)}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">确保高优先级进程在资源分配上得到保障。</li>
</ul>
</li>
<li class="lvl-2">
<p>适用于多任务操作系统，优先保证关键任务或重要用户的性能。</p>
</li>
</ul>
<p><strong>优点</strong>：保障高优先级任务的运行性能。</p>
<p><strong>缺点</strong>：可能导致低优先级进程长时间无法获得足够的资源，影响其运行。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配策略</title>
    <url>/posts/907f4c43.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配策略</h3>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在操作系统中，<strong>物理块分配策略</strong>主要决定了内存如何分配给进程以及页面置换的策略。以下是这些策略的详细解释：</p>
<hr>
<h3 id="1-固定分配，局部置换"><a class="header-anchor" href="#1-固定分配，局部置换">¶</a><strong>1. 固定分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配：每个进程在创建时，分配固定数量的物理块（即页面框）。这些物理块数量在整个运行过程中不再改变。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，一个进程可能被分配 5 个页面框，另一个进程被分配 10 个页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>局部置换：当一个进程需要置换页面时，只能在它自己的物理块中进行替换，而不会占用或影响其他进程的物理块。</p>
<ul class="lvl-2">
<li class="lvl-4">换句话说，每个进程有自己的物理块范围，页面置换仅限于该范围内。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：避免了进程之间的干扰，保证了各自的内存独立性。</p>
<p><strong>缺点</strong>：如果某个进程的需求量超过了固定分配的物理块数，可能会出现高频率的页面置换（抖动问题）。</p>
<hr>
<h3 id="2-可变分配，全局置换"><a class="header-anchor" href="#2-可变分配，全局置换">¶</a><strong>2. 可变分配，全局置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以根据进程的运行情况动态调整分配给每个进程的物理块数量。例如，一个进程内存需求增加时，可以从其他进程的分配中借用页面框。</p>
</li>
<li class="lvl-2">
<p>全局置换：当某个进程需要置换页面时，可以在整个系统的所有物理块中选择受影响的页面，不局限于自身的物理块范围。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，某个进程的页面置换可能会影响到其他进程正在使用的页面。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：提高了系统内存的利用率，允许内存资源在进程之间灵活分配。</p>
<p><strong>缺点</strong>：进程之间可能会互相干扰，导致某些进程因内存不足而性能下降。</p>
<hr>
<h3 id="3-可变分配，局部置换"><a class="header-anchor" href="#3-可变分配，局部置换">¶</a><strong>3. 可变分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以动态调整每个进程的物理块数量，具体分配数量由操作系统根据进程的需求决定。</p>
</li>
<li class="lvl-2">
<p><strong>局部置换</strong>：尽管分配数量可变，但每个进程仍只能在自己当前拥有的物理块中进行页面置换，而不能影响其他进程的页面。</p>
</li>
</ul>
<p><strong>优点</strong>：结合了固定分配和可变分配的优点，既能根据需求调整资源，又避免了进程之间的直接干扰。</p>
<p><strong>缺点</strong>：动态分配增加了操作系统的复杂性。</p>
<hr>
<h3 id="总结对比"><a class="header-anchor" href="#总结对比">¶</a><strong>总结对比</strong></h3>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>物理块分配</th>
<th>页面置换范围</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定分配，局部置换</td>
<td>固定数量</td>
<td>自己的物理块</td>
<td>简单、稳定，避免进程干扰</td>
<td>缺乏灵活性，可能导致个别进程性能下降</td>
</tr>
<tr>
<td>可变分配，全局置换</td>
<td>动态调整</td>
<td>全局</td>
<td>高效利用内存资源，支持动态调整</td>
<td>进程间干扰可能导致系统不稳定</td>
</tr>
<tr>
<td>可变分配，局部置换</td>
<td>动态调整</td>
<td>自己的物理块</td>
<td>兼顾灵活性和稳定性</td>
<td>系统复杂度较高</td>
</tr>
</tbody>
</table>
<p>这三种策略在实际中会根据操作系统的设计目标与应用场景选择适用的方案。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-页面框</title>
    <url>/posts/6dc856e2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3><strong>总结</strong></h3>
<ul class="lvl-1">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
</p>
    </div>
</div><span id="more"></span>
<p><strong>页面框</strong>（Page Frame）是操作系统中物理内存管理的一个重要概念。</p>
<hr>
<h3 id="页面框的定义"><a class="header-anchor" href="#页面框的定义">¶</a><strong>页面框的定义</strong></h3>
<p>页面框是指<strong>物理内存中的固定大小的块</strong>，它是虚拟内存管理中用于存放<strong>页</strong>（Page）的单位。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页</strong>：虚拟内存被划分为大小固定的块，每块称为一个页（Page）。</p>
</li>
<li class="lvl-2">
<p><strong>页面框</strong>：物理内存也被划分为同样大小的固定块，这些块称为页面框（Page Frame）。</p>
</li>
</ul>
<p>页面框和页的大小相同（通常为 4KB 或 8KB，具体取决于操作系统和硬件架构），这样可以方便地实现虚拟内存和物理内存之间的映射。</p>
<hr>
<h3 id="页面框的作用"><a class="header-anchor" href="#页面框的作用">¶</a><strong>页面框的作用</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>存储页</strong>：页面框用于存储从虚拟内存中调入的页。</p>
</li>
<li class="lvl-2">
<p><strong>虚拟内存与物理内存的映射</strong>：操作系统通过页表（Page Table）将虚拟内存的页与物理内存的页面框一一对应，从而实现虚拟内存管理。</p>
</li>
<li class="lvl-2">
<p><strong>提升内存利用率</strong>：通过分页机制，进程无需全部加载到内存中，只需将常用的页装入页面框即可，减少内存的浪费。</p>
</li>
</ul>
<hr>
<h3 id="页面框的分配过程"><a class="header-anchor" href="#页面框的分配过程">¶</a><strong>页面框的分配过程</strong></h3>
<ol>
<li class="lvl-3">
<p>虚拟地址空间划分：进程的虚拟地址被划分为多个页。</p>
<ul class="lvl-2">
<li class="lvl-5">假设某进程需要 16KB 的虚拟内存，且每页大小为 4KB，则虚拟内存被划分为 4 个页。</li>
</ul>
</li>
<li class="lvl-3">
<p>物理内存划分：操作系统将物理内存划分为等大小的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">假设有 1GB 的物理内存，页面框大小为 4KB，则物理内存被划分为 262,144 个页面框。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面调度：当进程运行时，操作系统将虚拟内存中的页映射到物理内存中的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">若某页需要访问但不在内存（缺页中断），操作系统从磁盘将该页加载到某个空闲页面框中，或通过页面置换算法腾出一个页面框。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="页面框相关机制"><a class="header-anchor" href="#页面框相关机制">¶</a><strong>页面框相关机制</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页表（Page Table）</strong>：存储每个页与页面框的映射关系。</p>
</li>
<li class="lvl-2">
<p><strong>页面置换</strong>：当页面框不足时，操作系统通过页面置换算法（如 LRU、FIFO）将某些不常用的页移出页面框，以腾出空间给新的页。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-移位寄存器</title>
    <url>/posts/3d2c198d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="移位寄存器的基本功能"><a class="header-anchor" href="#移位寄存器的基本功能">¶</a><strong>移位寄存器的基本功能</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据存储</strong>：可以临时存储一定数量的二进制数据。</p>
</li>
<li class="lvl-3">
<p><strong>数据移位</strong>：按照时钟信号，将数据向左或向右移位。</p>
</li>
<li class="lvl-3">
<p>数据串并转换：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>串行输入并行输出（SIPO）</strong>：将串行输入的数据逐位移入，然后一次性输出并行数据。</li>
<li class="lvl-5"><strong>并行输入串行输出（PISO）</strong>：将并行输入的数据一次性装载，然后逐位移出。</li>
<li class="lvl-5"><strong>串行输入串行输出（SISO）</strong>：数据逐位输入后，逐位移出。</li>
<li class="lvl-5"><strong>并行输入并行输出（PIPO）</strong>：并行方式输入和输出数据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的分类"><a class="header-anchor" href="#移位寄存器的分类">¶</a><strong>移位寄存器的分类</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>按移位方向分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>左移寄存器</strong>：数据向左移位，低位补零或引入外部输入。</li>
<li class="lvl-5"><strong>右移寄存器</strong>：数据向右移位，高位补零或引入外部输入。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>按输入输出方式分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>SISO（串行输入串行输出）</strong>：数据逐位输入并逐位输出，适合数据流传输。</li>
<li class="lvl-5"><strong>SIPO（串行输入并行输出）</strong>：串行输入，移位完成后并行读取，常用于串行转并行。</li>
<li class="lvl-5"><strong>PISO（并行输入串行输出）</strong>：并行数据装载后逐位输出，常用于并行转串行。</li>
<li class="lvl-5"><strong>PIPO（并行输入并行输出）</strong>：同时装载和输出并行数据，用于数据缓存。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的组成与工作原理"><a class="header-anchor" href="#移位寄存器的组成与工作原理">¶</a><strong>移位寄存器的组成与工作原理</strong></h3>
<p>移位寄存器通常由以下部分组成：</p>
<ol>
<li class="lvl-3">
<p><strong>触发器</strong>：每个触发器存储一个位的数据。</p>
</li>
<li class="lvl-3">
<p><strong>时钟信号</strong>：控制数据移位的节奏。</p>
</li>
<li class="lvl-3">
<p><strong>输入控制逻辑</strong>：决定数据的输入方式（串行或并行）。</p>
</li>
<li class="lvl-3">
<p><strong>输出控制逻辑</strong>：决定数据的输出方式。</p>
</li>
</ol>
<p><strong>工作原理</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个时钟周期，寄存器中的数据根据设定方向进行一次移位。</p>
</li>
<li class="lvl-2">
<p>输入数据按要求补充到移位方向的空位。</p>
</li>
<li class="lvl-2">
<p>移出的数据可以输出到其他模块。</p>
</li>
</ul>
<hr>
<h3 id="移位寄存器的应用"><a class="header-anchor" href="#移位寄存器的应用">¶</a><strong>移位寄存器的应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据延迟</strong>：移位寄存器可以延迟数据的传输，用于信号同步。</p>
</li>
<li class="lvl-3">
<p><strong>串并转换</strong>：实现串行和并行数据的转换。</p>
</li>
<li class="lvl-3">
<p><strong>计数器</strong>：通过移位操作实现二进制计数功能。</p>
</li>
<li class="lvl-3">
<p><strong>加密与解码</strong>：如线性反馈移位寄存器（LFSR）常用于伪随机数生成和加密。</p>
</li>
<li class="lvl-3">
<p><strong>信号处理</strong>：在数字信号处理中，用于滤波器设计、数据流处理等。</p>
</li>
</ol>
<hr>
<h3 id="示例电路：4位右移寄存器"><a class="header-anchor" href="#示例电路：4位右移寄存器">¶</a><strong>示例电路：4位右移寄存器</strong></h3>
<p>假设有 4 个触发器（D1, D2, D3, D4）组成一个右移寄存器，初始状态为 <code>1010</code>，右移过程如下：</p>
<ol>
<li class="lvl-3">
<p><strong>时钟周期 1</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1101</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 2</strong>：输入新数据 <code>0</code>，移位后数据为 <code>0110</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 3</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1011</code>。</p>
</li>
</ol>
<p><strong>右移逻辑</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个触发器的输入来自于它左侧触发器的输出（例如，D4 的输入来自 D3 的输出）。</p>
</li>
</ul>
<hr>
<p>移位寄存器在数字系统中是一种基础组件，可以通过设计不同的逻辑电路实现各种复杂功能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计组-第三章-存储系统的基本概念</title>
    <url>/posts/80359a17.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放计组第三章笔记</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="存储器的层次结构"><a class="header-anchor" href="#存储器的层次结构">¶</a>存储器的层次结构</h2>
<p><img src="./assets/image-20241217163358988.png" alt="image-20241217163358988"></p>
<h2 id="存储器的分类"><a class="header-anchor" href="#存储器的分类">¶</a>存储器的分类</h2>
<h3 id="按层次"><a class="header-anchor" href="#按层次">¶</a>按层次</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>高速缓存（cache</p>
</li>
<li class="lvl-2">
<p>主存储器（主存、内存</p>
</li>
<li class="lvl-2">
<p>辅助存储器（辅存、外存</p>
</li>
</ul>
<p>其中高速缓存和主存可以被CPU直接读写</p>
<h3 id="按存储介质分类"><a class="header-anchor" href="#按存储介质分类">¶</a>按存储介质分类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>半导体存储器：以半导体器件存储信息</p>
</li>
<li class="lvl-2">
<p>磁表面存储器：以磁性材料存储</p>
</li>
<li class="lvl-2">
<p>光存储器：以光介质存储</p>
</li>
</ul>
<h3 id="按存取方式"><a class="header-anchor" href="#按存取方式">¶</a>按存取方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机存取存储器：读写任何一个存储单元所需的时间都相同，与存储单元的物理位置无关</p>
</li>
<li class="lvl-2">
<p>顺序存取存储器：读写一个存储单元所需时间取决于存储单元所在的物理位置</p>
</li>
<li class="lvl-2">
<p>直接存取存储器：既有随机存取特性，也有顺序存储特性。先直接选取信息所在区域，再按顺序方式存取</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>特殊的存储器</h4>
<p>相联存储器：即，可以按照内容检索到存储位置进行读写</p>
<p>“快表”就是一种相联存储器</p>
</p>
    </div>
</div><h2 id="按信息的可更改性"><a class="header-anchor" href="#按信息的可更改性">¶</a>按信息的可更改性</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>读写存储器：即可读、也可写（如，磁盘、内存、cache</p>
</li>
<li class="lvl-2">
<p>只读存储器：只能读，不能写（如实体音乐专辑通常采用CD-ROM</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>事实上，很多ROM也可多次读写，只是比较麻烦</p>
</p>
    </div>
</div><h2 id="信息的可保存性"><a class="header-anchor" href="#信息的可保存性">¶</a>信息的可保存性</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>易失性存储器：断电后存储信息消失的存储器</p>
</li>
<li class="lvl-2">
<p>非易失性存储器：断电后，存储器信息任然保持</p>
</li>
<li class="lvl-2">
<p>破环性读出：信息读出后，原存储信息被破坏</p>
</li>
<li class="lvl-2">
<p>非破坏性读出：信息读出后，原存储信息不被破坏</p>
</li>
</ul>
<h2 id="存储器的性能指标"><a class="header-anchor" href="#存储器的性能指标">¶</a>存储器的性能指标</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>存储容量：存储字 * 字长</p>
</li>
<li class="lvl-2">
<p>单位成本：每位价格 = 总成本/总容量</p>
</li>
<li class="lvl-2">
<p>存储速度：<span style="color:red">数据传输率</span> = 数据的宽度<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="即存储字长">[1]</span></a></sup> / 存储周期</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>MDR 位数反应存储字长</p>
<p>MAR 位数反应存储字数</p>
<p>其中，存储字数 = $2^{\text{MAR位数}}$</p>
<p><img src="./assets/image-20241217170716626.png" alt="image-20241217170716626"></p>
</p>
    </div>
</div><p><img src="./assets/image-20241217170820557.png" alt="image-20241217170820557"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">即存储字长<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-主存储器的基本组成</title>
    <url>/posts/55b84d3b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>主存储器的基本组成笔记</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="基本的半导体元件及原理"><a class="header-anchor" href="#基本的半导体元件及原理">¶</a>基本的半导体元件及原理</h2>
<p><img src="./assets/image-20241217213252690.png" alt="image-20241217213252690"></p>
<center><small>一个存储元的结构图</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通</p>
</p>
    </div>
</div><h2 id="存储器芯片的基本原理"><a class="header-anchor" href="#存储器芯片的基本原理">¶</a>存储器芯片的基本原理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172155485.png" alt="image-20241217215544934"></p>
<center><small>存储器结构</small></center>
<p>电容的状态，即当前存储元存储数据的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172137191.png" alt="image-20241217213745682"></p>
<center><small>将多个存储元串联，组成存储阵列</small></center>
<p><img src="./assets/image-20241217214844617.png" alt="image-20241217214844617"></p>
<center><small>通过将某根特定的地址线置为高电平，就可以读出存储字</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172154050.png" alt="image-20241217215427377"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172203879.png" alt="image-20241217215712458"></p>
<center><small>译码器</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172203875.png" alt="image-20241217215824431"></p>
<center><small>总容量的计算</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172202131.png" alt="image-20241217220217701"></p>
<center><small>控制电路</small></center>
<p><img src="./assets/image-20241217224002371.png" alt="image-20241217224002371"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172246538.png" alt="image-20241217224634193"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172247986.png" alt="image-20241217224756484"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172248536.png" alt="image-20241217224834432"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172249976.png" alt="image-20241217224910019"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-SRAM和DRAM</title>
    <url>/posts/9e51c077.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172253813.png" alt="image-20241217225313705"></p>
<p>相关链接|<a href="./posts/2b174fb2">改错</a></p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172254176.png" alt="image-20241217225433063"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>DRAM<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="Dynamic Random Access Memory，动态--随机--存取--存储器">[1]</span></a></sup>是使用栅极电容作为一个存储元</p>
<p>SRAM<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="Static Random Access Memory，静态--随机--存取--存储器">[2]</span></a></sup>是使用双稳态触发器作为一个存储元</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172301628.png" alt="image-20241217230118820"></p>
<h2 id="栅极电容与双稳态触发器对比"><a class="header-anchor" href="#栅极电容与双稳态触发器对比">¶</a>栅极电容与双稳态触发器对比</h2>
<h3 id="栅极电容"><a class="header-anchor" href="#栅极电容">¶</a>栅极电容</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>读出1：MOS管接通，电容放电，数据上产生电流</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>电容放电信息被破坏，是<mark>破坏性读出</mark>。读出后应有<mark>重写</mark>操作，也称再生</p>
<p>另外，电容内的电荷只能维持2ms，即使不断电，2ms后信息也会消失，2ms之内必须“刷新”一次(给电容器充电)</p>
</p>
    </div>
</div><ul class="lvl-0">
<li class="lvl-2">
<p>读出0：MOS管接通后，数据线上无电流</p>
</li>
</ul>
<p>每个存储器制造成本更低，集成度高，功耗低</p>
<h3 id="双稳态触发器"><a class="header-anchor" href="#双稳态触发器">¶</a>双稳态触发器</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>读出0：BL为低电平</p>
</li>
<li class="lvl-2">
<p>读出1：BLX为低电平</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>读出数据，触发器状态保持稳定，是<mark>非破坏性读出</mark>，<mark>无需重写</mark></p>
</p>
    </div>
</div><p>每个存储元制造成本更高，集成度低，功耗大</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172317892.png" alt="image-20241217231730785"></p>
<h2 id="DRAM的刷新"><a class="header-anchor" href="#DRAM的刷新">¶</a>DRAM的刷新</h2>
<ol>
<li class="lvl-3">
<p>多久需要刷新一次：刷新周期，一般为2ms</p>
</li>
<li class="lvl-3">
<p>每次刷新多少存储单元：以行为单位，每次刷新一行存储单元</p>
</li>
<li class="lvl-3">
<p>如何刷新：</p>
<p><span style="color:blue">有硬件支持，读出一行的信息后重新写入，占用1个 读/写周期</span></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>该处说明，无论哪种刷新方式，<span style="color:red"><big><strong>DRAM的刷新方式均是以行刷新的模式刷新的</strong></big></span></p>
</p>
    </div>
</div></li>
<li class="lvl-3">
<p>在什么时候刷新：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>思路一：每次读写完就刷新一次</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>系统的存取周期变为1us</p>
<p>前0.5us用于正常读写</p>
<p>后0.5us用于刷新某行</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>思路二：2ms内集中全部刷新</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>系统的存取周期还是0.4us</p>
<p>有一段时间专门用于刷新</p>
<p>无法访问存储器，称为访存&quot;死区&quot;</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>思路三：2ms内每行刷新1次即可</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>2ms/128 = 15.6us一次</p>
<p>每15.6us内有0.5us的&quot;死时间&quot;</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180922018.png" alt="image-20241218092153796"></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>“刷新”由存储器独立完成，不需要cpu控制</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><big><strong>DRAM通常使用行列地址，以减少选通线的数量</strong></big></p>
<p>因为如果只用一维地址线，大容量存储就会使用非常多的地址线</p>
<p>所以在实际使用时，一般采用二维地址线，即行列地址线</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180853639.png" alt="image-20241218085302674"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180856798.png" alt="image-20241218085631434"></p>
</p>
    </div>
</div><h2 id="DRAM地址线时分复用技术"><a class="header-anchor" href="#DRAM地址线时分复用技术">¶</a>DRAM地址线时分复用技术</h2>
<p>因为DRAM需要很长的寻址，所以将行地址与列地址进行复用</p>
<p>则只需要$\frac{n}{2}$条地址线</p>
<p>在地址解析时，</p>
<p>先将行地址通过地址线放入行地址缓冲器</p>
<p>再将列地址通过地址线放入列地址缓冲区</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180932106.png" alt="image-20241218093200088"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>地址线复用技术，导致地址线、地址引脚减半</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>现在的主存通常采用SDRAM芯片</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>SDRAM：同步动态刷新存储器，是现在最常用的一种DRAM</p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">Dynamic Random Access Memory，动态--随机--存取--存储器<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">Static Random Access Memory，静态--随机--存取--存储器<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-只读存储器ROM</title>
    <url>/posts/4bd706e9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180945837.png" alt="image-20241218094522856"></p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="了解各种ROM"><a class="header-anchor" href="#了解各种ROM">¶</a>了解各种ROM</h2>
<h3 id="MROM"><a class="header-anchor" href="#MROM">¶</a>MROM</h3>
<p>掩模式只读ROM</p>
<p>厂家按照客户需求，在芯片生产过长中直接写入信息，之后<span style="color:red">任何人不可重写</span>（只能读出）</p>
<p>可靠性高、灵活性差、生产周期长、只适合批量定制</p>
<h3 id="PROM"><a class="header-anchor" href="#PROM">¶</a>PROM</h3>
<p>可编程只读ROM</p>
<p>用户可用专门PROM写入器写入信息，写<span style="color:red">写一次之后就无法更改</span></p>
<h3 id="EPROM"><a class="header-anchor" href="#EPROM">¶</a>EPROM</h3>
<p>可擦除可编程只读存储器</p>
<p>允许用户写入信息，之后用某种方法擦除数据，<span style="color:red">可进行多次重写</span></p>
<h3 id="UVEPROM"><a class="header-anchor" href="#UVEPROM">¶</a>UVEPROM</h3>
<p>用紫外线照射8~20分钟，擦除<mark>所有信息</mark></p>
<h3 id="EEROM"><a class="header-anchor" href="#EEROM">¶</a>EEROM</h3>
<p>(也常记为$E^2PROM$，第一个E是Electioneering)</p>
<p>可用“电擦除”的方式，擦除<mark>特定的字</mark></p>
<h3 id="Flash-Mermory"><a class="header-anchor" href="#Flash-Mermory">¶</a>Flash Mermory</h3>
<p>闪速存储器（注：U盘，SD卡，就是闪存)</p>
<p>在EEPROM基础上发展而来，断电后也能保持信息，且<span style="color:red">可进行多次快速擦除重写</span></p>
<p>注意：由于闪存需要擦除再写入，因此<mark>闪存的“写”速度要比“读”速度更慢</mark></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>每个存储元只需单个MOS管，位密度比RAM高</p>
</p>
    </div>
</div><h3 id="SSD-Solid-State-Drives"><a class="header-anchor" href="#SSD-Solid-State-Drives">¶</a>SSD(Solid State Drives)</h3>
<p>固态硬盘</p>
<p>由控制单元+存储单元（Flash芯片）构成，与闪存存储器的核心区别在于控制单元不一样，但存储介质都类似，<span style="color:red">可进行多次快速擦除重写</span>.</p>
<p>SSD速度块、功耗低、价格高。目前个人电脑常常用SSD取代传统的机械硬盘</p>

<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>虽然**SSD与Flash（U盘、SD卡）**都可读可写，但他们都还属于ROM，</p>
<p><big><strong>即<mark>只读存储器</mark></strong></big></p>
</p>
    </div>
</div><h2 id="计算机内的重要ROM"><a class="header-anchor" href="#计算机内的重要ROM">¶</a>计算机内的重要ROM</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181924131.png" alt="image-20241218192456757"></p>
<p>主板上的BIOS芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181929447.png" alt="image-20241218192900504"></p>
<p>我们常所的“内存条”就是主存，但事实上，主板上的ROM芯片也是“主存”的一部分</p>
<p>逻辑上，主存由RAM+ROM组成，且两者常统一编址</p>
</p>
    </div>
</div><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181934036.png" alt="image-20241218193406493"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>很多ROM芯片虽然名字是“Read-Only”，但是<mark>很多ROM也可以“写”</mark></p>
</li>
<li class="lvl-2">
<p><mark>闪存的写速度一般比读速度更慢</mark>，因为写入前要先擦除</p>
</li>
<li class="lvl-2">
<p>RAM芯片是易失性的，ROM芯片是非易失性的，很多<mark>ROM也都是具有”随机存取“的特性</mark></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>双口RAM和多模块存储器</title>
    <url>/posts/eb3d57f9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181945596.png" alt="image-20241218194526205"></p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="双端口ROM"><a class="header-anchor" href="#双端口ROM">¶</a>双端口ROM</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181946113.png" alt="image-20241218194614774"></p>
<blockquote>
<p>需要由两组完全独立的数据线、地址线、控制线。</p>
<p>CPU、RAM中也要有更复杂的控制电路</p>
</blockquote>
<p>两个端口对同一主存操作有一下4种情况</p>
<ol>
<li class="lvl-3">
<p>两个端口同时对不同的地址单元存取数据。👌</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一地址单元读出数据👌</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一地址单元写入数据🚫</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一个地址单元,一个写入数据,一个读出数据🚫</p>
</li>
</ol>
<blockquote>
<p>对比操作系统,”读者写者问题”</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328791.png" alt="image-20241218202233225"></p>
<h2 id="多体并行存储器"><a class="header-anchor" href="#多体并行存储器">¶</a>多体并行存储器</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328241.png" alt="image-20241218202740359"></p>
<h3 id="交叉编址"><a class="header-anchor" href="#交叉编址">¶</a>交叉编址</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328327.png" alt="image-20241218202847344"></p>
<h4 id="高位交叉编址"><a class="header-anchor" href="#高位交叉编址">¶</a>高位交叉编址</h4>
<p>地址的前几位表示是哪一个芯片</p>
<p>如 ,  上图中 ,  高位部分  (前面的<span style="color:blue">00</span>)  就是用于表示选择$M_0$芯片的</p>
<h4 id="低位交叉编址"><a class="header-anchor" href="#低位交叉编址">¶</a>低位交叉编址</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328323.png" alt="image-20241218203356731"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>对于高位交叉编址,   和低位交叉编址.</p>
<p>地址的实际值是不太一样的</p>
<p>对于高位交叉编址,  就像是在第一个内存条编完0~7</p>
<p>在到下一个内存条边8之后的</p>
<p>而,   地位交叉编址,  就像是横着编址</p>
<p>先从第一个存储器到最后一个存储器,  依次在第一个存储单元上编上0~4</p>
<p>在从第一个存储器第二个存储单元开始,依次往后编址</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182039551.png" alt="image-20241218203939989"></p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在交叉编址的多体存储器部分</p>
<p><big><strong>连续访问同一个存储体,   是需要等待刷新时间的</strong></big></p>
<p>即,    需要等待一个整个存取时间<small>(加上了刷新时间)</small></p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182048168.png" alt="image-20241218204838550"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328881.png" alt="image-20241218205030135"></p>
<p>当需要读出地址连续的四个单元时,   低位交叉编址和高位交叉编址访存时间不同</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对高位交叉编址,   访问连续地址时,    由于高位不变,   实际上是访问同一块存储体的连续地址,   则每次读取都需要等待一整个存取周期</p>
</li>
<li class="lvl-2">
<p>对于低位交叉编址,   访问连续地址时,   由于低位是变化的,   实际上是在分别访问每块存储体的相同位置的存储单元,   而访存完第一个存储体,   无需等待第一个存储体是否完成刷新,   直接访问第二个就可以</p>
</li>
</ul>
<p>若,   设每个存储体存取周期为$T$</p>
<p>存取时间为$r$,  假设$T=4r$</p>
<p>则,   访问高地址交叉编址需要耗时$5T$,   访问低地址交叉编址需要耗时$T+4r$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>低位交叉编址的多体存储器，连续取n个存储字耗时$T+(n-1)r$</p>
</p>
    </div>
</div><blockquote>
<p>宏观上来看，读写一个字的时间接近$r$</p>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>因为，在实际使用中，程序寻访的通常是连续的地址空间</p>
<p>所以这里讨论的就是连续访问连续地址的情况</p>
</p>
    </div>
</div><h3 id="应该取几个“体”"><a class="header-anchor" href="#应该取几个“体”">¶</a>应该取几个“体”</h3>
<p>采用<mark>流水线</mark>的方式并行存取（宏观上并行，微观上串行）</p>
<p>宏观上，一个存储周期内，m体交叉存储器可以提供的数据量位单个模块m倍</p>
<p>存取周期为T，<span style="color:red">存取时间为$r$</span></p>
<p>为了使流水线不间断，应保证模块数 m&gt;=T/r</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329040.png" alt="image-20241218230442183"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>如何判断当前读取的是那个存储体？</p>
<p>首先可以将地址转为2进制，然后看最后几个</p>
<p>或者，将地址对单元数取余</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329702.png" alt="image-20241218231050318"></p>
<h2 id="多模块存储器"><a class="header-anchor" href="#多模块存储器">¶</a>多模块存储器</h2>
<h3 id="多体并行存储器-2"><a class="header-anchor" href="#多体并行存储器-2">¶</a>多体并行存储器</h3>
<p>每个模块都有相同的容量和存取速度。</p>
<p>各模块都有独立的读写控制电路、地址寄存器和数据寄存器。</p>
<p>他们既能并行工作，又能交叉工作</p>
<h3 id="单体多字存储器"><a class="header-anchor" href="#单体多字存储器">¶</a>单体多字存储器</h3>
<p>每个存储单元存储$m$个字</p>
<p>总线宽度为$m$个字</p>
<p>一次并行读出$m$个字</p>
<p>每次只能同时取$m$个字，不能单独存取其中某个字</p>
<p>指令和数据在主存内必须是连续存放的</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329600.png" alt="image-20241218231856328"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>外部存储器</title>
    <url>/posts/54bffdf5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261704217.png" alt="image-20241226170415159"></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="磁表面存储器"><a class="header-anchor" href="#磁表面存储器">¶</a>磁表面存储器</h2>
<h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3>
<ol>
<li class="lvl-3">
<p>存储容量大，位价格低；</p>
</li>
<li class="lvl-3">
<p>记录介质可以重复利用</p>
</li>
<li class="lvl-3">
<p>记录介质信息可以长期保存而不丢失，甚至可以脱机存档</p>
</li>
<li class="lvl-3">
<p>非破坏性读出，读出是不需要再生</p>
</li>
</ol>
<h3 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h3>
<ol>
<li class="lvl-3">
<p>存取速度慢</p>
</li>
<li class="lvl-3">
<p>机械结构复杂</p>
</li>
<li class="lvl-3">
<p>对工作环境要求较高</p>
</li>
</ol>
<h2 id="磁盘存储器"><a class="header-anchor" href="#磁盘存储器">¶</a>磁盘存储器</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261622185.png" alt="image-20241226162157054"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261628961.png" alt="image-20241226162755028"></p>
<h3 id="磁盘的性能指标"><a class="header-anchor" href="#磁盘的性能指标">¶</a>磁盘的性能指标</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>磁盘容量</strong>：</p>
<p>一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化和格式化容量之分。</p>
<blockquote>
<p>非格式化容量是指磁记录表面可以利用的磁化单元总数</p>
<p>格式化容量是指按照某种特定的记录格式所能存储的信息的总量</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>记录密度</strong>：</p>
<p>记录密度是指盘片单位面积上记录的二进制的信息量，通常以道目睹、位密度、面密度标识</p>
<blockquote>
<p>道密度是沿磁盘半径方向单位长度上的磁道数</p>
<p>位密度是磁道单位长度上能记录的二进制代码位数</p>
<p>面密度是位密度和道密度的乘积</p>
</blockquote>

<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>注意：</strong></p>
<p>磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同</p>
</p>
    </div>
</div></li>
<li class="lvl-2">
<p><strong>平均存取时间</strong>：<br>
$$<br>
平均存取时间 = &amp;\text{寻道时间（磁头移动到目的磁道）}+ \<br>
&amp;\text{旋转延迟时间（磁头定位到所在扇区）}+ \<br>
&amp;\text{传输时间（传输数据所花费的时间）}<br>
$$<br>
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261701734.png" alt="image-20241226170158632"></p>
</li>
<li class="lvl-2">
<p><strong>数据传输率</strong>：</p>
<p>磁盘存储器再单位时间内性主机发送数据的字节数，称为数据传输率。</p>
<blockquote>
<p>假设磁盘转速为$r$（转/秒），每条磁道容量为N个字节，则数据传输率为$D_r = rN$</p>
</blockquote>
</li>
</ul>
<h3 id="磁盘地址"><a class="header-anchor" href="#磁盘地址">¶</a>磁盘地址</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261709715.png" alt="image-20241226170958634"></p>
<blockquote>
<p>例如，</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261710344.png" alt="image-20241226171037285"></p>
</blockquote>
<h3 id="磁盘的工作过程"><a class="header-anchor" href="#磁盘的工作过程">¶</a>磁盘的工作过程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261711702.png" alt="image-20241226171128627"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261712718.png" alt="image-20241226171213642"></p>
<h2 id="磁盘阵列"><a class="header-anchor" href="#磁盘阵列">¶</a>磁盘阵列</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261712931.png" alt="image-20241226171256854"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261713815.png" alt="image-20241226171338732"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261713191.png" alt="image-20241226171354113"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261714484.png" alt="image-20241226171443399"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261716731.png" alt="image-20241226171656664"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261718019.png" alt="image-20241226171845941"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261719172.png" alt="image-20241226171955101"></p>
<h2 id="固态硬盘SSD"><a class="header-anchor" href="#固态硬盘SSD">¶</a>固态硬盘SSD</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261721593.png" alt="image-20241226172132486"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261723463.png" alt="image-20241226172317360"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>系统读写固态硬盘是以一个页为单位的</p>
<p>也就是说，固态硬盘中的一个页相当于磁盘中的一个扇区</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>以块为单位擦除，擦除后，每个块可以被写一次，被读无限次</p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>OS</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.3-Cache与主存的映射方式</title>
    <url>/posts/bb85a050.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261117696.png" alt="image-20241226111710525"></p>
<h3 id="全相联映射"><a class="header-anchor" href="#全相联映射">¶</a>全相联映射</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261119088.png" alt="image-20241226111947501"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>提高了命中率，只要cache没有满，就可以存</p>
</p>
    </div>
</div><h3 id="直接映射"><a class="header-anchor" href="#直接映射">¶</a>直接映射</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261130493.png" alt="image-20241226113021569"></p>
<p>块号末尾三位，反应了应该存放在Cache块中的哪个位置</p>
<p>实际在cache存放标记时，也只需要存放前面19位，末尾三位与块号直接对应，无需存放。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261135329.png" alt="image-20241226113503748"></p>
<h3 id="组相联映射"><a class="header-anchor" href="#组相联映射">¶</a>组相联映射</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261137927.png" alt="image-20241226113753352"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261138537.png" alt="image-20241226113823483"></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>主存储器与CPU的连接</title>
    <url>/posts/4ec7c2a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412191014934.png" alt="image-20241219101421005"></p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261741152.png" alt="image-20241226174114040"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261741274.png" alt="image-20241226174133203"></p>
<h2 id="存储器芯片的输入输出信号"><a class="header-anchor" href="#存储器芯片的输入输出信号">¶</a>存储器芯片的输入输出信号</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261743720.png" alt="image-20241226174324667"></p>
<h3 id="位扩展"><a class="header-anchor" href="#位扩展">¶</a>位扩展</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261745112.png" alt="image-20241226174551023"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261747477.png" alt="image-20241226174710399"></p>
<h3 id="字扩展"><a class="header-anchor" href="#字扩展">¶</a>字扩展</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261752076.png" alt="image-20241226175245985"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261755725.png" alt="image-20241226175557634"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261759344.png" alt="image-20241226175900280"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261759896.png" alt="image-20241226175945684"></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261801842.png" alt="image-20241226180106765"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>补充知识-译码器</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261803025.png" alt="image-20241226180308959"></p>
<h5>74LS138</h5>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412262146520.png" alt="image-20241226214653458"></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.1+3.5.2-Cache的基本工作原理</title>
    <url>/posts/1e2c87d9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>Cache的替换算法</title>
    <url>/posts/47b18223.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261142582.png" alt="image-20241226114252796"></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="先进先出"><a class="header-anchor" href="#先进先出">¶</a>先进先出</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261216886.png" alt="image-20241226121625901"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261216992.png" alt="image-20241226121639684"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>抖动现象：</p>
<p>频繁的换入换出现象</p>
</p>
    </div>
</div><h3 id="近期最少使用算法-LRU"><a class="header-anchor" href="#近期最少使用算法-LRU">¶</a>近期最少使用算法 (LRU)</h3>
<p>基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能再次被访问，因此淘汰最久没有被访问过的块是合理的。</p>
<p>LRU算法的实际运行效果优秀，Cache命中率高</p>
<p>若被频繁访问到的主存块数量 &gt; Cache 行的数量：则有可能发送“抖动”，如${1, 2, 3, 4, 5, 1, 2, …}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261236061.png" alt="image-20241226123612555"></p>
<p>计数器用来记录Cache块已经多久没有被访问了。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<ol>
<li class="lvl-3">命中时，所命中的行的计数器清零，<mark>比其低的计数器加1，其余不变</mark>。<small>可以保证计数器的最大值可以达到的范围恰好是Cache的总数</small></li>
<li class="lvl-3">未命中且还有空闲行时，<strong>新装入的</strong>行的计数器<strong>置0</strong>，其余<strong>非空闲行</strong>全<strong>加1</strong></li>
<li class="lvl-3">未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其他全加1https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261254036.png。<small>为什么没说空闲行的事呢，因为此时已经没有空闲行了</small></li>
</ol>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>Cache块的总数 = $2^n$，则计数器只需n位。且Cache装满后所有计数器的值一定不重复。</p>
</p>
    </div>
</div><h3 id="最近不经常使用算法（LFU）"><a class="header-anchor" href="#最近不经常使用算法（LFU）">¶</a>最近不经常使用算法（LFU）</h3>
<p>为每个Cache块设置一个“计数器”，用于记录每个Cache块被访问过几次。当Cache满后<mark>替换“计数器”最小的</mark>。</p>
<p>曾经被经常访问的主存块在未来不一定会用到，<small>即，短时间内大量访问</small></p>
<p>并没有很好的遵循局部性原理，因此实际运行效果不如LRU</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261250759.png" alt="image-20241226125036315"></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261254036.png" alt="image-20241226125432990"></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>Cache写策略</title>
    <url>/posts/3f4cf4e9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261407506.png" alt="image-20241226140657366"></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>不讨论读命中，读不命中的情况？</p>
<p>读操作不会导致Cache和主存的数据不一致</p>
</p>
    </div>
</div><h2 id="写命中"><a class="header-anchor" href="#写命中">¶</a>写命中</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>写回法</strong></p>
<p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存</p>
<p>同时，若该块在没有修改的情况下被换出，则不需要写回</p>
<p>存在数据不一致隐患</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261414771.png" alt="image-20241226141409255"></p>
</li>
<li class="lvl-2">
<p><strong>全写法（写直通法，write-through）</strong></p>
<p>当Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲</p>
<p>访存次数增加，速度变慢，但更能保证数据一致性</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261417376.png" alt="image-20241226141727699"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261424026.png" alt="image-20241226142428464"></p>
</li>
</ul>
<h3 id="写不命中"><a class="header-anchor" href="#写不命中">¶</a>写不命中</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>写分配法</strong></p>
<p>当CPU对Cache<span style="color:red">写不命中时</span>，把主存的块调入Cache，在Cache中修改。通常<mark>搭配写回法</mark>使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261427631.png" alt="image-20241226142733273"></p>
</li>
<li class="lvl-2">
<p><strong>非写分配法</strong></p>
<p>当CPU对Cache<span style="color:red">写不命中时</span>只写入主存，不调入Cache，搭配<mark>全写法</mark>使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261431430.png" alt="image-20241226143107155"></p>
</li>
</ul>
<h2 id="多级Cache"><a class="header-anchor" href="#多级Cache">¶</a>多级Cache</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261433778.png" alt="image-20241226143306530"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261433290.png" alt="image-20241226143355503"></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412261435472.png" alt="image-20241226143458491"></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>SRAM与DRAM-改错</title>
    <url>/posts/2b174fb2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>SRAM与DRAM改错</p>
<p>相关链接|<a href="./posts/9e51c077">SRAM和DRAM</a></p>
</p>
    </div>
</div><span id="more"></span>
<ol>
<li class="lvl-3">
<p>动态RAM采用哪种刷新方式刷新时，不存在死时间</p>
<ul class="lvl-2">
<li class="lvl-5"><em>集中刷新</em>：集中刷新必然存在死时间</li>
<li class="lvl-5"><em>分散刷新</em>：机器的存取周期中的一段时间用来读/写，另一段时间用来刷新，因此不存在死时间，但存取周期变长</li>
<li class="lvl-5"><em>异步刷新</em>：异步刷新虽然缩短了死时间，但死时间依然存在</li>
</ul>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于芯片引脚数的计算：</h4>
<ol>
<li class="lvl-3">
<p>某一DRAM芯片，采用地址复用技术，其容量为$1024*8$位，除电源和接地端外，该芯片的引脚数最少是？</p>
<ul class="lvl-3">
<li class="lvl-5">$1024*8$位，因此可寻址范围是$1024B = 2^{10}B$，按字节寻址。采用地址复用技术时，通过行通选和列通选分行、列两次传送地址信号，因此地址线减半为5根，数据线仍为$8$根；加上行通选和列通选及读/写（片选线用行通选代替）4根，总共是$17$根</li>
</ul>
<blockquote>
<p>总结：</p>
<p>DRAM，动态RAM的地址计算</p>
<p>$引脚数 = \text{地址线(复用，减半)} + 数据线 + \text{行/列通选(2根)} + \text{读/写(两根)}$</p>
</p>
    </div>
</div></li>
</ol>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于不同访存方式的耗时计算</h4>
<ol>
<li class="lvl-3">
<p>某机器采用四体交叉存储器，现分别执行下述操作：</p>
<ul class="lvl-3">
<li class="lvl-5">读取$6$个连续地址单元中存放的存储字，重复80次</li>
<li class="lvl-5">读取$8$个连续地址单元中存放的存储字，重复60次</li>
</ul>
<p>则前一操作和后一操作所花费的时间之比为?</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412191651753.png" alt="image-20241219165101405"></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在做该类型的题目时，要根据不同的访存策略，画出每个存储器访问状态的甘特图!</p>
</p>
    </div>
</div></li>
</ol>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>IO</title>
    <url>/posts/8601bab2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="I-O系统"><a class="header-anchor" href="#I-O系统">¶</a>I/O系统</h2>
<h3 id="I-O系统的层次结构"><a class="header-anchor" href="#I-O系统的层次结构">¶</a>I/O系统的层次结构</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>用户层软件</strong>：产生I/O请求、格式化I/O、Spooling</p>
</li>
<li class="lvl-2">
<p><strong>设备独立性软件</strong>：映射、保护、分块、缓冲、分配</p>
</li>
<li class="lvl-2">
<p><strong>设备驱动程序</strong>：设置设备寄存器；检测状态</p>
</li>
<li class="lvl-2">
<p><strong>中断处理程序</strong>：发出操作指令、驱动设备工作</p>
</li>
<li class="lvl-2">
<p><strong>硬件</strong>：执行I/O操作</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>磁盘属于共享设备，因为多个进程可以同时使用，因为我们学过磁盘调度算法。</p>
</p>
    </div>
</div><h2 id="I-O硬件"><a class="header-anchor" href="#I-O硬件">¶</a>I/O硬件</h2>
<h3 id="设备控制器"><a class="header-anchor" href="#设备控制器">¶</a>设备控制器</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>I/O设备包括一个机械部件和一个电子部件。</p>
</li>
<li class="lvl-2">
<p>电子部件称为设备控制器或适配器，在 PC 中，它常常是插入主板扩充槽的印刷电路板</p>
</li>
<li class="lvl-2">
<p>机械部件则是设备本身。</p>
</li>
</ul>
<h3 id="通道"><a class="header-anchor" href="#通道">¶</a>通道</h3>
<h3 id="I-O控制方式"><a class="header-anchor" href="#I-O控制方式">¶</a>I/O控制方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>轮询</p>
</li>
<li class="lvl-2">
<p>中断</p>
</li>
<li class="lvl-2">
<p>直接存储器存取DMA</p>
</li>
<li class="lvl-2">
<p>通道</p>
</li>
</ul>
<h4 id="直接存储器存取DMA"><a class="header-anchor" href="#直接存储器存取DMA">¶</a>直接存储器存取DMA</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412221655024.png" alt="image-20241222165458479"></p>
<h2 id="缓冲技术"><a class="header-anchor" href="#缓冲技术">¶</a>缓冲技术</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412221938857.png" alt="image-20241222193829711"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412221938139.png" alt="image-20241222193849286"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>为什么双缓冲区对一块数据的处理时间为$Max(C+M,T)$?</h5>
<p>双缓冲区解决了I/O设备写入缓冲区和用户进程读出缓冲区的冲突</p>
<p>即，写入缓冲区和读出缓冲区可以并行</p>
<p>而，在进程操作当前缓冲区数据时，是无法将数据再次读入内存的</p>
<p>因为此时还在操作上一个读入的数据</p>
<p>故，数据读入和数据处理并不能并行。</p>
<p>则处理一块的时间为$Max(C+M,T)$.</p>
<p><small>若，读出缓冲区和操作数据可以并行，则时间为$Max(C,M,T)$</small></p>
</p>
    </div>
</div><h2 id="磁盘存储器"><a class="header-anchor" href="#磁盘存储器">¶</a>磁盘存储器</h2>
<h3 id="磁盘调度算法"><a class="header-anchor" href="#磁盘调度算法">¶</a>磁盘调度算法</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412222011943.png" alt="image-20241222201157430"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>存储器概述-改错</title>
    <url>/posts/3e13835c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>存储器概述改错</p>
</p>
    </div>
</div><span id="more"></span>
<ol>
<li class="lvl-3">
<p>磁盘属于直接存取存储器</p>
</li>
<li class="lvl-3">
<p>设机器字长为$32$位，一个容量为$16MB$的存储器，CPU按半字存储，其可寻址的单元数是：</p>
<ul class="lvl-2">
<li class="lvl-5">$16{MB} = 2<sup>{24}B$，由于字长为32位，现按半字(2B)寻址，可寻址单元数为$2</sup>{24}B/2B = 2^{23}$。</li>
</ul>
</li>
<li class="lvl-3">
<p>若某存储器存储周期位250ns，每次读出16位，该存储器的数据传输速率为</p>
<ul class="lvl-2">
<li class="lvl-5">每个存储周期读出$16bit = 2B$，因此数据传输速率为$2B/(250*10<sup>{-9})$，即$8*10</sup>4B/s$</li>
</ul>
</li>
<li class="lvl-3">
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>计组</category>
        <category>第三章.存储系统</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟存储器</title>
    <url>/posts/fd972ae3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>OS第五章总结</title>
    <url>/posts/6070b0ed.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一下存储器管理的笔记把</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="学习目标"><a class="header-anchor" href="#学习目标">¶</a>学习目标</h2>
<p>Ø能够理解各层存储器的作用</p>
<p>Ø理解存储管理的基本任务</p>
<p>Ø理解逻辑地址、物理地址的概念</p>
<p>Ø理解程序装入的实现方式及特点</p>
<p>Ø理解程序链接的实现方式及特点</p>
<h2 id="目标评价"><a class="header-anchor" href="#目标评价">¶</a>目标评价</h2>
<ol>
<li class="lvl-3">
<p>说出常见的计算机存储硬件</p>
</li>
<li class="lvl-3">
<p>说出存储层次中各硬件的特点</p>
</li>
<li class="lvl-3">
<p>分析源程序、目标程序和可执行程序的地址形式</p>
</li>
<li class="lvl-3">
<p>理解CPU对内存的访问过程</p>
</li>
<li class="lvl-3">
<p>说出程序的装入和链接方式</p>
</li>
</ol>
<h2 id="基础概念"><a class="header-anchor" href="#基础概念">¶</a>基础概念</h2>
<h3 id="内存管理的任务"><a class="header-anchor" href="#内存管理的任务">¶</a>内存管理的任务</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配回收</p>
</li>
<li class="lvl-2">
<p>地址转换</p>
</li>
<li class="lvl-2">
<p>存储扩充</p>
</li>
<li class="lvl-2">
<p>存储保护</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>学后应能够回答的问题</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131403033.png" alt="image-20241213140352275"></p>
</p>
    </div>
</div><h3 id="存储器的层次结构"><a class="header-anchor" href="#存储器的层次结构">¶</a>存储器的层次结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131405756.png" alt="image-20241213140513750"></p>
<center><small>计算机存储层次示意图</small></center>
<h4 id="寄存器"><a class="header-anchor" href="#寄存器">¶</a>寄存器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>存放<code>CPU</code>执行时的数据和指令</p>
</li>
</ul>
<h4 id="高速缓存"><a class="header-anchor" href="#高速缓存">¶</a>高速缓存</h4>
<p>介于寄存器和存储器之间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>备份主存常用数据和指令，减少对主存储器的访问次数</p>
</li>
<li class="lvl-2">
<p>缓和内存和处理机之间的矛盾</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131408580.png" alt="image-20241213140854868"></p>
<center><small>多级缓存</small></center>
<p>l1d：一级数据缓存</p>
<p>L1i：一级指令缓存</p>
<p>L2 cache：二级缓存</p>
<p>L3 cache：三级缓存</p>
</p>
    </div>
</div><h4 id="磁盘缓存"><a class="header-anchor" href="#磁盘缓存">¶</a>磁盘缓存</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>暂时存放频繁使用的一部分磁盘数据和信息</p>
</li>
<li class="lvl-2">
<p>缓和主存和I/O设备在速度上的额不匹配</p>
</li>
<li class="lvl-2">
<p><strong>利用主存的部分空间，主存可看成辅存的高速缓存</strong></p>
</li>
</ul>
<h4 id="主存"><a class="header-anchor" href="#主存">¶</a>主存</h4>
<h5 id="性能指标"><a class="header-anchor" href="#性能指标">¶</a>性能指标</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>按<strong>字节</strong>连续编址，没个存储单元为1个字节<small>(8个二进制位)</small></p>
</li>
<li class="lvl-2">
<p>存储容量：所包含的存储单元总数<small>(单位：MB或GB)</small></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131419619.png" alt="image-20241213141949137"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>简例</h5>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131421631.png" alt="image-20241213142102753"></p>
</p>
    </div>
</div><h3 id="程序地址"><a class="header-anchor" href="#程序地址">¶</a>程序地址</h3>
<h4 id="程序在成为进程前的准备工作"><a class="header-anchor" href="#程序在成为进程前的准备工作">¶</a>程序在成为进程前的准备工作</h4>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>总结</h5>
<h6>程序在成为进程前的准备工作</h6>
<ul class="lvl-1">
<li class="lvl-2">
<p><span style="color:red">编辑</span>：形成源文件(<span style="color:blue">符号地址</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">编译</span>：形成目标模块(<span style="color:blue">模块内符号地址解析</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">链接</span>：由多个模块或程序库形成可执行文件(<span style="color:blue">模块间符号地址解析</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">装入</span>：构造PCB，形成进程(<span style="color:blue">物理地址</span>)</p>
</li>
</ul>
</p>
    </div>
</div><ol>
<li class="lvl-3">
<p>编辑：编写源程序</p>
</li>
<li class="lvl-3">
<p>编译：由编译程序<small>(Complier)</small>对源程序进行编译，形成若干个目标模块</p>
</li>
<li class="lvl-3">
<p>链接：由链接程序<small>(Linker)</small>将目标模块和他们所需要的库函数链接在一起，形成一个完整的装入模块</p>
</li>
<li class="lvl-3">
<p>装入：由装入程序<small>(Loader)</small>，将装入模块装入内存</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>就像C语言代码，到运行的过程：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>编译</p>
</li>
<li class="lvl-2">
<p>链接</p>
</li>
<li class="lvl-2">
<p>运行</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="程序各阶段的地址变换"><a class="header-anchor" href="#程序各阶段的地址变换">¶</a>程序各阶段的地址变换</h4>
<ol>
<li class="lvl-3">
<p>源程序编译后的main.s</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131438484.png" alt="image-20241213143808948"></p>
<p>add：符号表示</p>
<p><big><strong>符号地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>源程序汇编后的main.o和test.o反汇编的文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131438521.png" alt="image-20241213143843828"></p>
<p>13：整数值</p>
<p><big><strong>相对地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>可执行程序myprog</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131440028.png" alt="image-20241213144033296"></p>
<p>4004e2 ：整数值</p>
<p><big><strong>相对地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>可执行文件装入内存执行时的地址？</p>
<p>内存单元地址<small><span style="color:red">由CPU对内存的访问方式决定</span></small></p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>编译、汇编、链接，三个过程的地址变换是编译器做的</p>
<p>而，将生成好的可执行文件，放到内存中运行，是操作系统要考虑的事情</p>
</p>
    </div>
</div><h4 id="物理地址和逻辑地址"><a class="header-anchor" href="#物理地址和逻辑地址">¶</a>物理地址和逻辑地址</h4>
<h5 id="物理地址-small-绝对地址-small"><a class="header-anchor" href="#物理地址-small-绝对地址-small">¶</a>物理地址<small>(绝对地址)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>物理内存的地址，内存以字节位单位编址</p>
</li>
<li class="lvl-2">
<p>物理地址空间：所有物理地址的集合</p>
</li>
</ul>
<h5 id="逻辑地址-small-虚拟地址、相对地址-small"><a class="header-anchor" href="#逻辑地址-small-虚拟地址、相对地址-small">¶</a>逻辑地址<small>(虚拟地址、相对地址)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>由CPU产生的地址，即成程序编译后使用的相对于0字节的地址</p>
</li>
<li class="lvl-2">
<p>逻辑地址空间：由程序所生成的所有逻辑地址的集合</p>
</li>
</ul>
<h5 id="地址转换-small-地址重定位、地址映射-small"><a class="header-anchor" href="#地址转换-small-地址重定位、地址映射-small">¶</a>地址转换<small>(地址重定位、地址映射)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序中的逻辑地址转换为物理地址</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><span style="color:red">地址转换是操作系统内存管理任务之一</span></p>
</p>
    </div>
</div><h3 id="程序的装入"><a class="header-anchor" href="#程序的装入">¶</a>程序的装入</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131504204.png" alt="image-20241213150423225"></p>
<center><small>程序装入示意图</small></center>
<h4 id="地址转换时期"><a class="header-anchor" href="#地址转换时期">¶</a>地址转换时期</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>绝对装入方式</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>编译</strong>产生的地址使用<strong>绝对地址</strong></li>
<li class="lvl-4">程序或数据被修改时，需要重新编译程序</li>
</ul>
</li>
<li class="lvl-2">
<p>可重定位装入方式</p>
<ul class="lvl-2">
<li class="lvl-4">编译后的目标模块使用相对地址</li>
<li class="lvl-4">在<strong>装入</strong>时，完成<strong>重定位</strong><big>(静态重定位)</big></li>
<li class="lvl-4">需硬件支持</li>
</ul>
</li>
<li class="lvl-2">
<p>动态运行时装入方式</p>
<ul class="lvl-2">
<li class="lvl-4">编译后的目标模块使用相对地址</li>
<li class="lvl-4">在<strong>运行</strong>时，完成重定位<big>(动态重定位)</big></li>
</ul>
</li>
</ul>
<h4 id="程序的链接"><a class="header-anchor" href="#程序的链接">¶</a>程序的链接</h4>
<h5 id="静态链接"><a class="header-anchor" href="#静态链接">¶</a>静态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在程序运行前，将各目标模块及它们所需的库函数链接成一个完整的装配模块</p>
</li>
<li class="lvl-2">
<p>对相对地址进行修改；变换外部调用符号</p>
</li>
</ul>
<h5 id="装入时动态链接"><a class="header-anchor" href="#装入时动态链接">¶</a>装入时动态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在装入内存时，采用边装入边链接的链接方式</p>
</li>
<li class="lvl-2">
<p>便于修改和更新</p>
</li>
<li class="lvl-2">
<p>便于实现对目标模块的共享</p>
</li>
</ul>
<h5 id="运行时动态链接"><a class="header-anchor" href="#运行时动态链接">¶</a>运行时动态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>将某些目标模块的链接推迟到执行时才执行</p>
</li>
<li class="lvl-2">
<p>加快装入过程，节省大量的内存空间</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>对于<strong>运行时动态链接</strong>，动态链接库像是相关联的东西</p>
<h4>动态链接库<small><a href="/posts/29b48e9">详细介绍</a></small></h4>
<p>动态链接库（Dynamic Link Library，简称DLL）是包含可以由多个程序共享使用的代码和数据的文件。这种技术使程序能够高效地复用资源、减少重复代码以及节省内存空间。</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<div style="overflow:hidden;"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131612602.png" alt="image-20241213161228676" style="zoom:40%;float:left;" /><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131614525.png" alt="image-20241213161403091" style="zoom:40%;float:right;" /></div>
<center><small>链接示意图</small></center>
</p>
    </div>
</div><hr>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>各种存储管理方案</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131617839.png" alt="image-20241213161739973"></p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>学习目标</h3>
<p><big><span style="color:blue"><strong>掌握各种存储管理方案的内存分配回收、数据结构、地址转换、存储保护、主要技术、优缺点</strong></span></big></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>能够分析单一分区、固定分区、动态分区的管理方式及优缺点</p>
</li>
<li class="lvl-2">
<p>掌握操作系统分区管理的数据结构、分区分配算法、回收算法</p>
</li>
<li class="lvl-2">
<p>理解并应用分区管理的地址变换方法</p>
</li>
<li class="lvl-2">
<p>掌握分区管理的内存扩充技术：交换、覆盖、紧凑</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131622972.png" alt="image-20241213162230528"></p>
</p>
    </div>
</div><h2 id="连续分配存储管理方式"><a class="header-anchor" href="#连续分配存储管理方式">¶</a>连续分配存储管理方式</h2>
<p><span style="color:red">连续存储方式：</span>为一个用户程序分配一个连续的内存空间</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>分类</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>单一连续分区</p>
</li>
<li class="lvl-2">
<p>固定连续分区</p>
</li>
<li class="lvl-2">
<p>动态分区分配</p>
</li>
<li class="lvl-2">
<p>动态可重定位分区分配</p>
</li>
</ul>
</p>
    </div>
</div><h3 id="单一连续分区"><a class="header-anchor" href="#单一连续分区">¶</a>单一连续分区</h3>
<h4 id="分配方式"><a class="header-anchor" href="#分配方式">¶</a>分配方式</h4>
<p><strong>单道</strong>程序环境下，仅装有一道用户程序，整个内存的用户空间由该程序独占。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配管理非常简单，内存利用率低</p>
</li>
<li class="lvl-2">
<p>用于单用户、单任务OS</p>
</li>
<li class="lvl-2">
<p>CP/M、MS-DOS、RT11</p>
</li>
</ul>
<h3 id="固定分区"><a class="header-anchor" href="#固定分区">¶</a>固定分区</h3>
<h4 id="管理方式"><a class="header-anchor" href="#管理方式">¶</a>管理方式</h4>
<p>多个分区可装多道程序</p>
<p>分区大小固定</p>
<p>分区个数固定</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131631934.png" alt="image-20241213163147362"></p>
<center><small>固定分区(大小相同)<small>(左)</small>，固定分区(大小不同)<small>(右)</small></small></center>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>固定分区中，使用固定分区使用表来管理分区的使用情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151344340.png" alt="image-20241215134409673"></p>
<center><small>固定分区使用表</small></center>
</p>
    </div>
</div><h4 id="地址重定位与存储保护"><a class="header-anchor" href="#地址重定位与存储保护">¶</a>地址重定位与存储保护</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151346947.png" alt="image-20241215134606043"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态重定位</p>
</li>
<li class="lvl-2">
<p>界限寄存器</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>静态重定位</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>在<strong>程序装载</strong>时，<strong>由操作系统</strong>将逻辑地址加上分区的起始地址，转换为物理地址</p>
</li>
<li class="lvl-2">
<p>该方法简单，但程序装载后地址固定，无法移动<small>(但固定分区情况下，程序确实不会发生移动)</small></p>
</li>
</ul>
<h5>界限寄存器</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>每一个分区设置一个界限寄存器，记录该分区的最大地址范围。</p>
</li>
<li class="lvl-2">
<p>访问内存时，硬件检查物理地址是否在分区范围内，超出范围则触发包含异常。</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h4>
<p>优点：易于实现，开销小</p>
<p><span style="color:red">问题</span>：</p>
<ol>
<li class="lvl-3">
<p>可能存在内碎片和外碎片</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>内碎片</strong>：占用分区之内未被利用的空间</p>
<p><strong>外碎片</strong>：占用分区之间难以利用的空闲分区<small>通常是小的空闲分区</small></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>举个例子：</p>
<p>例如，现在操作系统分给的固定分区大小为16k</p>
<p>但是又进程现在申请12k大小的内存，但是由于操作系统为固定分区模式，所以只能给该进程分一个大小为16k的分区，这样就有4k空间被浪费了，这浪费的4K空间称为内碎片</p>
<p>另外，再比如，现在操作系统仅剩下1K的存储空间，所有进程都无法装入，这1K存储空间，就称为内碎片</p>
</p>
    </div>
</div></p>
    </div>
</div></li>
<li class="lvl-3">
<p>分区数固定，限制了并发执行的程序数目</p>
</li>
</ol>
<h3 id="动态分区"><a class="header-anchor" href="#动态分区">¶</a>动态分区</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439067.png" alt="image-20241215143909924"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439724.png" alt="image-20241215143929060"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439958.png" alt="image-20241215143947058"></p>
<center><small>动态分区示意图</small></center>
<h4 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151500000.png" alt="image-20241215150022370"></p>
<center><small>已分配分区表</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151501017.png" alt="image-20241215150156082"></p>
<center><small>空闲分区表</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151503462.png" alt="image-20241215150357079"></p>
<center><small>空闲分区链</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>空闲分区链用于高效的管理空闲内存块</p>
<p>看起来，每一个空闲分区中，都会存放下一个空闲分区的首地址</p>
<p>另外，还会存放当前分区的大小</p>
</p>
    </div>
</div><h4 id="分配算法"><a class="header-anchor" href="#分配算法">¶</a>分配算法</h4>
<h5 id="基于-span-style-color-blue-顺序搜索-span-的动态分区分配算法"><a class="header-anchor" href="#基于-span-style-color-blue-顺序搜索-span-的动态分区分配算法">¶</a>基于<span style="color:blue">顺序搜索</span>的动态分区分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>依次搜索空闲分区链上的空闲分区，寻找一个大小能够满足要求的分区</p>
</li>
<li class="lvl-2">
<p>首次适应算法、循环适应算法、最佳适应算法、最坏适应算法</p>
</li>
</ul>
<h6 id="首次适应算法"><a class="header-anchor" href="#首次适应算法">¶</a>首次适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>空闲分区链以<strong>地址</strong>递增的次序链接<small>(<span style="color:red;">注意！</span>这里不是按照空闲分区的大小进行链接)</small></p>
</li>
<li class="lvl-2">
<p>从链首开始顺序查找，直到找到一个大小能够满足要求的空闲分区为止</p>
<p><span style="color:blue"><small>此处的含义是：当找到一处空闲块，空闲分区的大小<strong>大于</strong>当前需要装入的进程时，就会将该空闲块中<strong>进程所需要的部分</strong>  分给进程，剩下的部分<strong>仍作为空闲分区</strong></small></span></p>
</li>
<li class="lvl-2">
<p>缺点：低址部分留下许多小碎片</p>
</li>
</ul>
<h6 id="循环首次适应算法"><a class="header-anchor" href="#循环首次适应算法">¶</a>循环首次适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><span style="color:red">从上次找到的空闲分区的下一个空闲分区开始查找</span>，直到找到一个能满足要求的空闲分区</p>
</li>
<li class="lvl-2">
<p>空闲分区分布更均匀，减少了查找的开销</p>
</li>
<li class="lvl-2">
<p>缺乏大的空闲分区</p>
</li>
</ul>
<h6 id="最佳适应算法"><a class="header-anchor" href="#最佳适应算法">¶</a>最佳适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>搜索整个序列，找到适合条件的最小分区进行分配</p>
</li>
<li class="lvl-2">
<p>空闲分区按其<strong>容量</strong>从小到大的顺序链接</p>
</li>
<li class="lvl-2">
<p>用最小空间满足要求；但留下许多难以利用的小碎片</p>
</li>
</ul>
<h6 id="最坏适应算法"><a class="header-anchor" href="#最坏适应算法">¶</a>最坏适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>搜索整个序列，寻找最大分区进行匹配</p>
</li>
<li class="lvl-2">
<p>空闲分区按其容量从大到小的顺序链接</p>
</li>
<li class="lvl-2">
<p>分割后空闲块任为较大空块；缺乏大的空闲分区</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>关于每种分配算法是否会产生 内/外碎片的讨论</h5>
<h6>首次适应算法</h6>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>不会产生内碎片</strong>：因为首次适应算法中，每次分给进程的都是刚好够进程请求的</p>
</li>
<li class="lvl-2">
<p><strong>会产生外碎片</strong>：因为随着申请的进程数越来越多，空闲块就会被拆的越来越小，直到最后无法分给任何一个进程</p>
</li>
</ul>
<h6>循环首次适应</h6>
<p>其实和首次适应算法差不多</p>
<h6>最佳适应算法</h6>
<p>也是动态分区的一种</p>
<p>一般来说，动态分区都是不会产生内碎片的，因为给进程分的，都恰好是进程所需要的</p>
<p>但由于是动态分区，则不可避免空闲块被切的越来越小，直到无法分给任何进程</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实，<em>循环首次适应、最佳适应、最坏适应</em>，都只是对首次适应算法的改进，都只是修改了适应算法，而分配空间的核心相同</p>
</p>
    </div>
</div></p>
    </div>
</div><h5 id="基于-span-style-color-red-索引搜索-span-的动态分区分配算法"><a class="header-anchor" href="#基于-span-style-color-red-索引搜索-span-的动态分区分配算法">¶</a>基于<span style="color:red">索引搜索</span>的动态分区分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>提高搜索分区的速度，在大、中型系统中采用</p>
</li>
<li class="lvl-2">
<p>快速适应算法、伙伴系统和哈希算法</p>
</li>
</ul>
<h6 id="快速适应算法"><a class="header-anchor" href="#快速适应算法">¶</a>快速适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>将空闲分区按其容量大小进行分类，具有相同容量的所有空闲分区设有一个空闲分区链表</p>
</li>
<li class="lvl-2">
<p>分配时，根据进程长度，从索引表中寻找能容纳它的最小空闲分区链表；从链表取下第一块进行分配</p>
</li>
<li class="lvl-2">
<p>特点</p>
<ul class="lvl-2">
<li class="lvl-4">优点：不分割分区，不产生碎片，查找效率高</li>
<li class="lvl-4">缺点：分区归还主存时算法复杂，系统开销较大，存在浪费</li>
</ul>
</li>
</ul>
<h6 id="伙伴系统"><a class="header-anchor" href="#伙伴系统">¶</a>伙伴系统</h6>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>固定分区方式不够灵活，当进程大小与空闲分区大小不 匹配时，内存空间利用率很低。 动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。 伙伴系统 (buddy system)是介于固定分区与可变分区之间的动态分区技术。 <strong>伙伴：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块就称为“伙伴”。</strong></p>
<blockquote>
<p>摘自<a href="https://blog.csdn.net/weixin_45951642/article/details/124431231">存储器管理_OS_快速适应算法-CSDN博客</a></p>
</p>
    </div>
</div></blockquote>
<p>伙伴算法规定，无论已分配分区或空闲分区，其<span style="color:blue">大小均为 $2$ 的 $k$ 次幂</span>，$k$ 为整数，$n &lt;= k &lt;= m$，其中：$2^n$ 表示分配的最小分区大小，$2^m$ 标识分配的最大分区的大小，通常$2^m$ 是整个可分配内存的大小。</p>
<p>在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区。</p>
<p>内存管理模块保持有多个空闲块链表，空闲块的大小可以为 2，4，8，$2^m$ 字节（$m$ 为正整数）</p>
<p>系统初起时，只有一个最大的空闲块（整个内存）。</p>
<p><u>当一个长度为$n$的进程申请内存时，系统就分给它一个大于或等于所申请尺寸的最小的2的幂次的空闲块。</u><small>(<span style="color:blue">并没有一定和进程所需内存相同；即，即使进程用不了那么多，操作系统还是会分给它</span>)</small></p>
<p><strong>伙伴系统的缺点</strong>：不能有效的利用内存。进程大小不一定是2的整数被，因此会造成浪费，内碎片严重。</p>
<p>同时也会出现外碎片，因为还是会有进程无法放入较小的分区。</p>
<h4 id="内存分配流程"><a class="header-anchor" href="#内存分配流程">¶</a><strong>内存分配流程</strong></h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152058766.png" alt="image-20241215205802867"></p>
<h4 id="内存回收"><a class="header-anchor" href="#内存回收">¶</a>内存回收</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152059078.png" alt="image-20241215205944359"></p>
<h4 id="地址转换"><a class="header-anchor" href="#地址转换">¶</a>地址转换</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152100324.png" alt="image-20241215210048568"></p>
<center><small>动态重定位示意图</small></center>
<h4 id="相关技术"><a class="header-anchor" href="#相关技术">¶</a>相关技术</h4>
<p>主存不足的存储管理技术</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存紧凑</p>
</li>
<li class="lvl-2">
<p>交换</p>
</li>
<li class="lvl-2">
<p>覆盖</p>
</li>
</ul>
<h2 id="分页存储管理"><a class="header-anchor" href="#分页存储管理">¶</a>分页存储管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152105924.png" alt="image-20241215210511208"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152105463.png" alt="image-20241215210526994"></p>
<center><small>学习目标及目标评价</small></center>
<h3 id="分页存储的基本原理"><a class="header-anchor" href="#分页存储的基本原理">¶</a>分页存储的基本原理</h3>
<p>将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB）</p>
<p>每个分区就是一个“<strong>页框</strong>”<small>或称“<strong>页帧</strong>”、“<strong>内存块</strong>”、“<strong>物理块</strong>”</small></p>
<p>每个页框有一个编号，即“<strong>页框号</strong>”<small>或者“<strong>内存块号</strong>”、“<strong>页帧号</strong>”、“<strong>物理块号</strong>”</small></p>
<p>页框号从0开始。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152110600.png" alt="页与页框"></p>
<center><small>页与页框</small></center>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
<h3 id="地址结构"><a class="header-anchor" href="#地址结构">¶</a>地址结构</h3>
<p>内存地址(<span style="color:red">逻辑地址</span>)范围（1块大小为1KB）</p>
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152114213.png" alt="image-20241215211426833" style="zoom:50%;" />
<p>内存地址结构：</p>
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152115017.png" alt="image-20241215211502226" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152116919.png" alt="image-20241215211616857" style="zoom:80%;" />
<center><small><span style="color:red"><strong>分页地址中的结构(32位)</strong></span></small></center>
<h4 id="页号P"><a class="header-anchor" href="#页号P">¶</a>页号P</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>12-31位：20位</p>
</li>
<li class="lvl-2">
<p>地址空间最多运行有1M（$2^{20}$）页</p>
</li>
</ul>
<h4 id="位移量W（页内地址）"><a class="header-anchor" href="#位移量W（页内地址）">¶</a>位移量W（页内地址）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>0-11：12位</p>
</li>
<li class="lvl-2">
<p>每页大小为4KB（$2^{12}$）</p>
</li>
</ul>
<p>对某特定机器，地址结构是一定的。</p>
<p>若给抵挡一个逻辑地址空间中的地址为A，页面的大小为L，则<span style="color:red">页号P</span>和<span style="color:red">页内地址d</span>可按下式求得</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152124296.png" alt="image-20241215212411760"></p>
<h3 id="数据结构-2"><a class="header-anchor" href="#数据结构-2">¶</a>数据结构</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><big><span style="color:blue;">进程页表</span></big>：每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序；</p>
<ul class="lvl-2">
<li class="lvl-4">逻辑页号（本进程的地址空间）-&gt; 物理页号（实际内存空间）；</li>
</ul>
</li>
<li class="lvl-2">
<p><big><span style="color:blue;">物理页面表</span></big>：整个系统有一个物理页面表，描述物理内存空间的分配使用情况</p>
<ul class="lvl-2">
<li class="lvl-4">数据结构：位示图，空闲分区链表</li>
</ul>
</li>
<li class="lvl-2">
<p><big><span style="color:blue;">请求表</span></big>：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换，也可以结合到各进程PCB里</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><big><strong>页表不属于进程的地址空间</strong></big></p>
<p>但每个进程均有一个页表，由操作系统维护。</p>
<p>页表的主要作用是将进程的虚拟地址（Virtual Address）映射到物理地址（Physical Address）。每个进程都有独立的虚拟地址空间，而页表是管理这种虚拟地址空间的关键数据结构。</p>
<p>页表本身存储在内存中，由操作系统维护。它记录了虚拟页面与物理页面之间的映射关系，例如页面是否在内存中、页面权限等。</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152125190.png" alt="image-20241215212545948"></p>
<center><small>页表结构</small></center>
<h3 id="内存有效访问时间EAT"><a class="header-anchor" href="#内存有效访问时间EAT">¶</a>内存有效访问时间EAT</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202139618.png" alt="image-20241220213940979"></p>
<p><img src="./assets/1156ee8355ca107182c5e49788ac3c3.jpg" alt="1156ee8355ca107182c5e49788ac3c3"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>当快表未命中时，根据程序的局部性原理，下一次再次访问的概率会很大，所以需要将缺失的信息写入到块表中，以便下次查询时可以命中。</p>
</p>
    </div>
</div><h3 id="相关技术-2"><a class="header-anchor" href="#相关技术-2">¶</a>相关技术</h3>
<h4 id="两级或多级页表"><a class="header-anchor" href="#两级或多级页表">¶</a>两级或多级页表</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202217960.png" alt="image-20241220221715989"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202217488.png" alt="image-20241220221737815"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202238250.png" alt="image-20241220223823781"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>对于该题，通过逻辑地址空间和页大小可以得出</p>
<blockquote>
<p>逻辑地址结构即寻址到一个位</p>
</p>
    </div>
</div><p>逻辑地址共$10 + 16 = 26$位，</p>
<p>则，寻址到一个位需要：$26$位，即逻辑地址长度为$26$</p>
<p>而通过页表项大小和页大小可以算出一个页表可以存下$2^9$个页表，即逻辑地址结构中页号长度为$9$位</p>
<p>页内偏移量长度即页大小$10$位</p>
<p>所以可以推出现在已经用了$10 + 9 = 19$位</p>
<p>则剩下$7$位</p>
<p>全为页目录号长度</p>
<p>则，页目录号包含表项的个数至少为$2^7$</p>
<blockquote>
<p>页目录表，指的是一级页表。</p>
<p>包含表项，指的一级页表中的一项。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第六章复习</title>
    <url>/posts/b90b7ae5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一下操作系统第六章复习笔记吧</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="虚拟存储器的概念"><a class="header-anchor" href="#虚拟存储器的概念">¶</a>虚拟存储器的概念</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>局部性原理</p>
</li>
<li class="lvl-2">
<p>虚拟存储器的概念</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>局部性的特征体现</p>
</li>
<li class="lvl-3">
<p>理解虚拟存储器</p>
</li>
<li class="lvl-3">
<p>虚拟存储器的容量</p>
</li>
</ol>
<h3 id="虚拟存储器的任务"><a class="header-anchor" href="#虚拟存储器的任务">¶</a>虚拟存储器的任务</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>逻辑上扩充内存容量</p>
</li>
</ul>
<h3 id="局部性原理"><a class="header-anchor" href="#局部性原理">¶</a>局部性原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间局部性：</p>
<p>一条指令被执行了，则在不久的将来它可能再被执行。</p>
</li>
<li class="lvl-2">
<p>空间局部性：</p>
<p>若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。</p>
</li>
</ul>
<blockquote>
<p>只需要让程序当前需要运行的内容存在于内存中，程序就能跑</p>
</blockquote>
<h3 id="虚拟存储器的定义"><a class="header-anchor" href="#虚拟存储器的定义">¶</a>虚拟存储器的定义</h3>
<p>具有请求调入功能<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="调入功能 是 指将进程所需的数据或指令从磁盘调入主存">[1]</span></a></sup>和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<p><big>虚拟存储器的容量 = $min($ 内存 $+$ 外存 $,$ <code>cpu</code>寻址空间 $)$ </big></p>
<h3 id="虚拟存储器的特征"><a class="header-anchor" href="#虚拟存储器的特征">¶</a>虚拟存储器的特征</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>多次性</p>
</li>
<li class="lvl-2">
<p>对换性</p>
</li>
<li class="lvl-2">
<p>虚拟性</p>
</li>
</ul>
<h3 id="虚拟存储器的实现"><a class="header-anchor" href="#虚拟存储器的实现">¶</a>虚拟存储器的实现</h3>
<h4 id="请求分页系统"><a class="header-anchor" href="#请求分页系统">¶</a>请求分页系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：页表、缺页中断、地址变换机构</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调页软件、页面置换软件</p>
</li>
</ul>
<h4 id="请求分段系统"><a class="header-anchor" href="#请求分段系统">¶</a>请求分段系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：段表、缺段中断、地址变换机构。</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调段软件、段置换软件。</p>
</li>
</ul>
<h4 id="段页式虚拟存储器"><a class="header-anchor" href="#段页式虚拟存储器">¶</a>段页式虚拟存储器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>增加请求调页和页面置换。</p>
</li>
</ul>
<h2 id="请求分页存储管理"><a class="header-anchor" href="#请求分页存储管理">¶</a>请求分页存储管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101903431.png" alt="image-20241210190318202"></p>
<h3 id="目标评价"><a class="header-anchor" href="#目标评价">¶</a>目标评价</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0"><label for="checkbox0">请求分页中的页表需要如何修改？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1"><label for="checkbox1">缺页中断有何特点？缺页中断如何处理？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2"><label for="checkbox2">请求分页管理中地址转换如何完成？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3"><label for="checkbox3">页面置换算法有哪些？如何完成页面置换？有何特点？缺页率如何计算？</label></p>
</li>
</ul>
<h3 id="硬件支持"><a class="header-anchor" href="#硬件支持">¶</a>硬件支持</h3>
<h4 id="页表机制"><a class="header-anchor" href="#页表机制">¶</a>页表机制</h4>
<p>需要在进程页表<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="进程页表 是操作系统管理虚拟存储器时，用于映射进程的 **虚拟地址**和 **物理地址** 的一个重要数据结构。&lt;br&gt;每个进程都有自己的 **页表** ，它记录了该进程所有虚拟页的相关信息，&lt;br&gt;包括虚拟页是否已被加载到主存以及其对应的物理页框地址。">[2]</span></a></sup>中添加若干项</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态位P：指示该页是否在内存</p>
</li>
<li class="lvl-2">
<p>访问字段A：记录该页在一段时间内被访问的次数</p>
</li>
<li class="lvl-2">
<p>修改位M：也称脏位，标志该页是否被修改过</p>
</li>
<li class="lvl-2">
<p>外存地址：指示该页在外存中的地址（物理块号）</p>
</li>
</ul>
<h4 id="缺页中断机构"><a class="header-anchor" href="#缺页中断机构">¶</a>缺页中断机构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>在指令执行期间产生和处理中断信号</p>
</li>
<li class="lvl-2">
<p>一条指令在执行期间，可能产生多次缺页中断</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于 <em><a href="/posts/52e033e8"><code>一条指令在执行期间，可能产生多次缺页中断</code></a></em></h4>
<h4>指令本身产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>指令取指</strong></p>
<p><code>cpu</code>在只从一条指令时，需要从主存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<h4>操作数访问导致的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>直接操作数</strong></p>
<p>如果指令是使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断</p>
</li>
<li class="lvl-2">
<p><strong>间接访问</strong></p>
<p>指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断</p>
</li>
</ul>
<h4>指令操作多次访问内存</h4>
<p>一些复杂的指令（尤其在<a href="/posts/7436c65f">CISC架构</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="**CISC（Complex Instruction Set Computer）** 架构是一种处理器设计理念，其特点是提供 **复杂且多样化的指令集**">[3]</span></a></sup>中）可能在执行期间涉及多个内存访问，每次访问可能触发缺页中断。例如：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<h4>页表访问产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<h4>内存管理器的间接操作</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="缺页中断的特殊性"><a class="header-anchor" href="#缺页中断的特殊性">¶</a>缺页中断的特殊性</h4>
<p>缺页中断在指令执行期间产生和进行处理，而不是在一条指令执行完毕之后。所缺的页面调入之后，重新执行被中断的指令</p>
<h4 id="地址变换机构"><a class="header-anchor" href="#地址变换机构">¶</a>地址变换机构</h4>
<p>与分页内存管理方式类似</p>
<p>由逻辑地址检索页表，根据对应页表项的标志位判断，若在内存中，则直接形成物理地址。</p>
<p>如不在内存中，产生缺页中断，从对应页表项的外存地址，从外存找到该页，内存满，则选择页面换出，否则从外存直接调入内存。完成地址转换。<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412102029580.png" alt="image-20241210202946621"></p>
<h4 id="内存分配"><a class="header-anchor" href="#内存分配">¶</a>内存分配</h4>
<h5 id="最小物理块数的确定"><a class="header-anchor" href="#最小物理块数的确定">¶</a>最小物理块数的确定</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>保证进程正常运行所需的最小物理块数</p>
</li>
</ul>
<h5 id="物理块的分配策略"><a class="header-anchor" href="#物理块的分配策略">¶</a>物理块的分配策略</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配，局部置换</p>
</li>
<li class="lvl-2">
<p>可变分配，全局置换</p>
</li>
<li class="lvl-2">
<p>可变分配，局部置换</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/907f4c43">物理块的分配策略</a></p>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><h5 id="物理块分配算法"><a class="header-anchor" href="#物理块分配算法">¶</a>物理块分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>平均分配算法</p>
</li>
<li class="lvl-2">
<p><span style="color: red">按比例分配算法</span></p>
</li>
<li class="lvl-2">
<p>考虑优先权的分配算法</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/8ba68849">物理块分配算法</a></p>
<p><strong>对比总结</strong></p>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><h4 id="调页策略-small-又称-调页技术-small-详解-small-small"><a class="header-anchor" href="#调页策略-small-又称-调页技术-small-详解-small-small">¶</a>调页策略<small>又称  调页技术<small><a href="/posts/f830ee25">详解</a></small></small></h4>
<h5 id="何时调入页面"><a class="header-anchor" href="#何时调入页面">¶</a>何时调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>预调页策略：预先调入一些页面到内存</p>
</li>
<li class="lvl-2">
<p>请求调页策略：发现需要访问的页面不在内存时，调入内存</p>
</li>
</ul>
<h5 id="从何处调入页面"><a class="header-anchor" href="#从何处调入页面">¶</a>从何处调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>如系统拥有足够的对换区空间，全部从对换区调入所需页面</p>
</li>
<li class="lvl-2">
<p>如系统缺少足够的对换区空间，凡是不会被修改的文件，都直接从文件区调入</p>
<p>当换出这些页面时，由于未被修改而不必再将它们重写磁盘，以后再调入时，仍从文件区直接调入</p>
</li>
<li class="lvl-2">
<p>UNIX方式：未运行过的页面，从文件区调入；曾经运行过但又被换出的页面，从对换区调入</p>
</li>
</ul>
<h5 id="span-style-color-red-如何调入页面-span"><a class="header-anchor" href="#span-style-color-red-如何调入页面-span">¶</a><span style="color:red">如何调入页面</span></h5>
<ol>
<li class="lvl-3">
<p>查找所需页在磁盘上的位置</p>
</li>
<li class="lvl-3">
<p>查找一内存空闲块：</p>
<ul class="lvl-2">
<li class="lvl-5">如果有空闲块，就直接使用它</li>
<li class="lvl-5">如果没有空闲块，使用页面置换算法选择一个&quot;牺牲&quot;内存块</li>
<li class="lvl-5">将“牺牲”块的内容写到磁盘上，更新页表和物理块表</li>
</ul>
</li>
<li class="lvl-3">
<p>将所需页读入新空闲块，更新页表</p>
</li>
<li class="lvl-3">
<p>重启用户进程</p>
</li>
</ol>
<h5 id="缺页率"><a class="header-anchor" href="#缺页率">¶</a>缺页率</h5>
<p>缺页率的计算：<br>
$$<br>
f= F/A<br>
$$</p>
<center><small>s为访问页面成功<small>(在内存中)</small>次数</small></center>
<center><small>F为访问页面失败<small>(不在内存)</small>次数</small></center>
<center><small>A为总访问次数 A = s+F</small></center>
<ul class="lvl-0">
<li class="lvl-2">
<p>影响因素：页面大小、分配内存块的数目、页面置换算法、程序固有属性</p>
</li>
</ul>
<p>缺页中断处理的时间：</p>
<p>$$<br>
t = β×t_a + (1- β)×t_b<br>
$$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>例子</h5>
<p>存取内存的时间= 200 nanoseconds (ns)</p>
<p>平均缺页处理时间 = 8 milliseconds (ms)</p>
<p><em>t</em> = (1 – p) × 200ns + p × 8ms</p>
<p>= (1 – p) × 200ns + p ×8,000,000ns</p>
<p>= 200ns + p × 7,999,800ns</p>
<p>如果每1,000次访问中有一个缺页中断，那么：</p>
<p><em>t</em> = 8.2 ms</p>
<p><strong>这是导致计算机速度放慢</strong> <strong>40</strong> <strong>倍的影响因子！</strong></p>
</p>
    </div>
</div><h4 id="页面置换算法"><a class="header-anchor" href="#页面置换算法">¶</a>页面置换算法</h4>
<p><strong>功能</strong>：需要调入页面时，选择内存中年哪个物理页面被置换。称为replacement policy<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="policy：/ˈpɒləsi/ n.  策略；方针；">[4]</span></a></sup></p>
<p><small><strong>目标</strong>：把未来不再使用的或短期内较少使用的页面调出，通常只能在局部性原理指导下依据过去的统计数据进行预测；</small></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>算法一览</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>最佳算法(<strong>OPT</strong>, optimal)</p>
</li>
<li class="lvl-2">
<p>先进先出算法(<strong>FIFO</strong>)</p>
</li>
<li class="lvl-2">
<p>最近最久未使用算法(<strong>LRU</strong>, Least Recently Used)</p>
</li>
<li class="lvl-2">
<p>轮转算法(clock)</p>
</li>
<li class="lvl-2">
<p>最不常用算法(<strong>LFU</strong>, Least Frequently Used)</p>
</li>
<li class="lvl-2">
<p>页面缓冲算法(page buffering)</p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最佳置换算法-OPT"><a class="header-anchor" href="#最佳置换算法-OPT">¶</a>最佳置换算法 OPT</h5>
<p>被置换的页将是之后最长时间不被使用的页</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111512688.png" alt="image-20241211151237943"></p>
<p>无法实现的算法，可用来评价其他算法</p>
<h5 id="先进先出置换算法"><a class="header-anchor" href="#先进先出置换算法">¶</a>先进先出置换算法</h5>
<p><span style="color:red">总是淘汰最先进入内存的页面</span>，即选择在内存中驻留时间最久的页面予以淘汰</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111515908.png" alt="image-20241211151558420"></p>
<p>性能较差。较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。并且有Belady现象。</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="贝拉迪  贝拉迪异常（Belady&#039;s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误">[5]</span></a></sup> 现象</h4>
<p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。</p>
<h4>Belady现象的描述</h4>
<p>一个进程P要访问M个页，OS分配N个内存页面给进程P；对一个访问序列S，发生缺页次数为PE（S,N）。当N增大时，PE(S, N)时而增大，时而减小。</p>
<h4>Belady现象的原因</h4>
<p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的。</p>
<blockquote>
<p>反而，先加载进去的页面可能是访问次数最多的，如c语言中，定义的函数往往放在<code>main</code>函数<small>程序入口之前</small>，而且当函数调用另一个函数时，被调用的函数必须放在当前函数之前。</p>
</p>
    </div>
</div></blockquote>

<div class="callout callout-info">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">INFO</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady现象的例子</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>进程P有5页程序访问页的顺序为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5；</p>
</li>
<li class="lvl-2">
<p>如果在内存中分配3个页面，则缺页情况如下：12次访问中有缺页9次；</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111539081.png" alt="image-20241211153920646"></p>
</li>
<li class="lvl-2">
<p>如果在内存中分配4个页面，则缺页情况如下：12次访问中有缺页10次</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111540590.png" alt="image-20241211154006562"></p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最近最久未使用-LRU"><a class="header-anchor" href="#最近最久未使用-LRU">¶</a>最近最久未使用 LRU</h5>
<p>选择内存中<span style="color:blue;">最久未使用的页面</span>被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111631081.png" alt="image-20241211163148299"></p>
<h6 id="硬件支持-2"><a class="header-anchor" href="#硬件支持-2">¶</a>硬件支持</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>寄存器</p>
<p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个<a href="/posts/3d2c198d">移位寄存器</a><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="**移位寄存器**（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。">[6]</span></a></sup>，可表示为<br>
$$<br>
R=R_{n-1}R_{n-2}R_{n-3}…R_2R_1R_0<br>
$$</p>
<p><strong>某进程具有</strong> <strong>8</strong> <strong>个页面时的</strong> <strong>LRU</strong> <strong>访问情况</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111652427.png" alt="image-20241211165224336"></p>
</li>
<li class="lvl-2">
<p>栈</p>
<p>用栈保存时，栈的变换情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111656423.png" alt="image-20241211165630180"></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现<small><a href="/posts/f041ded5">详细实现过程</a></small></h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><h5 id="Clock置换算法"><a class="header-anchor" href="#Clock置换算法">¶</a>Clock置换算法</h5>
<p>LRU的近似算法，又称最近未用(NRU)或二次机会页面置换算法</p>
<h6 id="简单的Clock算法"><a class="header-anchor" href="#简单的Clock算法">¶</a>简单的Clock算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页都与一个访问位相关联，初始值为0</p>
</li>
<li class="lvl-2">
<p>当页被访问时置访问位为1</p>
</li>
<li class="lvl-2">
<p>置换时选择访问位为0的页 ；若为1，重新置为0</p>
</li>
</ul>
<p><left><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111709272.png" alt="image-20241211170935261" style="zoom:45%;" /></left><br>
<right><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111714913.png" alt="image-20241211171426161" style="zoom:45%;" /></right></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>像是时钟一样，在需要进行页表置换时，转着圈访问上图所示的访问位</p>
<p><small>若顺时针</small></p>
<p>当转到每一个访问位时，如果当前转到的访问位的值为1，则将该访问位置为0，然后接着访问下一个访问位</p>
<p>直到遇到第一个为0的访问位，则将该访问位对应的页表换出。</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>概述：当使用<code>clock</code>算法换入缺失的页面后，指针会指向当前换入页的后一个页。</p>
<h4>细节辨析</h4>
<p>当算法已经选择好了一个页面并将其换出的细节过程</p>
<p>比如替换前的序列</p>
<p>$[\overset{\downarrow}{1_1}, 2_1, 3_1]$</p>
<p>现在需要调入页面$4$在使用<code>clock</code>算法计算后：</p>
<p>$[\overset{\downarrow}{1_0}, 2_0, 3_0]$</p>
<p>此时页面$1$被选择，然后替换</p>
<p>$[\overset{\downarrow}{4_1}, 2_1, 3_1]$</p>
<p>然后指针指向刚换入页面的<strong>后一个页面</strong></p>
<p>$[{1_1}, \overset{\downarrow}{2_1}, 3_1]$</p>
<p>然后才完成一次完整的$clock$</p>
</p>
    </div>
</div><h6 id="改进Clock置换算法"><a class="header-anchor" href="#改进Clock置换算法">¶</a>改进Clock置换算法</h6>
<p>除须考虑页面的使用情况外，还须增加置换代价</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>考虑置换代价，即考虑当前页表是否被修改</p>
<p>因为被修改的页表，需要写入磁盘更加耗时</p>
<p><small>没有被修改的页表，在换出后直接丢掉就好了</small></p>
</p>
    </div>
</div><p>即，淘汰时，同时检查访问位A与修改位M</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第1类（A=0，M=0）：表示该页最近既未被访问、又未被修改，是最佳淘汰页。</p>
</li>
<li class="lvl-2">
<p>第2类（A=0，M=1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。</p>
</li>
<li class="lvl-2">
<p>第3类（A=1，M=0）：表示该页最近已被访问，但未被修改，该页有可能再被访问。</p>
</li>
<li class="lvl-2">
<p>第4类（A=1，M=1）：表示该页最近已被访问且被修改，该页有可能再被访问。</p>
</li>
</ul>
<p>置换时，循环依次查找第1类、第2类页面，找到为止。</p>
<h5 id="最少使用置换算法-LFU-small-详细解释-small"><a class="header-anchor" href="#最少使用置换算法-LFU-small-详细解释-small">¶</a>最少使用置换算法 LFU<small><a href="/posts/78bb016d">详细解释</a></small></h5>
<p>为内存中的每个页面设置一个移位寄存器，用来记录该页面的被访问频率</p>
<p>LFU 选择在<span style="color:red">最近时期使用最少的额页面内</span>作为淘汰页</p>
<h5 id="页面缓冲算法-PBA"><a class="header-anchor" href="#页面缓冲算法-PBA">¶</a>页面缓冲算法 PBA</h5>
<p>是对 FIFO<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="先进先出算法">[7]</span></a></sup> 算法的发展，通过被置换页面的缓冲，有机会找回刚被置换的页面</p>
<h6 id="被置换页面的选择和处理："><a class="header-anchor" href="#被置换页面的选择和处理：">¶</a><strong>被置换页面的选择和处理</strong>：</h6>
<p>用 FIFO 算法选择被置换页，把被置换的页面放入两个链表之一</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果页面未被修改，就将其归入到空闲页面链表的末尾</p>
</li>
<li class="lvl-2">
<p>否则将其归入到已修改页面链表。</p>
</li>
</ul>
<h6 id="处理过程"><a class="header-anchor" href="#处理过程">¶</a>处理过程</h6>
<p>需要调入新的物理页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除。</p>
<p>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面再次被访问，只需要较小的开销就可以将被访问的页面返还，重新作为进程的内容页。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实，空闲页面链表和已修改页面链表就像两个缓冲区，等过了缓冲时间任未访问的页面就真的扔了。</p>
</p>
    </div>
</div><p>当已修改页面达到一定次数后，在将它们一起调出到外存，然后将他们归入空闲页面链表，这样能大大减少I/O操作次数<small>也相当于是一个缓冲区吧，页表I/O缓冲区，因为I/O操作比较慢</small></p>
<h4 id="访问内存的有效时间"><a class="header-anchor" href="#访问内存的有效时间">¶</a>访问内存的有效时间</h4>
<p>系统中有快表，</p>
<center><small>快表时间λ，</small></center>
<center><small>页表时间t，</small></center>
<center><small>缺页处理时间ε，</small></center>
<center><small>快表命中率a，</small></center>
<center><small>缺页率f</small></center>
<p>具有快表的请求分页管理方式的内存访问操作：</p>
<p>（1）被访问页在内存中，对应页表项在快表中</p>
<p>​    EAT=λ+t</p>
<p>（2）被访问页在内存中，对应页表项不在快表中</p>
<p>​    EAT=λ+t+λ+t=2×（λ+t）</p>
<p>（3）被访问页不在内存中</p>
<p>​    EAT= λ+t+ε+λ+t=2×（λ+t）+ε</p>
<p>（4）快表命中率为a，缺页率为f，缺页中断处理时间为ε</p>
<p>EAT= λ+a×t+(1-a)×((1-f)×(λ+t)+f×(t+ε+ λ)+t)</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412122117572.png" alt="image-20241212211714003"></p>
<center><small>耗费时间计算</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>cache</code>是用来加速<code>cpu</code>访问主存，如果<code>cache</code>中有数据，<code>cpu</code>就可以直接拿</p>
<p>快表是用来加速地址转换的</p>
<blockquote>
<p><a href="/posts/c38ea43e">在地址转换过程中会访问两次页表嘛？</a></p>
</p>
    </div>
</div></blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>勘误</h4>
<p><span style="color:red"><big>严格按照上图中的过程计算</big></span></p>
<p><big><strong>声明</strong></big></p>
<p><img src="./assets/image-20241223171247181.png" alt="image-20241223171247181"></p>
<center><small>完整虚存处理图</small></center>
<p>完整过程描述：</p>
<p>一个有快表的系统，同时系统中不存在Cache</p>
<ol>
<li class="lvl-3">
<p>首先是快表命中的情况</p>
<ol>
<li class="lvl-6">查询快表，进行地址转换（<strong>访问快表</strong>）</li>
<li class="lvl-6">访问对应的页（<strong>访问内存</strong>）</li>
</ol>
</li>
<li class="lvl-3">
<p>然后是快表未命中的情况</p>
<ol>
<li class="lvl-6">查询快表，发现没有命中（<strong>访问快表</strong>）</li>
<li class="lvl-6">查询内存中的页表（<strong>访问内存</strong>）</li>
<li class="lvl-6">访问对应的页，在该处又会产生两种情况
<ol>
<li class="lvl-9">没有发生缺页，访问对应的页（<strong>访问内存</strong>）</li>
<li class="lvl-9">发生缺页
<ol>
<li class="lvl-12">先执行缺页处理（<strong>缺页处理</strong>）</li>
<li class="lvl-12">在访问对应的页（<strong>访问内存</strong>）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</p>
    </div>
</div><h4 id="抖动与工作集"><a class="header-anchor" href="#抖动与工作集">¶</a>抖动与工作集</h4>
<h5 id="抖动-颠簸-Thrashing"><a class="header-anchor" href="#抖动-颠簸-Thrashing">¶</a>抖动/颠簸(Thrashing)</h5>
<p>页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象为颠簸。</p>
<h6 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统中运行的进程太多</p>
</li>
<li class="lvl-2">
<p>页面淘汰算法不合理</p>
</li>
<li class="lvl-2">
<p>分配给进程的物理页面数太少</p>
</li>
</ul>
<h5 id="常驻集"><a class="header-anchor" href="#常驻集">¶</a>常驻集</h5>
<p>常驻集指虚拟页式管理中给进程分配的物理页面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412112032913.png" alt="image-20241211201956645"></p>
<center><small>缺页率和物理块数（常驻集）之间的关系图</small></center>
<h5 id="工作集"><a class="header-anchor" href="#工作集">¶</a>工作集</h5>
<blockquote>
<p>1968年由Denning提出，目的是依据进程在过去的一段时间内访问的页面来调整常驻集大小。</p>
</blockquote>
<p>所谓工作集，指在某段时间间隔Δ里进程实际要访问页面的集合。</p>
<p>把某进程在时间t的工作集记为w(t，Δ),其中的变量Δ称为工作集的“窗口尺寸”</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$\Delta$是一个虚拟时间段，称为窗口大小(window size)，它采用&quot;虚拟时间&quot;单位(阻塞时不计时)，大致可以用执行的指令数目，或处理器执行时间来计算；</p>
</li>
<li class="lvl-2">
<p>工作集是在[t - $\Delta$, t]时间段内所访问的页面的集合；</p>
</li>
<li class="lvl-2">
<p>| W(t, $\Delta$) | 指工作集大小即页面数目；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412112032473.png" alt="image-20241211202426933"></p>
<h6 id="抖动的预防方法"><a class="header-anchor" href="#抖动的预防方法">¶</a>抖动的预防方法</h6>
<ol>
<li class="lvl-3">
<p>采取局部置换策略：只能在分配给自己的内存空间内进行置换；</p>
</li>
<li class="lvl-3">
<p>把工作集算法融入到处理机调度中，让常驻集包含工作集；</p>
</li>
<li class="lvl-3">
<p>利用“L=S”准则调节缺页率：</p>
 <center><small>L是缺页之间的平均时间</small></center>
 <center><small>S是平均缺页服务时间，即用于置换一个页面的时间</small></center>
<ul class="lvl-2">
<li class="lvl-6">
<p>L&gt;S，说明很少发生缺页</p>
</li>
<li class="lvl-6">
<p>L&lt;S，说明频繁缺页</p>
</li>
<li class="lvl-6">
<p>L=S，磁盘和处理机都可达到最大利用率</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>选择暂停进程。</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">调入功能 是 指将进程所需的数据或指令从磁盘调入主存<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">进程页表 是操作系统管理虚拟存储器时，用于映射进程的 <strong>虚拟地址</strong>和 <strong>物理地址</strong> 的一个重要数据结构。<br>每个进程都有自己的 <strong>页表</strong> ，它记录了该进程所有虚拟页的相关信息，<br>包括虚拟页是否已被加载到主存以及其对应的物理页框地址。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3" class="footnote-item"><span class="footnote-content"><strong>CISC（Complex Instruction Set Computer）</strong> 架构是一种处理器设计理念，其特点是提供 <strong>复杂且多样化的指令集</strong><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4" class="footnote-item"><span class="footnote-content">policy：/ˈpɒləsi/ n.  策略；方针；<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5" class="footnote-item"><span class="footnote-content">贝拉迪  贝拉迪异常（Belady's anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6" class="footnote-item"><span class="footnote-content"><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7" class="footnote-item"><span class="footnote-content">先进先出算法<a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘空间管理</title>
    <url>/posts/292fbdbc.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="外存组织方式"><a class="header-anchor" href="#外存组织方式">¶</a>外存组织方式</h2>
<h3 id="外存组织方式-2"><a class="header-anchor" href="#外存组织方式-2">¶</a>外存组织方式</h3>
<h4 id="显式链接——FAT"><a class="header-anchor" href="#显式链接——FAT">¶</a>显式链接——FAT</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>FAT：文件分配表</p>
</li>
<li class="lvl-2">
<p>将一个文件离散的存储在外存上，将链接个物理块的指针显式的登记在一张文件分配表FAT中，FAT整个系统一张，每个表项序号为对应物理块号，表项内容为文件下一物理块的指针</p>
</li>
<li class="lvl-2">
<p>文件首个物理块地址被登记在文件目录中</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231014179.png" alt="image-20241223101435502"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231020236.png" alt="image-20241223102005862"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>关于FAT表项的位数，与文件总数紧密相连，要能表示所有文件的存储地址</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>FAT技术——相关计算1</h4>
<p>磁盘块（扇区）大小，FAT表项大小，簇的大小——磁盘容量</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>FAT12：FAT表项12位，簇大小为1，2，4，8个扇区</p>
</li>
<li class="lvl-2">
<p>FAT16：FAT表项16为，簇大小为4，8，…，64个扇区</p>
</li>
<li class="lvl-2">
<p>FAT32：FAT表项32位，簇大小的8个扇区</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="混合索引"><a class="header-anchor" href="#混合索引">¶</a>混合索引</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231025668.png" alt="image-20241223102511222"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在Unix文件管理中，文件控制块中的文件索引一个有13项</p>
<p>即，从0~12，共13项</p>
<p>而，0~9是正常的直接链接</p>
<p>即，0~9的所有直接指向文件</p>
<p>而，10~12，则是分级索引</p>
<p>其中，10，是一级索引，即用索引方式存放文件结构</p>
<p>11，是二级索引</p>
<p>12，是三级索引</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231029973.png" alt="image-20241223102921220"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231030086.png" alt="image-20241223103024215"></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>第2章-进程的描述与控制</title>
    <url>/posts/b9cdc318.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="进程的基本状态"><a class="header-anchor" href="#进程的基本状态">¶</a>进程的基本状态</h2>
<ol>
<li class="lvl-3">
<p>执行</p>
</li>
<li class="lvl-3">
<p>就绪</p>
</li>
<li class="lvl-3">
<p>阻塞</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412192035462.png" alt="image-20241219203552806"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>绝对不会出现，CPU空闲而还有进程就绪的情况</p>
<p>cpu一定会从就绪队列中取下一个进程运行</p>
</p>
    </div>
</div><h3 id="进程的五种基本状态"><a class="header-anchor" href="#进程的五种基本状态">¶</a>进程的五种基本状态</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建状态  -&gt;  即进程在申请PCB的阶段</p>
</li>
<li class="lvl-2">
<p>终止状态  -&gt;  进程已经完全运行完，等待OS善后，并回收PCB<small>也称将死状态</small></p>
</li>
</ul>
<h3 id="进程的7种基本状态"><a class="header-anchor" href="#进程的7种基本状态">¶</a>进程的7种基本状态</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>挂起状态</p>
</li>
</ul>
<p>即在状态转换种加入了人的参与，由用户操作将进程挂起</p>
<p>由，就绪和阻塞拓展出了两种新状态，</p>
<p><big>即，静态就绪和静态阻塞</big></p>
<p>用户执行挂起操作时就会将进程转换为这两种状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412192045886.png" alt="image-20241219204500153"></p>
<h2 id="进程控制块"><a class="header-anchor" href="#进程控制块">¶</a>进程控制块</h2>
<p>PCB是进程的一部分，是操作系统中最重要的<span style="color:red">记录型数据结构</span>，是进程存在的唯一标志，<strong>常驻内存</strong></p>
<h3 id="PCB的作用"><a class="header-anchor" href="#PCB的作用">¶</a>PCB的作用</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>作为独立运行基本单位的标志</p>
</li>
<li class="lvl-2">
<p>能实现间断性的运行方式</p>
</li>
<li class="lvl-2">
<p>提供进程管理所需要的信息</p>
</li>
<li class="lvl-2">
<p>提供基础调度所需要的信息</p>
</li>
<li class="lvl-2">
<p>实现与其他进程的同步与通信</p>
</li>
</ul>
<h3 id="PCB的信息——处理机状态信息"><a class="header-anchor" href="#PCB的信息——处理机状态信息">¶</a>PCB的信息——处理机状态信息</h3>
<p>处理机状态信息主要是由处理机各种寄存器的内容所组成</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>通用寄存器</strong></p>
</li>
<li class="lvl-2">
<p><strong>指令寄存器</strong>：存放要访问的下一条指令</p>
</li>
<li class="lvl-2">
<p><strong>程序状态字PSW</strong>：条件码，执行方式，中断屏蔽标志</p>
</li>
<li class="lvl-2">
<p><strong>用户栈指针</strong>：每个用户进程有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址</p>
</li>
</ul>
<h3 id="PCB的信息——进程控制信息"><a class="header-anchor" href="#PCB的信息——进程控制信息">¶</a>PCB的信息——进程控制信息</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>程序和数据的地址</strong></p>
</li>
<li class="lvl-2">
<p><strong>进程同步和通信机制</strong></p>
</li>
<li class="lvl-2">
<p><strong>资源清单</strong></p>
</li>
<li class="lvl-2">
<p><strong>链接指针</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100011.png" alt="image-20241220084923485">、</p>
<center><small>进程切换时的过程</small></center>
<h3 id="PCB表"><a class="header-anchor" href="#PCB表">¶</a>PCB表</h3>
<p>系统把所有的PCB组织在一起，并把他们放在内存的固定区域，就构成了PCB表。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>PCB表的大小决定了系统中最多可同时存在的进程格式，称为<span style="color:blue">系统的并发度</span></p>
</p>
    </div>
</div><h3 id="PCB表的组织方式"><a class="header-anchor" href="#PCB表的组织方式">¶</a>PCB表的组织方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>线性方式</p>
</li>
<li class="lvl-2">
<p>链接方式</p>
</li>
<li class="lvl-2">
<p>索引方式</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100870.png" alt="image-20241220085403229"></p>
<center><small>线性组织方式</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100638.png" alt="image-20241220085453303"></p>
<center><small>链接组织方式</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100550.png" alt="image-20241220085625834"></p>
<center><small>索引组织方式</small></center>
<h2 id="进程控制"><a class="header-anchor" href="#进程控制">¶</a>进程控制</h2>
<h3 id="原语"><a class="header-anchor" href="#原语">¶</a>原语</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>原语</p>
<p>由若干条指令组成，用于完成一定功能的一个过程。</p>
</li>
<li class="lvl-2">
<p>进程管理最基本的功能：由OS内核中的原语实现</p>
</li>
</ul>
<h3 id="进程创建"><a class="header-anchor" href="#进程创建">¶</a>进程创建</h3>
<p>进程具有层次结构</p>
<blockquote>
<p>有些进程会由于自身业务的需要，去主动创建子进程去处理业务</p>
<p>此时，就出现了层级关系，即父子进程</p>
</blockquote>
<h4 id="进程创建过程"><a class="header-anchor" href="#进程创建过程">¶</a>进程创建过程</h4>
<ol>
<li class="lvl-3">
<p>申请空白PCB</p>
</li>
<li class="lvl-3">
<p>分配所需要资源</p>
</li>
<li class="lvl-3">
<p>初始化PCB</p>
</li>
<li class="lvl-3">
<p>插入就绪队列</p>
</li>
</ol>
<h3 id="进程终止"><a class="header-anchor" href="#进程终止">¶</a>进程终止</h3>
<h4 id="引起进程终止的事件"><a class="header-anchor" href="#引起进程终止的事件">¶</a>引起进程终止的事件</h4>
<p>正常结束</p>
<p>异常结束</p>
<p>外界干预</p>
<h4 id="进程终止过程"><a class="header-anchor" href="#进程终止过程">¶</a>进程终止过程</h4>
<p>找进程的PCB，读取进程状态</p>
<p>终止进程，并设置调度标志</p>
<p>终止所有子进程</p>
<p>回收进程所拥有的全部资源</p>
<p>回收PCB，生命周期结束</p>
<h3 id="进程的阻塞与唤醒"><a class="header-anchor" href="#进程的阻塞与唤醒">¶</a>进程的阻塞与唤醒</h3>
<h4 id="引起进程阻塞的事件"><a class="header-anchor" href="#引起进程阻塞的事件">¶</a>引起进程阻塞的事件</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201103603.png" alt="image-20241220090934888"></p>
<h4 id="进程阻塞过程"><a class="header-anchor" href="#进程阻塞过程">¶</a>进程阻塞过程</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>停止执行</p>
</li>
<li class="lvl-2">
<p>状态由执行改为阻塞</p>
</li>
<li class="lvl-2">
<p>将PCB插入阻塞队列</p>
</li>
</ul>
<h4 id="唤醒过程"><a class="header-anchor" href="#唤醒过程">¶</a>唤醒过程</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>从阻塞队列中移出</p>
</li>
<li class="lvl-2">
<p>状态由阻塞改为就绪</p>
</li>
<li class="lvl-2">
<p>将PCB插入就绪队列</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>进程的阻塞与唤醒一般成对出现</p>
</p>
    </div>
</div><h3 id="Unix进程控制实现"><a class="header-anchor" href="#Unix进程控制实现">¶</a>Unix进程控制实现</h3>
<h4 id="创建——fork"><a class="header-anchor" href="#创建——fork">¶</a>创建——<code>fork()</code></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>为子进程分配进程表</p>
</li>
<li class="lvl-2">
<p>为子进程分配进程标识符</p>
</li>
<li class="lvl-2">
<p>复制进程的进程映像，但不复制共享内存区</p>
</li>
<li class="lvl-2">
<p>增加父进程所打开文件的计数，表示新进程也在使用这些文件</p>
</li>
<li class="lvl-2">
<p>把子进程置为“就绪”</p>
</li>
<li class="lvl-2">
<p><big><span style="color:red"><strong>返回子进程标识符给父进程，把0值返回给子进程</strong></span></big></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100243.png" alt="image-20241220091917855"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>如果创建失败，则父进程会返回$-1$</p>
</p>
    </div>
</div><h4 id="进程映像的改换——exec"><a class="header-anchor" href="#进程映像的改换——exec">¶</a>进程映像的改换——exec</h4>
<p>更改进程执行代码，更改正文段，数据段</p>
<p>调用格式：exec(文件名，参数列表，环境变量)</p>
<h4 id="进程终止——exit"><a class="header-anchor" href="#进程终止——exit">¶</a>进程终止——exit</h4>
<p>当一个进程指向性结束后，进程可以调用exit自我终止。</p>
<p>终止时它放弃占用的所有资源，<strong>清除缓冲区</strong>，处于等待父进程善后处理状态。</p>
<h4 id="等待子进程终止——wait"><a class="header-anchor" href="#等待子进程终止——wait">¶</a>等待子进程终止——wait</h4>
<p>父进程等待子进程的终止</p>
<p>对处于等待善后处理状态的子进程进行善后处理。</p>
<p>在用户态进程中，父进程调用wait(status)等待它的一个子进程终止</p>
<p>若子进程没有终止，则它进入阻塞态</p>
<h2 id="进程通信"><a class="header-anchor" href="#进程通信">¶</a>进程通信</h2>
<p>进程通信是指进程之间的信息交换</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201103693.png" alt="image-20241220093317725"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100239.png" alt=""></p>
<h3 id="信号"><a class="header-anchor" href="#信号">¶</a>信号</h3>
<h4 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h4>
<p>软件中断</p>
<p>处理异步事件的机制</p>
<p>信号名(以SIG开头)</p>
<h4 id="信号产生"><a class="header-anchor" href="#信号产生">¶</a>信号产生</h4>
<p>按中断键，硬件异常，kill函数，kill命令</p>
<h4 id="信号-2"><a class="header-anchor" href="#信号-2">¶</a>信号</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100506.png" alt="image-20241220093706272"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201100036.png" alt="image-20241220093717283"></p>
<h3 id="无名管道"><a class="header-anchor" href="#无名管道">¶</a>无名管道</h3>
<h4 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>管道是连接读写进程的一个特殊文件，允许进程按先进先出的方式传送数据，也能使进程同步执行操作</p>
</li>
<li class="lvl-2">
<p>发送进程以字符流形式把大量数据送入管道，接收进程重管道中读取数据，所以叫管道通信</p>
</li>
</ul>
<h4 id="相关系统调用"><a class="header-anchor" href="#相关系统调用">¶</a>相关系统调用</h4>
<p>通过pipe系统调用创建无名管道，得到两个文件描述符，分别用于写和读</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201103522.png" alt="image-20241220094536400"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201059794.png" alt="image-20241220094559790"></p>
<h3 id="消息队列"><a class="header-anchor" href="#消息队列">¶</a>消息队列</h3>
<h4 id="msgget"><a class="header-anchor" href="#msgget">¶</a>msgget</h4>
<p>根据用户给出的整数值key，创建新消息队列或打开现有消息队列，返回一个消息队列ID</p>
<h4 id="msgsnd"><a class="header-anchor" href="#msgsnd">¶</a>msgsnd</h4>
<p>发送消息</p>
<h4 id="msgrcv"><a class="header-anchor" href="#msgrcv">¶</a>msgrcv</h4>
<p>接收消息，可以指定消息类型；没有消息返回-1</p>
<h4 id="msgctl"><a class="header-anchor" href="#msgctl">¶</a>msgctl</h4>
<p>对消息队列进行控制，如删除消息队列；</p>
<h3 id="无名管道-2"><a class="header-anchor" href="#无名管道-2">¶</a>无名管道</h3>
<h4 id="原理-2"><a class="header-anchor" href="#原理-2">¶</a>原理</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>共享内存是内核为进程创建的一个特殊的内存段，它可连接到自己的地址空间，也可以连接到其他进程的地址空间</p>
</li>
<li class="lvl-2">
<p>最快的进程间通信方式</p>
</li>
<li class="lvl-2">
<p>不提供任何同步功能</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201059663.png" alt="image-20241220100757861"></p>
<h2 id="线程的概念及实现"><a class="header-anchor" href="#线程的概念及实现">¶</a>线程的概念及实现</h2>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>进程的两个<strong>基本属性</strong></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>进程是一个可拥有资源的独立单位</p>
</li>
<li class="lvl-2">
<p>进程是一个可独立调度和分派的基本单位</p>
</li>
</ul>
</p>
    </div>
</div><ul class="lvl-0">
<li class="lvl-2">
<p><strong>进程</strong>是拥有资源的基本单位</p>
</li>
<li class="lvl-2">
<p><strong>线程</strong>作为调度和分派的基本单位</p>
</li>
</ul>
<p><strong>调度的基本单位</strong></p>
<p><strong>并发性</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在引入线程的操作系统中，不仅进程中间可以并发执行，而且在一个进程中的多个线程之间，也可以并发执行</p>
</li>
</ul>
<h3 id="线程状态"><a class="header-anchor" href="#线程状态">¶</a>线程状态</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>执行态、就绪态、阻塞态</p>
</li>
<li class="lvl-2">
<p>线程状态转换与进程状态转换一样</p>
</li>
</ul>
<h3 id="进程控制块-2"><a class="header-anchor" href="#进程控制块-2">¶</a>进程控制块</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程标识符、一组寄存器、线程运行态、优先级、线程专有存储器、信号屏蔽、堆栈指针</p>
</li>
</ul>
<h3 id="线程实现"><a class="header-anchor" href="#线程实现">¶</a>线程实现</h3>
<h4 id="实现方式"><a class="header-anchor" href="#实现方式">¶</a>实现方式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>内核支持线程KST</p>
</li>
<li class="lvl-2">
<p>用户级线程ULT</p>
</li>
<li class="lvl-2">
<p>组合方式</p>
</li>
</ul>
<p>具体实现：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内核支持线程的实现</p>
</li>
<li class="lvl-2">
<p>用户级线程的实现</p>
</li>
</ul>
<h4 id="在内核空间的实现"><a class="header-anchor" href="#在内核空间的实现">¶</a>在内核空间的实现</h4>
<p>优点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在多处理机系统中，内核可同时调度同一进程的多个线程</p>
</li>
<li class="lvl-2">
<p>如果一个线程阻塞了，内核可调度其他线程(同一或其他进程)</p>
</li>
<li class="lvl-2">
<p>线程切换比较块，开销小</p>
</li>
<li class="lvl-2">
<p>内核本身可采用多线程技术，提高执行速度和效率</p>
</li>
</ul>
<p>缺点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对用户线程切换，开销较大</p>
</li>
</ul>
<h4 id="用户级线程ULT"><a class="header-anchor" href="#用户级线程ULT">¶</a>用户级线程ULT</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201059363.png" alt="image-20241220103748808"></p>
<p>优点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程切换不需要转换到内核空间</p>
</li>
<li class="lvl-2">
<p>调度算法可以是进程专用的</p>
</li>
<li class="lvl-2">
<p>线程的实现与OS平台无关</p>
</li>
</ul>
<p>缺点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统调用的阻塞问题</p>
</li>
<li class="lvl-2">
<p>多线程应用不能利用多处理机进行多重处理的优点</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201059500.png" alt="image-20241220104928083"></p>
<h3 id="进程线程对比"><a class="header-anchor" href="#进程线程对比">¶</a>进程线程对比</h3>
<ol>
<li class="lvl-3">
<p>需要频繁创建销毁的优先用线程</p>
</li>
<li class="lvl-3">
<p>需要进行大量计算的优先使用线程。所谓大量计算，会耗费很多CPU，切换频繁，优先选择线程。</p>
</li>
<li class="lvl-3">
<p>强相关处理用线程，弱相关处理用进程</p>
</li>
<li class="lvl-3">
<p>可能要拓展到多机分布的用进程，多核分布的用线程</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>课后习题</h3>
<ol>
<li class="lvl-3">
<p>🚩采用轮换调度算法，进程中设置内核进程和用户进程效果完全不同</p>
</li>
<li class="lvl-3">
</li>
</ol>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/posts/ae533703.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="文件目录"><a class="header-anchor" href="#文件目录">¶</a>文件目录</h2>
<h4 id="文件控制块"><a class="header-anchor" href="#文件控制块">¶</a>文件控制块</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>文件控制块(FCB)</strong>：管理和控制文件的数据结构，与文件一一对应</p>
</li>
<li class="lvl-2">
<p><strong>文件目录</strong>：文件控制块的集合，即一个文件控制块就是一个文件目录项</p>
</li>
<li class="lvl-2">
<p><strong>目录文件</strong>：文件目录也被看作一个文件</p>
</li>
</ul>
<h4 id="索引节点"><a class="header-anchor" href="#索引节点">¶</a>索引节点</h4>
<p>减少磁盘访问次数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>把文件与文件描述信息分开，文件描述信息</p>
<p>用索引节点保存，简称为i节点</p>
</li>
<li class="lvl-2">
<p>索引节点：文件控制块除了文件名的其他信息</p>
</li>
<li class="lvl-2">
<p>文件目录：文件名和文件索引节点编号</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412230950302.png" alt="image-20241223095008467"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>文件索引节点只是将文件名单独放到了一个索引表中，而不是把一整个FCB放到了索引表中；所以，首先，需要从文件索引表中查到FCB的额位置，然后再访问FCB才算是完整的一个文件访问过程</p>
<p>即，查找一个文件需要两次访问，先访问索引节点，再访问FCB</p>
</p>
    </div>
</div><h2 id="文件共享与保护"><a class="header-anchor" href="#文件共享与保护">¶</a>文件共享与保护</h2>
<h3 id="文件共享"><a class="header-anchor" href="#文件共享">¶</a>文件共享</h3>
<h4 id="基于有向无环图实现共享"><a class="header-anchor" href="#基于有向无环图实现共享">¶</a>基于有向无环图实现共享</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412230958368.png" alt="image-20241223095830786"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>即，在B目录添加一个索引或者记录，指向共享文件的FCB，这样就完成了一次共享。</p>
<p>注意，在共享时count+1，即标识当前文件有几个目录使用。</p>
<p>当删除文件时会令count-1，此时，如果文件的count减到了0，那么文件才会被删除。</p>
</p>
    </div>
</div><h4 id="符号链接共享"><a class="header-anchor" href="#符号链接共享">¶</a>符号链接共享</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412231002471.png" alt="image-20241223100205071"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>即，Link，并不修改共享文件的FCB，链接文件像是单方共享</p>
<p>当主文件被删除时<small>（即不在文件中）</small>，此时链接就会失效，并不像基于有向无环图那样，修改文件计数。</p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>处理机的调度与死锁</title>
    <url>/posts/1ba791ab.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201117837.png" alt="image-20241220111714119"></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h2>平均周转时间 与 平均等待时间？</h2>
<ul class="lvl-1">
<li class="lvl-2">
<p>周转时间 = 作用完成时间 - 作业到达时间</p>
</li>
<li class="lvl-2">
<p>带权周转时间 = 周转时间 / 服务时间</p>
</li>
<li class="lvl-2">
<p>平均周转时间 = 作业周转总时间 / 作业个数</p>
</li>
<li class="lvl-2">
<p>平均带权周转时间 = 带权周转总时间 / 作业个数</p>
</li>
</ul>
</p>
    </div>
</div><h2 id="调度算法"><a class="header-anchor" href="#调度算法">¶</a>调度算法</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>先来先服务算法（FCFS）（<strong>F</strong>irst <strong>C</strong>ome, <strong>F</strong>irst <strong>S</strong>erved.）</p>
</li>
<li class="lvl-2">
<p>短作业优先算法（SJF）（<strong>S</strong>hortest <strong>J</strong>ob <strong>F</strong>irst）</p>
</li>
<li class="lvl-2">
<p>优先级调度（RR）</p>
</li>
<li class="lvl-2">
<p>高响应比优先调度算法（HRRN）(<strong>h</strong>ighest <strong>r</strong>esponse <strong>r</strong>atio <strong>n</strong>ext)</p>
</li>
</ul>
<h3 id="算法性能评价"><a class="header-anchor" href="#算法性能评价">¶</a>算法性能评价</h3>
<h4 id="周转时间"><a class="header-anchor" href="#周转时间">¶</a>周转时间</h4>
<ol>
<li class="lvl-5">
<p>周转时间 = 完成时间 - 到达时间</p>
</li>
<li class="lvl-5">
<p>平均周转时间：周转时间/进程数</p>
</li>
<li class="lvl-5">
<p>带权周转时间：周转时间/服务时间</p>
</li>
<li class="lvl-5">
<p>平均带权周转时间：带权周转时间/进程数</p>
</li>
</ol>
<h4 id="响应时间"><a class="header-anchor" href="#响应时间">¶</a>响应时间</h4>
<p>从用户通过键盘提交一个请求开始，到系统首次产生响应为止的时间，包括键盘输入时间、信息处理时间和信息回收时间</p>
<h4 id="截止时间"><a class="header-anchor" href="#截止时间">¶</a>截止时间</h4>
<p>某任务必须开始执行的时间（开始截止时间）和执行完成时间（完成截止时间）</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>非抢占式调度</h4>
<p>指进程一旦获得处理机，只有在该进程任务完成或因某事间而阻塞才让出处理机，绝不允许某进程抢占已经分配出去的处理机。</p>
<h4>抢占式调度</h4>
<p>抢占式调度  <small>(PreemptiveMode)</small> 允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。</p>
</p>
    </div>
</div><h3 id="短作业优先算法-small-SJF-small"><a class="header-anchor" href="#短作业优先算法-small-SJF-small">¶</a>短作业优先算法 <small>SJF</small></h3>
<p>从等待队列中取下<strong>服务时间最短</strong>的进程进行执行</p>
<h5 id="非抢占式调度"><a class="header-anchor" href="#非抢占式调度">¶</a>非抢占式调度</h5>
<ol>
<li class="lvl-3">
<p>找出最先到达的进程（该进程的完成时间=到达时间+服务时间）；</p>
</li>
<li class="lvl-3">
<p>根据上一进程的完成时间，找到在这个完成时间内所有到达的进程，并找到这些进程中服务时间最短的那个，然后计算它的完成时间（<strong>该进程的完成时间=上一进程的完成时间+该进程服务时间</strong>）；</p>
</li>
<li class="lvl-3">
<p>重复2直至完成所有进程的计算。</p>
</li>
</ol>
<h5 id="抢占式调度"><a class="header-anchor" href="#抢占式调度">¶</a>抢占式调度</h5>
<ol>
<li class="lvl-3">
<p>找出最先到达的进程（该进程的完成时间=到达时间+服务时间）</p>
</li>
<li class="lvl-3">
<p>根据上一进程的完成时间，找到在这个完成时间内所有到达的进程，并找到这些进程中服务时间最短的那个，<strong>在进程运行中，有新到达的进程时，会比较两者的服务时间（该进程剩余的服务时间与新进程的服务时间进行比较，若小则继续运行，若大则暂停进程，新进程运行。</strong>）</p>
</li>
<li class="lvl-3">
<p>重复2直至完成所有进程的计算。</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>这里有<em><strong>基于最短服务时间</strong></em>和<strong>基于最短剩余服务时间</strong>两种</p>
<p>上面提供的抢占式调度流程，是基于最短剩余时间的</p>
</p>
    </div>
</div><blockquote>
<p><strong>SJF特点是降低了系统平均周转时间。</strong></p>
<p><strong>但对长作业不利，长作业有可能长时间得不到调度。</strong></p>
</blockquote>
<h3 id="优先级调度算法"><a class="header-anchor" href="#优先级调度算法">¶</a>优先级调度算法</h3>
<h3 id="高响应比优先调度算法"><a class="header-anchor" href="#高响应比优先调度算法">¶</a>高响应比优先调度算法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><span style="color:blue">响应比</span></p>
<p>$$<br>
R_P = \frac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}} = \frac{\text{响应时间}}{\text{要求服务时间}} = 1 + \frac{\text{等待时间}}{\text{服务时间}}<br>
$$</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>相关例题</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201632298.png" alt="image-20241220163207688"></p>
<h4>解题方略</h4>
<p>画表画轴</p>
<p>在考察这类知识点时，一般题目都会给出进程<strong>到达时间</strong>以及进程<strong>运行时间</strong>  <small>(也叫服务时间)</small></p>
<p>在草稿纸上画表，加上<strong>开始时间</strong>，<strong>完成时间</strong>，<strong>周转时间</strong>，<strong>带权周转时间</strong>项</p>
<p>然后，画数轴，来反映进程执行状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906855.png" alt="image-20241220165621402"></p>
</p>
    </div>
</div><h4 id="优缺点"><a class="header-anchor" href="#优缺点">¶</a>优缺点</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>如等待时间相同，取决于运行时间，类似于SJF</p>
</li>
<li class="lvl-2">
<p>如运行时间相同，取决于等待时间，类似于FCFS</p>
</li>
<li class="lvl-2">
<p>长作业可随其等待时间的增加而提高，也可得到服务</p>
</li>
<li class="lvl-2">
<p>缺点：每次调度之前，都需要计算响应比，增加系统开销</p>
</li>
</ul>
<h3 id="时间片轮转调度算法"><a class="header-anchor" href="#时间片轮转调度算法">¶</a>时间片轮转调度算法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><span style="color:red">一般准则</span>：时间片/10&gt;进程上下文</p>
</li>
</ul>
<h3 id="多级队列调度算法"><a class="header-anchor" href="#多级队列调度算法">¶</a>多级队列调度算法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>就绪队列从一个分为多个，如：</p>
<ul class="lvl-2">
<li class="lvl-4">前台[交互式]</li>
<li class="lvl-4">后台[批处理]</li>
</ul>
</li>
<li class="lvl-2">
<p>每个队列都有自己的调度算法</p>
</li>
<li class="lvl-2">
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201720399.png" alt="image-20241220172015600"></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>几种调度算法对比</h3>
<p><strong>短作业优先（SJF）</strong>：<em>最低的平均周转时间</em>和<em>平均带权周转时间</em>，但对长作业不公平。</p>
<p><strong>高响应比优先（HRRN）</strong>：平衡了短作业和长作业的公平性。</p>
<p><strong>优先级调度</strong>：灵活性高，但需要合理设置优先级。</p>
<p><strong>先来先服务（FCFS）</strong>：实现简单，但可能导致性能低下。</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>多个作业同时到达时</strong></p>
<p><big><strong>短作业优先算法拥有<big>最低的平均周转时间</big></strong></big></p>
</p>
    </div>
</div><h2 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201837409.png" alt="image-20241220183729683"></p>
<h3 id="死锁的必要条件"><a class="header-anchor" href="#死锁的必要条件">¶</a>死锁的必要条件</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>互斥</p>
<p><small>资源在某一时刻只能被一个资源占有或使用</small></p>
</li>
<li class="lvl-2">
<p>请求和保持</p>
<p><small>一个进程已经持有至少一个资源，同时又请求其他资源</small></p>
</li>
<li class="lvl-2">
<p>不可抢占（不可剥夺）</p>
<p><small>已经分配给某个进程的资源，在未被进程主动释放前，不能被其他进程强行夺走</small></p>
</li>
<li class="lvl-2">
<p>循环等待（环路等待）</p>
<p><small>系统中存在一个进程等待环，环中的每个进程都在等待下一个进程持有的资源。</small></p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>判断是否死锁的方法</h4>
<p>系统中有 $N$ 个进程，某种资源 $M$ 个，每个进程需要最多 $k$ 个资源，系统不会发生死锁的条件是：<br>
$$<br>
N(k-1) &lt; M<br>
$$<br>
即，先给每个进程分给他们所需要资源少于一个的资源，如果此时还有多的资源，则一定会有一个进程可以启动，所以就不会发送死锁</p>
</p>
    </div>
</div><h3 id="处理死锁的方法"><a class="header-anchor" href="#处理死锁的方法">¶</a>处理死锁的方法</h3>
<h4 id="死锁的避免"><a class="header-anchor" href="#死锁的避免">¶</a>死锁的避免</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>银行家算法</p>
<p>通过记录资源使用情况，以避免死锁的发生</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>操作系统：银行家</p>
</li>
<li class="lvl-4">
<p>资源：周转资金</p>
</li>
<li class="lvl-4">
<p>进程：贷款的客户</p>
</li>
</ul>
</li>
</ul>
<h5 id="安全状态与不安全状态"><a class="header-anchor" href="#安全状态与不安全状态">¶</a>安全状态与不安全状态</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安全状态</strong>：</p>
<p>是指系统能按某种进程顺序 ($P_1$ ， $P_2$ ，$Pn$)( 称〈 PI·” Pn 〉序列为安全序列），来为每个进程 P i 分配其所需资源直牵满足每个进程对资源的最大需求，使每个进程都可顺利地成。</p>
</li>
<li class="lvl-2">
<p><strong>不安全状态</strong>：</p>
<p>如果系统<strong>无法找到</strong>这样一个<strong>安全序列</strong>，则称系统于<strong>不安全状态</strong>。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906077.png" alt="image-20241220190054024"></p>
<h4 id="银行家算法"><a class="header-anchor" href="#银行家算法">¶</a>银行家算法</h4>
<p>略</p>
<h4 id="死锁检测"><a class="header-anchor" href="#死锁检测">¶</a>死锁检测</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>资源分配图</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906690.png" alt="image-20241220190426767"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906391.png" alt="image-20241220190438547"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906711.png" alt="image-20241220190453753"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906528.png" alt="image-20241220190547182"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201906813.png" alt="image-20241220190559889"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201907656.png" alt="image-20241220190711273"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>4.1指令系统的基本格式</title>
    <url>/posts/688831be.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>调页策略</title>
    <url>/posts/f830ee25.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>虚拟存储管理中的调页技术是操作系统为管理虚拟内存和物理内存而采取的一种核心策略。调页技术的主要目的是高效地将内存页面在主存（RAM）和辅助存储（通常是磁盘）之间进行交换，以实现内存的扩展并提高程序执行效率。以下是调页技术的关键点及其分类：</p>
</p>
    </div>
</div><span id="more"></span>
<hr>
<h3 id="1-调页技术的基本原理"><a class="header-anchor" href="#1-调页技术的基本原理">¶</a><strong>1. 调页技术的基本原理</strong></h3>
<p>虚拟存储管理允许程序使用比物理内存容量更大的地址空间。当程序访问的虚拟地址未被映射到物理内存时，会触发<strong>页面错误（Page Fault）</strong>。此时，操作系统会根据调页策略选择适当的页面进行替换。</p>
<p>调页技术的核心流程：</p>
<ol>
<li class="lvl-3">
<p><strong>页面加载</strong>：将所需的页面从磁盘加载到物理内存。</p>
</li>
<li class="lvl-3">
<p><strong>页面置换</strong>：当内存已满时，根据页面置换算法选择一个页面从内存中移出。</p>
</li>
<li class="lvl-3">
<p><strong>页面回写</strong>：如果被替换的页面被修改，则需要将其写回磁盘。</p>
</li>
</ol>
<hr>
<h3 id="2-调页的分类"><a class="header-anchor" href="#2-调页的分类">¶</a><strong>2. 调页的分类</strong></h3>
<p>调页技术主要分为以下几种类型：</p>
<h4 id="1-请求调页-Demand-Paging"><a class="header-anchor" href="#1-请求调页-Demand-Paging">¶</a><strong>(1) 请求调页 (Demand Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：仅当程序访问某页面时才将其加载到内存。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：减少了不必要的页面加载，提高内存利用率。</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：大部分程序的访问具有<strong>局部性原理</strong>，即程序倾向于访问最近使用过的页面或临近页面。</p>
</li>
</ul>
<h4 id="2-预调页-Pre-paging"><a class="header-anchor" href="#2-预调页-Pre-paging">¶</a><strong>(2) 预调页 (Pre-paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：在加载当前页面时，预先加载与其相关的其他页面。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：可以减少未来的页面错误次数，提高程序执行效率。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：可能会加载一些实际上不需要使用的页面，导致资源浪费。</p>
</li>
</ul>
<h4 id="3-局部调页-Local-Paging"><a class="header-anchor" href="#3-局部调页-Local-Paging">¶</a><strong>(3) 局部调页 (Local Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：每个进程只能在其被分配的物理页面中进行页面置换。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：确保每个进程的内存页面是独立管理的，避免被其他进程干扰。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：在内存分配不足时，可能导致某些进程频繁发生页面错误（抖动）。</p>
</li>
</ul>
<h4 id="4-全局调页-Global-Paging"><a class="header-anchor" href="#4-全局调页-Global-Paging">¶</a><strong>(4) 全局调页 (Global Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：所有进程共享物理页面，页面置换可以选择任意进程的页面。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：内存利用率更高，系统能更动态地调整内存分配。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：某些进程可能因为其他进程频繁置换其页面而受到干扰。</p>
</li>
</ul>
<hr>
<h3 id="3-调页算法"><a class="header-anchor" href="#3-调页算法">¶</a><strong>3. 调页算法</strong></h3>
<p>调页技术需要依赖页面置换算法来决定哪一页需要被替换。以下是几种常见的页面置换算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>FIFO（First In First Out）</strong>：最先进入内存的页面最先被替换。</p>
</li>
<li class="lvl-2">
<p><strong>LRU（Least Recently Used）</strong>：选择最近最久未使用的页面进行置换。</p>
</li>
<li class="lvl-2">
<p><strong>LFU（Least Frequently Used）</strong>：选择访问频率最少的页面进行置换。</p>
</li>
<li class="lvl-2">
<p><strong>OPT（Optimal Page Replacement）</strong>：理想情况下选择将来不再使用或最晚被使用的页面。</p>
</li>
<li class="lvl-2">
<p><strong>Clock（时钟算法）</strong>：基于页面的访问位，结合环形链表实现的近似 LRU 算法。</p>
</li>
</ul>
<hr>
<h3 id="4-调页的优缺点"><a class="header-anchor" href="#4-调页的优缺点">¶</a><strong>4. 调页的优缺点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：</p>
<ul class="lvl-2">
<li class="lvl-4">提高了内存利用率和系统的多任务能力。</li>
<li class="lvl-4">支持程序运行时动态扩展内存需求。</li>
</ul>
</li>
<li class="lvl-2">
<p>缺点：</p>
<ul class="lvl-2">
<li class="lvl-4">页面置换和调页操作会增加系统开销。</li>
<li class="lvl-4">如果频繁发生页面错误，会导致性能下降（抖动现象）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-实际应用场景"><a class="header-anchor" href="#5-实际应用场景">¶</a><strong>5. 实际应用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>服务器环境</strong>：通过请求调页减少内存占用，同时根据负载动态调整进程的页面分配。</p>
</li>
<li class="lvl-2">
<p><strong>嵌入式系统</strong>：通常采用局部调页，确保关键任务的内存资源得到优先保证。</p>
</li>
<li class="lvl-2">
<p><strong>高性能计算</strong>：结合预调页和全局调页，充分利用内存和缓存的空间局部性。</p>
</li>
</ul>
<hr>
<h3 id="6-优化方向"><a class="header-anchor" href="#6-优化方向">¶</a><strong>6. 优化方向</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页面大小</strong>：适当增大页面大小可以减少页面错误，但也会增加内存浪费。</p>
</li>
<li class="lvl-2">
<p><strong>缓存技术</strong>：通过硬件缓存或高速内存进一步减少调页操作。</p>
</li>
<li class="lvl-2">
<p><strong>智能预取</strong>：结合程序运行的访问模式预测未来可能需要的页面。</p>
</li>
</ul>
<hr>
<p>调页技术是现代操作系统虚拟存储管理的重要组成部分。通过结合不同的调页策略和优化方法，可以显著提升内存利用率和系统性能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>进程同步</title>
    <url>/posts/4de07942.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412241659642.png" alt="image-20241220204542857"></p>
<p>相关链接|<a href="/posts/1ba791ab#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁的必要条件</a></p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2>
<h3 id="临界区"><a class="header-anchor" href="#临界区">¶</a>临界区</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><span style="color:red">临界区：进程中涉及临界资源的代码段</span></p>
</li>
<li class="lvl-2">
<p>进入区．用于检查是否可以进入临界区的代码段。</p>
</li>
<li class="lvl-2">
<p>退出区：将临界区正被访问的标志恢复为未被访问标志。</p>
</li>
<li class="lvl-2">
<p>剩余区：其他代码</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201921936.png" alt="image-20241220192132479"></p>
<h3 id="同步进制应该遵守的准则"><a class="header-anchor" href="#同步进制应该遵守的准则">¶</a>同步进制应该遵守的准则</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201922898.png" alt="image-20241220192225160"></p>
<h2 id="进程同步机制"><a class="header-anchor" href="#进程同步机制">¶</a>进程同步机制</h2>
<h3 id="软件同步机制"><a class="header-anchor" href="#软件同步机制">¶</a>软件同步机制</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>软件同步机制</p>
<p>使用编程方法解决临界区问题</p>
</li>
<li class="lvl-2">
<p>硬件同步机制</p>
<p>使用特殊的硬件指令，可有效的实现进程互斥</p>
</li>
<li class="lvl-2">
<p><strong>信号量机制</strong></p>
</li>
<li class="lvl-2">
<p>管程机制</p>
</li>
</ul>
<h3 id="信号量机制"><a class="header-anchor" href="#信号量机制">¶</a>信号量机制</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201929170.png" alt="image-20241220192922246"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201928780.png" alt="image-20241220192858207"></p>
<h4 id="信号量的使用"><a class="header-anchor" href="#信号量的使用">¶</a>信号量的使用</h4>
<ol>
<li class="lvl-3">
<p><strong>定义信号量</strong></p>
<p><span style="color:blue">一种临界资源，定义一个信号量</span></p>
<p>互斥 —— 临界资源 —— s</p>
</li>
<li class="lvl-3">
<p><strong>初值</strong></p>
<p><code>s.value</code> = <span style="color:red">资源总数</span></p>
</li>
<li class="lvl-3">
<p><strong>PV操作</strong></p>
<p>进临界区前 <code>P(s)</code></p>
<p>退出临界区<code>V(s)</code></p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>做题小点</h5>
<p>V操作是唤醒一个进程</p>
<p>并不是说停下当前进程执行另一进程</p>
<p>而是，将唤醒进程从当前信号量的阻塞队列中取出，放入就绪队列，等待系统调度。</p>
</p>
    </div>
</div><h4 id="利用信号量实现前驱-同步"><a class="header-anchor" href="#利用信号量实现前驱-同步">¶</a>利用信号量实现前驱/同步</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412201938064.png" alt="image-20241220193803461"></p>
<h3 id="管程机制"><a class="header-anchor" href="#管程机制">¶</a>管程机制</h3>
<p>管程定义的是公共的数据结构，如消息队列</p>
<blockquote>
<p>进程定义的私有的数据结构，对进程是封闭的，进程无法访问</p>
</blockquote>
<p>感觉像是将进程的同步与互斥封装到资源的使用中</p>
<blockquote>
<p>就像是，在使用套接字时，会有个函数专门管理连接请求，在使用的过程中，我们发现，会有一个模式：即，当调用函数进行网络连接时，如果当前没有连接请求，调用函数的进程就会阻塞，而程序中不用显示的引用PV操作，而是利用库函数，对进程状态进行管控，简化了同步过程。</p>
</blockquote>
<p>在进程访问资源时，都会调用管程，以申请资源，从而达到进程互斥的效果。</p>
<p>管程的三个特性</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模块化（封装性）</p>
</li>
<li class="lvl-2">
<p>抽象数据类型</p>
</li>
<li class="lvl-2">
<p>信息隐蔽</p>
</li>
</ul>
<h2 id="经典的进程同步问题"><a class="header-anchor" href="#经典的进程同步问题">¶</a>经典的进程同步问题</h2>
<h3 id="生产者消费者模型"><a class="header-anchor" href="#生产者消费者模型">¶</a>生产者消费者模型</h3>
<h4 id="一个生产者，一个消费者，一个缓冲区"><a class="header-anchor" href="#一个生产者，一个消费者，一个缓冲区">¶</a>一个生产者，一个消费者，一个缓冲区</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202018579.png" alt="image-20241220201806894"></p>
<h4 id="多个生产者，多个消费者，n个缓冲区"><a class="header-anchor" href="#多个生产者，多个消费者，n个缓冲区">¶</a>多个生产者，多个消费者，n个缓冲区</h4>
<p>首先，生产者们与消费者们会相互竞争缓冲区队列，因为他们都会对缓冲区队列状态产生改变</p>
<p>其中，生产者们要竞争空位，以放入产品，消费者们要相互竞争产品。</p>
<p>所以还有空位信号量和物品信号量</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202025662.png" alt="image-20241220202557051"></p>
<p><big><strong>但申请空位/商品，必须在申请缓冲区队列之前</strong></big>，可以这样理解，先申请空位/商品，在申请进入缓冲区放/拿商品。</p>
<p>而且如果先申请进入队列，而恰好没有空位，此时进程会阻塞，而进程已经进入 进入队列的临界区，此时其他进程也讲无法进入队列临界区，导致消费者无法进入临界区消费，最后导致死锁。</p>
<h3 id="读者写者问题"><a class="header-anchor" href="#读者写者问题">¶</a>读者写者问题</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202031920.png" alt="image-20241220203146955"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202034935.png" alt="image-20241220203455858"></p>
<blockquote>
<p>写者需要等待所有读者进程均退出后才能接着写</p>
<p>如果当前无读者，则可能资源处于“写”状态，需要申请；</p>
<p>如果当前有读者，说明当前资源处于“读”状态，无需申请；</p>
<p>如果当前所有读者均读完<small>（readcount == 0  即没有读者了）</small>，可能等待队列中有写者在被阻塞，则最后一个读者负责唤醒“写进程”。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202040568.png" alt="image-20241220204045095"></p>
<h3 id="哲学家进餐问题"><a class="header-anchor" href="#哲学家进餐问题">¶</a>哲学家进餐问题</h3>
<p><img src="./assets/image-20241220204127428.png" alt="image-20241220204127428"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>破坏死锁的任何一个必要条件即可<a href="./posts/1ba791ab#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁的必要条件</a></p>
</p>
    </div>
</div><h3 id="信号量使用总结"><a class="header-anchor" href="#信号量使用总结">¶</a>信号量使用总结</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202044395.png" alt="image-20241220204453017"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412202045083.png" alt="image-20241220204510426"></p>
<p><img src="./assets/image-20241220204530903.png" alt="image-20241220204530903"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
        <category>OS</category>
        <category>操作系统</category>
        <category>章节笔记</category>
      </categories>
  </entry>
  <entry>
    <title>1.1计算机网络概论</title>
    <url>/posts/f4cb0304.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>PPT计算机网络概论，知识点总结</p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="计算机网络的分类"><a class="header-anchor" href="#计算机网络的分类">¶</a>计算机网络的分类</h3>
<h4 id="按覆盖范围分"><a class="header-anchor" href="#按覆盖范围分">¶</a>按覆盖范围分</h4>
<ol>
<li class="lvl-3">
<p><strong>广域网</strong></p>
<p><small>作用范围通常为几十到几千公里，任务是长距离运送主机所发送的数据</small></p>
</li>
<li class="lvl-3">
<p><strong>城域网</strong></p>
<p><small>作用范围一般是一个城市</small></p>
</li>
<li class="lvl-3">
<p><strong>局域网</strong></p>
<p><small>如<strong>校园网</strong>或<strong>企业网</strong></small></p>
</li>
<li class="lvl-3">
<p><strong>个人区域网</strong></p>
<p><small>是在个人工作的地方把属于个人使用的电子设备，用无线设备连接起来的网络</small></p>
</li>
</ol>
<h4 id="按用户使用者分"><a class="header-anchor" href="#按用户使用者分">¶</a>按用户使用者分</h4>
<ol>
<li class="lvl-3">
<p><strong>公用网</strong></p>
<p><small>按规定交纳费用的人都可以使用的网络。也可称为公众网。</small></p>
</li>
<li class="lvl-3">
<p><strong>专用网</strong></p>
<p><small>为特殊业务工作的需要而建造的网络。</small></p>
</li>
</ol>
<h4 id="按拓扑结构分"><a class="header-anchor" href="#按拓扑结构分">¶</a>按拓扑结构分</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>星形网络</p>
</li>
<li class="lvl-2">
<p>环形网络</p>
</li>
<li class="lvl-2">
<p>总线网络</p>
</li>
<li class="lvl-2">
<p>网状结构</p>
</li>
</ul>
<h3 id="计算机网络的性能指标"><a class="header-anchor" href="#计算机网络的性能指标">¶</a>计算机网络的性能指标</h3>
<p>单位换算：<br>
$$<br>
k = 10^3 \\<br>
M = 10^6 \\<br>
G = 10^9<br>
$$</p>
<p>$$<br>
\text{发送时延} = \frac{数据帧长度}{发送速率}<br>
$$</p>
<p>$$<br>
\text{传播时延} = \frac{信道长度}{电磁波在信道上的传播速率}<br>
$$</p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>1.2-网络体系结构与网络协议</title>
    <url>/posts/ec7daff7.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="OSI七层模型"><a class="header-anchor" href="#OSI七层模型">¶</a>OSI七层模型</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282112565.png" alt="image-20241228211242504"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>应用层</strong>：</p>
<p>通过应用层协议，提供应用程序便捷使用的网络服务调用</p>
</li>
<li class="lvl-2">
<p><strong>表示层</strong>：</p>
<p>关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构</p>
</li>
<li class="lvl-2">
<p><strong>会话层</strong>：</p>
<p>利用传输层提供的服务，在应用程序之间建立和维持会话，并使会话获得同步</p>
</li>
<li class="lvl-2">
<p><strong>传输层</strong>：</p>
<p>传输层为<strong>终端用户</strong>提供端到端的数据传输控制</p>
</li>
<li class="lvl-2">
<p><strong>网络层</strong></p>
<p>将数据包跨越网络从源设备发送到目的设备</p>
</li>
<li class="lvl-2">
<p><strong>数据链路层</strong></p>
<p>实现相邻网络实体间的数据传输</p>
</li>
<li class="lvl-2">
<p><strong>物理层</strong></p>
<p>定义如何在信道上传输0、1</p>
</li>
</ul>
<h3 id="TCP-IP参考模型"><a class="header-anchor" href="#TCP-IP参考模型">¶</a>TCP/IP参考模型</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282121589.png" alt="image-20241228212125527"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282122753.png" alt="image-20241228212207690"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282122611.png" alt="image-20241228212231562"></p>
<h3 id="五层网络体系结构"><a class="header-anchor" href="#五层网络体系结构">¶</a>五层网络体系结构</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>应用层</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>任务</strong>：通过应用进程间的交互来完成特定的网络应用</p>
</li>
<li class="lvl-4">
<p><strong>协议</strong>：定义的是<strong>应用进程</strong>间通信和交互的规则</p>
</li>
<li class="lvl-4">
<p>例如：DNS、HTTP、SMTP</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>传输层</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>任务</strong>：负责向两台主机<strong>进程</strong>之间通信提供通用的数据传输服务</p>
</li>
<li class="lvl-4">
<p>主要使用<strong>两种协议</strong>：</p>
<p>传输控制协议 TCP</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>提供<strong>面向连接</strong>的、<strong>可靠</strong>的数据传输服务</p>
</li>
<li class="lvl-6">
<p>数据传输的单位是<strong>报文段</strong></p>
</li>
</ul>
<p>用户数据报协议 UDP</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>提供无连接的<strong>尽最大努力</strong>的数据传输服务<small>（<strong>不保证数据传输的可靠性</strong>）</small></p>
</li>
<li class="lvl-6">
<p>数据传输的单位是<strong>用户数据报</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>网络层</strong></p>
<ul class="lvl-2">
<li class="lvl-4">为分组交换网上不同<strong>主机</strong>提供通信服务。</li>
<li class="lvl-4">两个具体<strong>任务</strong>：
<ul class="lvl-4">
<li class="lvl-6"><strong>路由选择</strong>：通过一定的算法，在互联网中的每个路由器上，<strong>生成</strong>一个用来转发分组的<strong>转发表</strong></li>
<li class="lvl-6"><strong>转发</strong>：每一个路由器在接收到一个分组时，要依据转发表中指明的路径把分组<strong>转发</strong>到下一个路由器</li>
</ul>
</li>
<li class="lvl-4">互联网使用的网络层协议包括<strong>无连接</strong>的<strong>网际协议IP</strong></li>
<li class="lvl-4">IP协议分组也叫做<strong>IP 数据报</strong>，或简称为<strong>数据报</strong></li>
</ul>
</li>
<li class="lvl-2">
<p><strong>数据链路层</strong>；</p>
<ul class="lvl-2">
<li class="lvl-4">常简称为<strong>链路层</strong></li>
<li class="lvl-4"><strong>任务</strong>：实现两个<strong>相邻节点</strong>之间的<strong>可靠通信</strong></li>
<li class="lvl-4">在两个相邻节点间的链路上传送<strong>帧</strong></li>
<li class="lvl-4">如发现有差错，就简单<strong>丢弃</strong>出错帧</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>物理层</strong></p>
<ul class="lvl-2">
<li class="lvl-4"><strong>任务</strong>：实现<strong>比特</strong>的传输</li>
<li class="lvl-4"><strong>注意</strong>：传递信息所利用的一些<strong>物理手段</strong>，如双绞线，同轴电缆、光缆、无线信道等，并<strong>不在物理层协议之内</strong>，而是在物理层协议的下面</li>
</ul>
</li>
</ul>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>2.5-信道复用技术</title>
    <url>/posts/ef176f0c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="信道复用"><a class="header-anchor" href="#信道复用">¶</a>信道复用</h3>
<h4 id="信道复用的定义"><a class="header-anchor" href="#信道复用的定义">¶</a>信道复用的定义</h4>
<p>为了提高通道线路的利用效率，降低通信成本，在一条物理线路上同时传输多路信息；</p>
<h4 id="信道复用分类"><a class="header-anchor" href="#信道复用分类">¶</a>信道复用分类</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>频分多路复用</p>
</li>
<li class="lvl-2">
<p>波分多路复用</p>
</li>
<li class="lvl-2">
<p><strong>时分多路复用</strong></p>
</li>
<li class="lvl-2">
<p><strong>码分多路复用</strong></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>2.2-数据通信基础</title>
    <url>/posts/eea27e4b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="波特率与比特率、二者之间的关系"><a class="header-anchor" href="#波特率与比特率、二者之间的关系">¶</a>波特率与比特率、二者之间的关系</h3>
<p><strong>波特率</strong>是指单位时间内通过信道传输的码元数</p>
<p><strong>比特率</strong>是指单位时间内通过信道传输的比特数</p>
<h3 id="信道的最大传输速率与信道带宽"><a class="header-anchor" href="#信道的最大传输速率与信道带宽">¶</a>信道的最大传输速率与信道带宽</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282149731.png" alt="image-20241228214926691"></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>3-数据链路层-局域网</title>
    <url>/posts/ff91f528.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CSMA-CD"><a class="header-anchor" href="#CSMA-CD">¶</a>CSMA/CD</h3>
<p>解决介质共享问题的核心技术</p>
<ol>
<li class="lvl-3">
<p>某站点想要发送数据，它必须首先侦听信道；</p>
</li>
<li class="lvl-3">
<p>如果信道空闲，立即发送数据；如果信道忙，则继续侦听信道，直到信道变为空闲，立即发送数据；</p>
</li>
<li class="lvl-3">
<p>站点在发送过程中继续检测信道，若一直未检测到碰撞，则把该数据成功发送完毕；如果检测到冲突，立即停止发送数据，发送干扰信号，然后执行指数退避算法，等待一随机长的时间，重新侦听信道，返回第2步。</p>
</li>
</ol>
<h3 id="冲突窗口的概念"><a class="header-anchor" href="#冲突窗口的概念">¶</a>冲突窗口的概念</h3>
<p>在一个局域网中，A、B两结点是距离最远的两点，相距D，信号传播速度V，A在发送数据后最多在W时间后可以检测出所有可能的冲突：$W=2D/V$,$W$被称为冲突窗口。</p>
<h3 id="Ethernet帧格式"><a class="header-anchor" href="#Ethernet帧格式">¶</a>Ethernet帧格式</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412291540494.png" alt="image-20241229154028441"></p>
<h3 id="最小帧长度"><a class="header-anchor" href="#最小帧长度">¶</a>最小帧长度</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412291541588.png" alt="image-20241229154143518"></p>
<h3 id="地址解析协议"><a class="header-anchor" href="#地址解析协议">¶</a>地址解析协议</h3>
<h4 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h4>
<p>主机或路由器每一网络接口都有一个ARP模块，将在<strong>同一网段</strong>上的目的IP地址作为输入，返回其MAC地址，作为封装数据帧的目的物理地址</p>
<h4 id="运行机制"><a class="header-anchor" href="#运行机制">¶</a>运行机制</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412291547281.png" alt="image-20241229154740209"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412291548559.png" alt="image-20241229154804518"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>注意！询问时发的是广播包</p>
<p>而对应IP的回答是单播包</p>
</p>
    </div>
</div><h4 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h4>
<p><code>arp -a</code>显示当前的ARP表</p>
<h3 id="交换机"><a class="header-anchor" href="#交换机">¶</a>交换机</h3>
<h4 id="交换机表的生成"><a class="header-anchor" href="#交换机表的生成">¶</a>交换机表的生成</h4>
<p>每当主机通过交换机转发数据时，交换机就会记录当前主机的MAC以及发送的端口，同时设置定时器，以节省内存</p>
<h4 id="交换机转发数据的工作原理"><a class="header-anchor" href="#交换机转发数据的工作原理">¶</a>交换机转发数据的工作原理</h4>
<p>如果交换机表中有对应主机的端口，则直接向目的端口单播，但如果查不到，就对所有端口广播</p>
<h4 id="STP协议的作用"><a class="header-anchor" href="#STP协议的作用">¶</a>STP协议的作用</h4>
<p>即 生成树协议，防止网桥网络中冗余链路出现环路工作。</p>
<h4 id="虚拟局域网-VLAN"><a class="header-anchor" href="#虚拟局域网-VLAN">¶</a>虚拟局域网 VLAN</h4>
<p><mark>一个VLAN = 一个广播域 =一个IP地址网段</mark></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>3-数据链路层-广域网</title>
    <url>/posts/a2e55340.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>相关链接|</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="数据链路层"><a class="header-anchor" href="#数据链路层">¶</a>数据链路层</h3>
<h4 id="比特填充定界法"><a class="header-anchor" href="#比特填充定界法">¶</a>比特填充定界法</h4>
<p>用一组比特作为帧的起始和结束，如$01111110$</p>
<p>利用<strong>0 比特插入法</strong>来解决数据传输透明性的问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发送方在发送数据时，在连续5个1后插入一个0；接收方在接收到连续的5个1后若跟着一个0，删除0。</p>
</li>
</ul>
<h4 id="基本的-span-style-color-red-差错检测-span-方法"><a class="header-anchor" href="#基本的-span-style-color-red-差错检测-span-方法">¶</a>基本的<span style="color:red">差错检测</span>方法</h4>
<h5 id="循环冗余校验码（CRC）"><a class="header-anchor" href="#循环冗余校验码（CRC）">¶</a>循环冗余校验码（CRC）</h5>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282234882.png" alt="image-20241228223413816"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282234490.png" alt="image-20241228223427444"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412282234094.png" alt="image-20241228223445045"></p>
<hr />
<div style="text-align: center;color:#4d648d;font-size:50px;">(完)</div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
</search>
