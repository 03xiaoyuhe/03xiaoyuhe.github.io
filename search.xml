<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CISC架构</title>
    <url>/posts/7436c65f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>CISC（Complex Instruction Set Computer）<strong>架构是一种处理器设计理念，其特点是提供</strong>复杂且多样化的指令集</strong></p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CISC架构的定义"><a class="header-anchor" href="#CISC架构的定义">¶</a><strong>CISC架构的定义</strong></h3>
<p>**CISC（Complex Instruction Set Computer）*<em>架构是一种处理器设计理念，其特点是提供*<em>复杂且多样化的指令集</em></em>，每条指令可以完成多种复杂操作。这种设计理念的目标是通过简化程序的指令数目，减少程序代码量，提高开发效率。</p>
<p>CISC是传统计算机架构的典型代表，如<strong>x86架构</strong>和早期的<strong>VAX</strong>、<strong>IBM System/360</strong>等处理器。</p>
<hr>
<h3 id="CISC架构的特点"><a class="header-anchor" href="#CISC架构的特点">¶</a><strong>CISC架构的特点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>复杂指令集</strong></p>
<ul class="lvl-2">
<li class="lvl-5">每条指令的功能非常强大，可能同时执行多个步骤（如取数、运算、存储）。</li>
<li class="lvl-5">如<code>MOV</code>, <code>ADD</code>, <code>MULT</code>等指令，不仅支持寄存器操作，还支持直接对内存操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令长度不固定</strong></p>
<ul class="lvl-2">
<li class="lvl-5">指令可以是不同长度的字节组合，使得编码更加灵活，但解码复杂。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>丰富的寻址模式</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提供多种内存寻址模式，如立即寻址、直接寻址、间接寻址、基址寻址等，支持对复杂数据结构的直接操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>微码实现</strong></p>
<ul class="lvl-2">
<li class="lvl-5">通常使用**微程序控制器（Microcode Control Unit）**来解码复杂指令，这种方式简化了硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令执行时间较长</strong></p>
<ul class="lvl-2">
<li class="lvl-5">单条指令可能需要多个时钟周期完成，因为其内部可能包含多个微操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>高度依赖内存</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构允许指令直接操作内存，而不是先将数据加载到寄存器，这增加了对内存访问的频率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的优点"><a class="header-anchor" href="#CISC架构的优点">¶</a><strong>CISC架构的优点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>程序代码紧凑</strong></p>
<ul class="lvl-2">
<li class="lvl-5">强大的指令集可以用更少的指令实现复杂功能，减少程序代码量。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>易于编写高层语言编译器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">高级语言中复杂的语句可以直接映射为CISC指令，简化了编译器的设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>向后兼容性强</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构通过扩展指令集可以保持对旧程序的兼容性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适合复杂的计算任务</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令和多样化的寻址模式使其适合复杂的数据处理任务。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的缺点"><a class="header-anchor" href="#CISC架构的缺点">¶</a><strong>CISC架构的缺点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>指令解码复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">不固定的指令长度和复杂的指令集增加了CPU解码指令的难度，降低了效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>执行速度较慢</strong></p>
<ul class="lvl-2">
<li class="lvl-5">一条CISC指令可能需要多个时钟周期完成，无法充分发挥现代高速硬件的性能。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>硬件设计复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">支持多样化指令和寻址模式需要更复杂的硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>能耗较高</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令的实现通常需要更多的电力支持。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC与RISC的对比"><a class="header-anchor" href="#CISC与RISC的对比">¶</a><strong>CISC与RISC的对比</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CISC</strong></th>
<th><strong>RISC（Reduced Instruction Set Computer）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令集</strong></td>
<td>复杂、多样化</td>
<td>简单、固定长度</td>
</tr>
<tr>
<td><strong>指令执行时间</strong></td>
<td>单条指令执行时间长，可能需要多个时钟周期</td>
<td>单条指令执行时间短，通常一个时钟周期完成</td>
</tr>
<tr>
<td><strong>硬件设计</strong></td>
<td>复杂的硬件支持复杂指令集</td>
<td>简化的硬件设计，执行更高效</td>
</tr>
<tr>
<td><strong>代码密度</strong></td>
<td>高，程序代码量少</td>
<td>低，通常需要更多指令完成相同的功能</td>
</tr>
<tr>
<td><strong>能耗</strong></td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td><strong>典型代表</strong></td>
<td>x86, VAX</td>
<td>ARM, MIPS, RISC-V</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="CISC架构的实际应用"><a class="header-anchor" href="#CISC架构的实际应用">¶</a><strong>CISC架构的实际应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>x86处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">现代的PC和服务器大多基于x86架构，该架构是CISC的典型代表。</li>
<li class="lvl-5">如Intel和AMD的处理器均采用该架构。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>嵌入式系统中的老一代处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">如8086、80286处理器，广泛应用于工业控制和嵌入式系统中。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>专用硬件系统</strong></p>
<ul class="lvl-2">
<li class="lvl-5">需要复杂数据处理的场景，如传统银行机房的大型机。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="现代CISC的改进"><a class="header-anchor" href="#现代CISC的改进">¶</a><strong>现代CISC的改进</strong></h3>
<p>尽管CISC架构在指令执行效率上不如RISC，但现代CISC处理器通过以下方式提升性能：</p>
<ol>
<li class="lvl-3">
<p><strong>指令解码优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">使用硬件将CISC复杂指令拆解为更简单的微操作（micro-operations）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>流水线设计</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构中引入RISC的流水线思想，提高指令执行效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多核技术</strong></p>
<ul class="lvl-2">
<li class="lvl-5">增加多核处理能力，弥补单核执行速度的不足。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>缓存优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提高指令和数据缓存的命中率，减少内存访问延迟。</li>
</ul>
</li>
</ol>
<hr>
<p>总结来说，CISC架构通过强大的指令集提供了高度灵活性，特别适合某些需要复杂指令处理的应用场景。尽管其在效率和硬件设计方面有一定劣势，但通过现代优化技术，CISC架构依然在许多领域保持了强大的竞争力。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>footnote使用</title>
    <url>/posts/64648fb9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>写在前面</title>
    <url>/posts/55009.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>写在前面</h1>
<p>这个博客用于发布一些笔者认为需要多端查看的各种笔记，或者用于记录想要分享的各种知识</p>
<p>另外，由于笔者还并没有完全掌握<code>hexo</code>的各种用法，这个博客同时也会记录一些在使用<code>hexo</code>时的个人心得。</p>
<h2 id="博客支持的callout块"><a class="header-anchor" href="#博客支持的callout块">¶</a>博客支持的callout块</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&quot;info&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">&quot;warning&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">&quot;error&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">&quot;success&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">&quot;note&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">&quot;tip&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<div class="callout callout-info">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">INFO</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>嘿，typora不支持这个</p>
</p>
    </div>
</div>
<div class="callout callout-error">
    <div class="callout-head">
        <span class="callout-head-icon">❌</span>
        <span class="callout-head-text" style="color:#d32f2f">ERROR</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>嘿！typora也不支持这个</p>
</p>
    </div>
</div>
<div class="callout callout-success">
    <div class="callout-head">
        <span class="callout-head-icon">✔️</span>
        <span class="callout-head-text" style="color:#2e7d32">SUCCESS</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>好吧，typora支持的内容有点少了</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太好了，typora支持<code>note</code></p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>测试callout</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h2>测试一下是否支持应该支持的 md 语法</h2>
<p>警告！</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p>     $\uparrow  \ \ \ \      \uparrow  \ \ \ \     \uparrow$ 其他所有人</p>
<p>     $\uparrow  \ \ \ \      \uparrow$ 用户组</p>
<p>      $\uparrow$ 文件所有者</p>
<p>普通文本内容，其他段落不受影响。</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p><strong>Markdown 语法支持</strong>：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>列表项 1</p>
</li>
<li class="lvl-2">
<p>列表项 2</p>
</li>
</ul>
<blockquote>
<p>嵌套引用块</p>
</p>
    </div>
</div><p>普通文本内容，其他段落不受影响。</p>
</blockquote>
<h2 id="关于博客中自定义渲染callout块的部分"><a class="header-anchor" href="#关于博客中自定义渲染callout块的部分">¶</a>关于博客中自定义渲染<code>callout</code>块的部分</h2>
<h3 id="首先是callout语法"><a class="header-anchor" href="#首先是callout语法">¶</a>首先是<code>callout</code>语法</h3>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; [!tag]</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content2</span></span><br></pre></td></tr></table></figure>
<p>由于笔者在编写此博客时使用的编写工具是<code>typora</code>，故将原来<code>obsidian</code>的语法做了一些改动，因为<code>typora</code>的引用块，行与行之间也会自动添加空行。<a href="/posts/4179">[关于callout块渲染]</a></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>渲染器部分，详见[[关于callout块渲染]]</p>
</p>
    </div>
</div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!info] 信息头</span><br><span class="line">这是第一行内容。</span><br><span class="line">这是第二行内容。</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>typora破解</title>
    <url>/posts/8fcf3ec6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太逆天了，笔者是在花<big><big>89</big></big>米😕 之后，偶然搜到了这个，虽然已经没用了，但还是摘一下</p>
</p>
    </div>
</div><span id="more"></span>
<p><small>放个error以表愤怒！</small>😠</p>

<div class="callout callout-error">
    <div class="callout-head">
        <span class="callout-head-icon">❌</span>
        <span class="callout-head-text" style="color:#d32f2f">ERROR</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>Typora 是一款由 Abner Lee 开发的轻量级 Markdown 编辑器，适用于 OS X、Windows 和 Linux 三种操作系统。</p>
<p>与其他 Markdown 编辑器不同的是，Typora 没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p>
<p>该软件目前只有 15 天免费试用，后续使用续费付费才行！这里分享一个自己破解的方法！不再从网上下载破解版或者补丁了！</p>
<p>免责声明：本文内容仅为技术分享、交流、探讨，推荐大家支持官方正版软件！</p>
<h2>官网地址</h2>
<p>国外：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmEuaW8v">https://typora.io/</a></p>
<p>国内：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmFpby5jbi8=">https://typoraio.cn/</a></p>
<h2>省流步骤</h2>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 <code>\ resources\page-dist\static\js\LicenseIndex.xxxxxxxxx.xxxxxxx.chunk.js</code>，激活主程序</p>
</li>
</ol>
<p>查找：<code>e.hasActivated=&quot;true&quot;==e.hasActivated,</code></p>
<p>替换：<code>e.hasActivated=&quot;true&quot;==&quot;true&quot;,</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\page-dist\license.html，关闭每次启动时的已激活弹窗</p>
</li>
</ol>
<p>查找：<code>&lt;/body&gt;&lt;/html&gt;</code>替换：<code>&lt;/body&gt;&lt;script&gt;window.onload=function()&#123;setTimeout(()=&gt;&#123;window.close();&#125;,5);&#125;&lt;/script&gt;&lt;/html&gt;</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\locales\zh-Hans.lproj\Panel.json，去除左下角 “未激活” 提示（不完美方案，仅去除文字，小框框还在）</p>
</li>
</ol>
<p>查找：<code>&quot;UNREGISTERED&quot;:&quot;未激活&quot;</code></p>
<p>替换：<code>&quot;UNREGISTERED&quot;:&quot; &quot;</code></p>
<h2>最后总结</h2>
<ul class="lvl-1">
<li class="lvl-2">
<p>我的许可证页面无法查看</p>
</li>
<li class="lvl-2">
<p>左下角关闭的小框还存在</p>
</li>
<li class="lvl-2">
<p>其他平台如 MAC，Linux 参考本文自己摸索一下</p>
</li>
<li class="lvl-2">
<p>一旦程序启动崩溃，可能是替换时有误操作，重新安装再尝试</p>
</li>
<li class="lvl-2">
<p>随着新版本更新，可能该方法会失效，亲测 1.7.6 没有问题</p>
</li>
</ul>
<p>—— <a href="https://blog.captainz.cc/posts/typora_crack.html">自己动手破解 Markdown 软件 Typora，支持官网最新版 | Hyper Tech</a></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>一条指令在执行期间，可能产生多次缺页中断</title>
    <url>/posts/52e033e8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>一条指令在执行期间，可能产生多次缺页中断 的详细解析</p>
</p>
    </div>
</div><span id="more"></span>
<p>是的，一条指令在执行期间<strong>可能产生多次缺页中断</strong>。这是因为指令的执行可能涉及到多个内存地址的访问，而每个地址的访问都有可能导致缺页中断。以下是几种可能导致这种情况的场景：</p>
<hr>
<h3 id="1-指令本身产生的缺页中断"><a class="header-anchor" href="#1-指令本身产生的缺页中断">¶</a><strong>1. 指令本身产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>指令取指</strong><br>
CPU在执行一条指令时，需要从内存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="2-操作数访问导致的缺页中断"><a class="header-anchor" href="#2-操作数访问导致的缺页中断">¶</a><strong>2. 操作数访问导致的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>直接操作数</strong><br>
如果指令使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>间接访问（如指针或数组访问）</strong><br>
指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="3-指令操作多次访问内存"><a class="header-anchor" href="#3-指令操作多次访问内存">¶</a><strong>3. 指令操作多次访问内存</strong></h3>
<p>一些复杂指令（尤其在CISC架构中）可能在执行期间涉及多个内存访问，每次访问都可能触发缺页中断。例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<hr>
<h3 id="4-页表访问产生的缺页中断"><a class="header-anchor" href="#4-页表访问产生的缺页中断">¶</a><strong>4. 页表访问产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="5-内存管理器的间接操作"><a class="header-anchor" href="#5-内存管理器的间接操作">¶</a><strong>5. 内存管理器的间接操作</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
<hr>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h3>
<p>假设有一条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i] = b[j] + c[k];</span><br></pre></td></tr></table></figure>
<p>执行这条指令可能涉及以下几个内存访问：</p>
<ol>
<li class="lvl-3">
<p>取出指令本身（指令所在页面可能触发缺页中断）。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>a</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>b</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>c</code>的地址。</p>
</li>
<li class="lvl-3">
<p>访问<code>b[j]</code>的值。</p>
</li>
<li class="lvl-3">
<p>访问<code>c[k]</code>的值。</p>
</li>
<li class="lvl-3">
<p>写入<code>a[i]</code>。</p>
</li>
</ol>
<p>如果这些访问的页面都未加载到主存，则可能触发<strong>多次缺页中断</strong>。</p>
<hr>
<h3 id="如何缓解缺页中断带来的开销"><a class="header-anchor" href="#如何缓解缺页中断带来的开销">¶</a><strong>如何缓解缺页中断带来的开销</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>预取机制</strong><br>
操作系统可预测程序的访问模式，提前将相关页面加载到主存，减少缺页中断。</p>
</li>
<li class="lvl-3">
<p><strong>使用更大的页面（大页）</strong><br>
使用大页面（如2MB或1GB）可以减少页表项数量，降低缺页中断概率。</p>
</li>
<li class="lvl-3">
<p><strong>优化程序内存访问模式</strong><br>
开发者可以优化数据结构和算法，尽量减少跨页面访问。</p>
</li>
<li class="lvl-3">
<p><strong>TLB优化</strong><br>
提高页表缓存（TLB）的命中率，加快地址转换速度。</p>
</li>
</ol>
<hr>
<p>综上，虽然一条指令可能导致多次缺页中断，但通过合理的内存管理策略和优化，可以有效降低缺页中断的频率，提高系统性能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 callout 块渲染</title>
    <url>/posts/4179.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下<code>callout</code>支持过程。</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="初期想法"><a class="header-anchor" href="#初期想法">¶</a>初期想法</h2>
<p>因为<code>hexo</code>支持<code>markdown</code>基础语法，而笔者在使用<code>hexo</code>之前，恰好使用过<code>Obsidian</code>笔记软件，非常喜欢使用<code>Obsidian</code>中的<code>Callout</code>块。</p>
<p>但发现网上并没有相关解决方案，虽然可以使用自定义代码块的方式书写类似<code>callout</code>块的效果，但是这样就和当前使用的<code>markdown</code>编辑器不兼容，而且自定义代码块的样式并不好看。<small><del>笔者还是比较喜欢即写即渲染的编辑模式</del></small></p>
<p>所以，笔者就想提供一个专门用于渲染<code>callout</code>块的自定义渲染器，<small>笔者曾经写过一个<code>python</code>的<code>md</code>渲染器，就在书写本文章不久前，也是为了解决<code>callout</code>块问题</small></p>
<p><small><del>笔者对<code>callout</code>还是非常喜爱的</del></small></p>
<h2 id="实际实现"><a class="header-anchor" href="#实际实现">¶</a>实际实现</h2>
<p>首先，安装<code>hexo-renderer-markdown-it</code> 以及 <code>markdown-it-container</code> 插件来扩展 <code>Markdown</code> 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-container --save</span><br></pre></td></tr></table></figure>
<p>在 <code>hexo-renderer-markdown-it</code> 配置中启用容器解析： 修改 <code>Hexo</code> 的 <code>_config.yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-container</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时，<code>hexo</code>已经支持运行自定义的<code>markdown</code>了。</p>
<p>接下来，我们书写<code>callout</code>渲染器。</p>
<p><small><del>其实笔者在该部分废了老大的劲</del></small></p>
<p>我先贴下代码</p>
<h3 id="自定义渲染器代码"><a class="header-anchor" href="#自定义渲染器代码">¶</a>自定义渲染器代码</h3>
<p><small>二编了🤡代码最终还是没躲过bug，当然鲁棒性肯定更高了</small></p>
<p><small>三编了，这次是加了支持表情符的功能，这个也是typora支持的😴</small></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iconConfig = &#123;</span><br><span class="line">    <span class="string">&quot;info&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;warning&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;error&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;success&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;note&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;tip&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadIcon</span>(<span class="params">iconName</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[iconName] || iconConfig[<span class="string">&quot;info&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;span class=&quot;callout-head-icon&quot;&gt;<span class="subst">$&#123;iconInfo.icon&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateCalloutHTML</span>(<span class="params">type, tokens, state</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> md = <span class="built_in">require</span>(<span class="string">&#x27;markdown-it&#x27;</span>)(&#123;</span><br><span class="line">        <span class="attr">html</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">linkify</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">typographer</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">breaks</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">xhtmlOut</span>: <span class="literal">false</span></span><br><span class="line">    &#125;).<span class="title function_">use</span>(<span class="built_in">require</span>(<span class="string">&#x27;markdown-it-emoji&#x27;</span>)); <span class="comment">// 添加 Emoji 插件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123; ...state.<span class="property">options</span>, <span class="attr">breaks</span>: <span class="literal">true</span>, <span class="attr">xhtmlOut</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> wrappedTokens = [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_open&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: <span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        ...tokens,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_close&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: -<span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> calloutBody = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        calloutBody = md.<span class="property">renderer</span>.<span class="title function_">render</span>(wrappedTokens, options, state.<span class="property">env</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Callout rendering error:&quot;</span>, error);</span><br><span class="line">        calloutBody = <span class="string">&quot;&lt;!-- Render Error --&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[type] || iconConfig[<span class="string">&quot;info&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;callout callout-<span class="subst">$&#123;type&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-head&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;loadIcon(type)&#125;</span></span></span><br><span class="line"><span class="string">        &lt;span class=&quot;callout-head-text&quot; style=&quot;color:<span class="subst">$&#123;iconInfo.color&#125;</span>&quot;&gt;<span class="subst">$&#123;type.toUpperCase()&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-contents&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;calloutBody&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown-it:renderer&#x27;</span>, <span class="keyword">function</span> (<span class="params">md</span>) &#123;</span><br><span class="line">    md.<span class="property">core</span>.<span class="property">ruler</span>.<span class="title function_">push</span>(<span class="string">&#x27;render_callout&#x27;</span>, <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tokens = state.<span class="property">tokens</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = tokens.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;blockquote_open&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> blockquoteTokens = [];</span><br><span class="line">                <span class="keyword">while</span> (tokens[j] &amp;&amp; tokens[j].<span class="property">type</span> !== <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    blockquoteTokens.<span class="title function_">push</span>(tokens[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tokens[j]?.<span class="property">type</span> === <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> calloutType = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">const</span> calloutBodyTokens = [];</span><br><span class="line">                    blockquoteTokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;inline&#x27;</span> &amp;&amp; !calloutType) &#123;</span><br><span class="line">                            <span class="keyword">const</span> match = token.<span class="property">content</span>.<span class="title function_">match</span>(<span class="regexp">/\[!(\w+)]/</span>);</span><br><span class="line">                            <span class="keyword">if</span> (match) calloutType = match[<span class="number">1</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            calloutBodyTokens.<span class="title function_">push</span>(token);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (calloutType) &#123;</span><br><span class="line">                        <span class="keyword">const</span> calloutHtml = <span class="title function_">generateCalloutHTML</span>(calloutType, calloutBodyTokens, state);</span><br><span class="line">                        token.<span class="property">type</span> = <span class="string">&#x27;html_block&#x27;</span>;</span><br><span class="line">                        token.<span class="property">content</span> = calloutHtml;</span><br><span class="line">                        tokens.<span class="title function_">splice</span>(i + <span class="number">1</span>, j - i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><small>其实在阅读这段代码我们能够发现，这段脚本支持用户自定义自己喜欢的callout块，这是后话</small></p>
<p><small>二编：发现有<code>hexo</code>有时候会报<code>breaks</code>和<code>xhtmlOut</code>的错，最后看了一下详细的报错信息发现和这个<code>callout</code>脱不了干系，果不其然要改了😰</small></p>
<h3 id="代码放置位置"><a class="header-anchor" href="#代码放置位置">¶</a>代码放置位置</h3>
<p><strong>然后就是代码的放置位置</strong>，虽然笔者并不了解<code>hexo</code></p>
<ol>
<li class="lvl-3">
<p>总之，在你的<em>博客根目录</em><br>
<small>(虽然不知道博客根目录是否难懂，但如果跟着教程配好了博客的人一定都很聪明)</small></p>
</li>
<li class="lvl-3">
<p>新建一个<code>scripts</code>文件夹<small>当然，也可能有的大佬已经有了，<del>萌新瑟瑟发抖</del></small></p>
</li>
<li class="lvl-3">
<p>然后在该文件夹下新建文件<code>markdown-it-callout.js</code><small>当然，笔者的文件名取的是这个，但并不清楚其他名字是否可用</small></p>
</li>
<li class="lvl-3">
<p>然后把上面那段<code>callout</code>渲染代码贴进去</p>
</li>
</ol>
<h3 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义css样式</h3>
<p>然后由于笔者使用的callout块是自己渲染的，需要<strong>自定义css样式</strong></p>
<p>这个部分在<a href="/posts/d9cd1415">客制化css</a>有详细介绍</p>
<h3 id="支持表情符部分"><a class="header-anchor" href="#支持表情符部分">¶</a>支持表情符部分</h3>
<h4 id="安装-markdown-it-emoji-插件"><a class="header-anchor" href="#安装-markdown-it-emoji-插件">¶</a>安装 <code>markdown-it-emoji</code> 插件</h4>
<p>使用 npm 安装 <code>markdown-it-emoji</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install markdown-it-emoji</span><br></pre></td></tr></table></figure>
<p>当然，如果不喜欢表情符的话，可以把<code>.use(require('markdown-it-emoji')</code>删除。</p>
<hr>
<p>然后！<big>然后！<big>然后！</big></big>你就获得了一个可以渲染<code>callout</code>的<code>hexo</code></p>
<h2 id="然后就是效果展示了"><a class="header-anchor" href="#然后就是效果展示了">¶</a>然后就是效果展示了</h2>
<p>其实看<a href="/posts/55009">写在前面</a>就可以了</p>
<hr>
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
]]></content>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo插件hexo-graph的使用</title>
    <url>/posts/1bd5413e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记一下文章&quot;关于&quot;页的书写</p>
<p>插件地址<a href="https://github.com/codepzj/hexo-graph">codepzj/hexo-graph: hexo-graph，一个基于echarts，集成博客热力图，博客月份统计图，分类统计图，标签统计图的多元化插件。</a></p>
</p>
    </div>
</div><span id="more"></span>
<p>略</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>折腾 hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客中使用的脚注功能</title>
    <url>/posts/c6910d47.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下博客中脚注配置的相关内容</p>
</p>
    </div>
</div><span id="more"></span>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<ol>
<li class="lvl-3">打开 hexo 官方插件页面 <a href="https://hexo.io/plugins/">Plugins</a></li>
<li class="lvl-3">搜索 <code>footnotes</code> 并安装 <a href="https://github.com/kchen0x/hexo-reference">hexo-reference</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure>
<p>配置根目录 <code>_config.yml</code> 文件，新增一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-reference</span><br></pre></td></tr></table></figure>
<h4>参考文档</h4>
<p><a href="https://kchen.cc/2016/11/10/footnotes-in-hexo/#fnref:4">Hexo 里的脚注插件</a></p>
<p>—— 摘自 <a href="https://toypipi.github.io/2024/05/10/hexo-%E5%A2%9E%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%8A%9F%E8%83%BD/">hexo 增加脚注功能 | Toypipi’s blog</a></p>
</p>
    </div>
</div><h2 id="修改footnote脚注样式"><a class="header-anchor" href="#修改footnote脚注样式">¶</a>修改footnote脚注样式</h2>
<p>由于笔者实在是不太喜欢<code>hexo-reference</code>提供的红色的<code>footnote</code>然后鉴于笔者是使用插件渲染<code>footnote</code>的，所以笔者就准备对插件的代码做一下改造：</p>
<ol>
<li class="lvl-3">
<p>我们先进入博客根目录下的<code>/node_modules/hexo-reference</code></p>
<p><small>没错，笔者准备对这个插件进行修改</small></p>
</li>
<li class="lvl-3">
<p>然后查看文件<code>index.js</code></p>
<p><small>不出意外的话这个一般是插件的入口文件</small></p>
<p>我们看到这个文件前有一段<code>js</code>引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renderFootnotes = <span class="built_in">require</span>(<span class="string">&#x27;./src/footnotes&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没错，笔者在看完其后代码之后认为核心渲染程序应该在</p>
<p><code>./src/footnotes</code></p>
</li>
<li class="lvl-3">
<p>然后我们找到这个文件，即插件根目录下的<code>/src/footnotes.js</code>文件，笔者打开了它并把<code>hint--error</code>给删了</p>
</li>
<li class="lvl-3">
<p>然后就好了</p>
</li>
</ol>
<p><small>其实笔者在记录过程是一边做一边写的，<u>所幸笔者猜对了</u></small></p>
<p><small>Oops! 笔者在阅读代码的时候发现这个插件好像依赖插件<code>markdown-it</code></small></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>折腾hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本博客的客制化css</title>
    <url>/posts/d9cd1415.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>当然是记一些关于本博客客制化<code>css</code>相关的内容啦</p>
</p>
    </div>
</div><span id="more"></span>
<p><strong>由于之前说到<a href="/posts/4179">用自定义渲染器渲染<code>callout</code></a></strong></p>
<p>但是其中其实还有一个问题有待解决：</p>
<p><big>如何将自定义的<code>callout</code>样式块渲染出来</big></p>
<p><small>这里指的是，<code>Markdown</code>已经成功的转换成显示在网站中的<code>html</code>代码块了</small></p>
<p>但是实际上我们发现，解析的<code>html</code>我们确实有了，但是<code>callout</code>并非是我们想要的样式，而是一个并没有进行任何着色的状态。</p>
<h2 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义<code>css</code>样式</h2>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>2.1 添加客制化css</h3>
<p>虽然在<code>css</code>目录下任意<code>.styl</code>下添加<code>css</code>样式代码可以生效，但是为了方便以后修改，最好创建一个新的<code>.styl</code>文件记录自己的修改。</p>
<ol>
<li class="lvl-3">
<p>在<code>themes/next/source/css/main.styl</code>最后加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;_custom/custom&quot;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>在<code>themes/next/source/css</code>目录下创建<code>_custom</code>文件夹；</p>
</li>
<li class="lvl-3">
<p>在目录<code>themes/next/source/css/_custom</code>下新建文件<code>custom.styl</code>。</p>
</li>
<li class="lvl-3">
<p>在<code>custom.styl</code>中添加<code>css</code>样式修改博客的<code>css</code>。</p>
</li>
</ol>
<p>—— 摘自 <a href="https://zachary116699.github.io/2024/05/09/hexo-next-css/">hexo-next主题配置css | 大水笔✰档案室</a></p>
</p>
    </div>
</div><p>然后就是将自己自定义的<code>css</code>样式放在里面</p>
<p>这里贴一下<code>callout</code>样式部分：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基础样式 */</span></span><br><span class="line"><span class="selector-class">.callout</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">4px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Info 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-info</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#3178c6</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e3f2fd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Warning 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-warning</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#e5a700</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff3e0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Error 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-error</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#d32f2f</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffebee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Success 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-success</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#2e7d32</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e8f5e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-note</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#673ab7</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ede7f6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tip 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-tip</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#009688</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0f2f1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，就好了，现在整个<code>callout</code>块的部分就完整了🙌</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾hexo</title>
    <url>/posts/8dc8b2ab.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>操作系统第六章复习</title>
    <url>/posts/b90b7ae5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一下操作系统第六章复习笔记吧</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="虚拟存储器的概念"><a class="header-anchor" href="#虚拟存储器的概念">¶</a>虚拟存储器的概念</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>局部性原理</p>
</li>
<li class="lvl-2">
<p>虚拟存储器的概念</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>局部性的特征体现</p>
</li>
<li class="lvl-3">
<p>理解虚拟存储器</p>
</li>
<li class="lvl-3">
<p>虚拟存储器的容量</p>
</li>
</ol>
<h3 id="虚拟存储器的任务"><a class="header-anchor" href="#虚拟存储器的任务">¶</a>虚拟存储器的任务</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>逻辑上扩充内存容量</p>
</li>
</ul>
<h3 id="局部性原理"><a class="header-anchor" href="#局部性原理">¶</a>局部性原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间局部性：</p>
<p>一条指令被执行了，则在不久的将来它可能再被执行。</p>
</li>
<li class="lvl-2">
<p>空间局部性：</p>
<p>若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。</p>
</li>
</ul>
<blockquote>
<p>只需要让程序当前需要运行的内容存在于内存中，程序就能跑</p>
</blockquote>
<h3 id="虚拟存储器的定义"><a class="header-anchor" href="#虚拟存储器的定义">¶</a>虚拟存储器的定义</h3>
<p>具有请求调入功能<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--info hint--rounded hint--bounce" aria-label="调入功能 是 指将进程所需的数据或指令从磁盘调入主存
">[1]</span></a></sup>和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<p><big>虚拟存储器的容量 = $min($ 内存 $+$ 外存 $,$ <code>cpu</code>寻址空间 $)$ </big></p>
<h3 id="虚拟存储器的特征"><a class="header-anchor" href="#虚拟存储器的特征">¶</a>虚拟存储器的特征</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>多次性</p>
</li>
<li class="lvl-2">
<p>对换性</p>
</li>
<li class="lvl-2">
<p>虚拟性</p>
</li>
</ul>
<h3 id="虚拟存储器的实现"><a class="header-anchor" href="#虚拟存储器的实现">¶</a>虚拟存储器的实现</h3>
<h4 id="请求分页系统"><a class="header-anchor" href="#请求分页系统">¶</a>请求分页系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：页表、缺页中断、地址变换机构</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调页软件、页面置换软件</p>
</li>
</ul>
<h4 id="请求分段系统"><a class="header-anchor" href="#请求分段系统">¶</a>请求分段系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：段表、缺段中断、地址变换机构。</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调段软件、段置换软件。</p>
</li>
</ul>
<h4 id="段页式虚拟存储器"><a class="header-anchor" href="#段页式虚拟存储器">¶</a>段页式虚拟存储器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>增加请求调页和页面置换。</p>
</li>
</ul>
<h2 id="请求分页存储管理"><a class="header-anchor" href="#请求分页存储管理">¶</a>请求分页存储管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101903431.png" alt="image-20241210190318202"></p>
<h3 id="目标评价"><a class="header-anchor" href="#目标评价">¶</a>目标评价</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0"><label for="checkbox0">请求分页中的页表需要如何修改？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1"><label for="checkbox1">缺页中断有何特点？缺页中断如何处理？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2"><label for="checkbox2">请求分页管理中地址转换如何完成？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3"><label for="checkbox3">页面置换算法有哪些？如何完成页面置换？有何特点？缺页率如何计算？</label></p>
</li>
</ul>
<h3 id="硬件支持"><a class="header-anchor" href="#硬件支持">¶</a>硬件支持</h3>
<h4 id="页表机制"><a class="header-anchor" href="#页表机制">¶</a>页表机制</h4>
<p>需要在进程页表<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--info hint--rounded hint--bounce" aria-label="进程页表 是操作系统管理虚拟存储器时，用于映射进程的 **虚拟地址**和 **物理地址** 的一个重要数据结构。<br>每个进程都有自己的 **页表** ，它记录了该进程所有虚拟页的相关信息，<br>包括虚拟页是否已被加载到主存以及其对应的物理页框地址。
">[2]</span></a></sup>中添加若干项</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态位P：指示该页是否在内存</p>
</li>
<li class="lvl-2">
<p>访问字段A：记录该页在一段时间内被访问的次数</p>
</li>
<li class="lvl-2">
<p>修改位M：也称脏位，标志该页是否被修改过</p>
</li>
<li class="lvl-2">
<p>外存地址：指示该页在外存中的地址（物理块号）</p>
</li>
</ul>
<h4 id="缺页中断机构"><a class="header-anchor" href="#缺页中断机构">¶</a>缺页中断机构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>在指令执行期间产生和处理中断信号</p>
</li>
<li class="lvl-2">
<p>一条指令在执行期间，可能产生多次缺页中断</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于 <em><a href="/posts/52e033e8"><code>一条指令在执行期间，可能产生多次缺页中断</code></a></em></h4>
<h4>指令本身产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>指令取指</strong></p>
<p><code>cpu</code>在只从一条指令时，需要从主存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<h4>操作数访问导致的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>直接操作数</strong></p>
<p>如果指令是使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断</p>
</li>
<li class="lvl-2">
<p><strong>间接访问</strong></p>
<p>指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断</p>
</li>
</ul>
<h4>指令操作多次访问内存</h4>
<p>一些复杂的指令（尤其在<a href="/posts/7436c65f">CISC架构</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--medium hint--info hint--rounded hint--bounce" aria-label="**CISC（Complex Instruction Set Computer）** 架构是一种处理器设计理念，其特点是提供 **复杂且多样化的指令集**
">[3]</span></a></sup>中）可能在执行期间涉及多个内存访问，每次访问可能触发缺页中断。例如：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<h4>页表访问产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<h4>内存管理器的间接操作</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="缺页中断的特殊性"><a class="header-anchor" href="#缺页中断的特殊性">¶</a>缺页中断的特殊性</h4>
<p>缺页中断在指令执行期间产生和进行处理，而不是在一条指令执行完毕之后。所缺的页面调入之后，重新执行被中断的指令</p>
<h4 id="地址变换机构"><a class="header-anchor" href="#地址变换机构">¶</a>地址变换机构</h4>
<p>与分页内存管理方式类似</p>
<p>由逻辑地址检索页表，根据对应页表项的标志位判断，若在内存中，则直接形成物理地址。</p>
<p>如不在内存中，产生缺页中断，从对应页表项的外存地址，从外存找到该页，内存满，则选择页面换出，否则从外存直接调入内存。完成地址转换。<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412102029580.png" alt="image-20241210202946621"></p>
<h4 id="内存分配"><a class="header-anchor" href="#内存分配">¶</a>内存分配</h4>
<h5 id="最小物理块数的确定"><a class="header-anchor" href="#最小物理块数的确定">¶</a>最小物理块数的确定</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>保证进程正常运行所需的最小物理块数</p>
</li>
</ul>
<h5 id="物理块的分配策略"><a class="header-anchor" href="#物理块的分配策略">¶</a>物理块的分配策略</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配，局部置换</p>
</li>
<li class="lvl-2">
<p>可变分配，全局置换</p>
</li>
<li class="lvl-2">
<p>可变分配，局部置换</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/907f4c43">物理块的分配策略</a></p>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><h5 id="物理块分配算法"><a class="header-anchor" href="#物理块分配算法">¶</a>物理块分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>平均分配算法</p>
</li>
<li class="lvl-2">
<p><span style="color: red">按比例分配算法</span></p>
</li>
<li class="lvl-2">
<p>考虑优先权的分配算法</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/8ba68849">物理块分配算法</a></p>
<p><strong>对比总结</strong></p>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><h4 id="调页策略"><a class="header-anchor" href="#调页策略">¶</a>调页策略</h4>
<h5 id="何时调入页面"><a class="header-anchor" href="#何时调入页面">¶</a>何时调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>预调页策略：预先调入一些页面到内存</p>
</li>
<li class="lvl-2">
<p>请求调页策略：发现需要访问的页面不在内存时，调入内存</p>
</li>
</ul>
<h5 id="从何处调入页面"><a class="header-anchor" href="#从何处调入页面">¶</a>从何处调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>如系统拥有足够的对换区空间，全部从对换区调入所需页面</p>
</li>
<li class="lvl-2">
<p>如系统缺少足够的对换区空间，凡是不会被修改的文件，都直接从文件区调入</p>
<p>当换出这些页面时，由于未被修改而不必再将它们重写磁盘，以后再调入时，仍从文件区直接调入</p>
</li>
<li class="lvl-2">
<p>UNIX方式：未运行过的页面，从文件区调入；曾经运行过但又被换出的页面，从对换区调入</p>
</li>
</ul>
<h5 id="span-style-color-red-如何调入页面-span"><a class="header-anchor" href="#span-style-color-red-如何调入页面-span">¶</a><span style="color:red">如何调入页面</span></h5>
<ol>
<li class="lvl-3">
<p>查找所需页在磁盘上的位置</p>
</li>
<li class="lvl-3">
<p>查找一内存空闲块：</p>
<ul class="lvl-2">
<li class="lvl-5">如果有空闲块，就直接使用它</li>
<li class="lvl-5">如果没有空闲块，使用页面置换算法选择一个&quot;牺牲&quot;内存块</li>
<li class="lvl-5">将“牺牲”块的内容写到磁盘上，更新页表和物理块表</li>
</ul>
</li>
<li class="lvl-3">
<p>将所需页读入新空闲块，更新页表</p>
</li>
<li class="lvl-3">
<p>重启用户进程</p>
</li>
</ol>
<h5 id="缺页率"><a class="header-anchor" href="#缺页率">¶</a>缺页率</h5>
<p>缺页率的计算：<br>
$$<br>
f= F/A<br>
$$</p>
<center><small>s为访问页面成功<small>(在内存中)</small>次数</small></center>
<center><small>F为访问页面失败<small>(不在内存)</small>次数</small></center>
<center><small>A为总访问次数 A = s+F</small></center>
<ul class="lvl-0">
<li class="lvl-2">
<p>影响因素：页面大小、分配内存块的数目、页面置换算法、程序固有属性</p>
</li>
</ul>
<p>缺页中断处理的时间：</p>
<p>$$<br>
t = β×t_a + (1- β)×t_b<br>
$$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>例子</h5>
<p>存取内存的时间= 200 nanoseconds (ns)</p>
<p>平均缺页处理时间 = 8 milliseconds (ms)</p>
<p><em>t</em> = (1 – p) × 200ns + p × 8ms</p>
<p>= (1 – p) × 200ns + p ×8,000,000ns</p>
<p>= 200ns + p × 7,999,800ns</p>
<p>如果每1,000次访问中有一个缺页中断，那么：</p>
<p><em>t</em> = 8.2 ms</p>
<p><strong>这是导致计算机速度放慢</strong> <strong>40</strong> <strong>倍的影响因子！</strong></p>
</p>
    </div>
</div><h4 id="页面置换算法"><a class="header-anchor" href="#页面置换算法">¶</a>页面置换算法</h4>
<p><strong>功能</strong>：需要调入页面时，选择内存中年哪个物理页面被置换。称为replacement policy<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--medium hint--info hint--rounded hint--bounce" aria-label="policy：/ˈpɒləsi/ n.  策略；方针；
">[4]</span></a></sup></p>
<p><small><strong>目标</strong>：把未来不再使用的或短期内较少使用的页面调出，通常只能在局部性原理指导下依据过去的统计数据进行预测；</small></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>算法一览</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>最佳算法(<strong>OPT</strong>, optimal)</p>
</li>
<li class="lvl-2">
<p>先进先出算法(<strong>FIFO</strong>)</p>
</li>
<li class="lvl-2">
<p>最近最久未使用算法(<strong>LRU</strong>, Least Recently Used)</p>
</li>
<li class="lvl-2">
<p>轮转算法(clock)</p>
</li>
<li class="lvl-2">
<p>最不常用算法(<strong>LFU</strong>, Least Frequently Used)</p>
</li>
<li class="lvl-2">
<p>页面缓冲算法(page buffering)</p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最佳置换算法-OPT"><a class="header-anchor" href="#最佳置换算法-OPT">¶</a>最佳置换算法 OPT</h5>
<p>被置换的页将是之后最长时间不被使用的页</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111512688.png" alt="image-20241211151237943"></p>
<p>无法实现的算法，可用来评价其他算法</p>
<h5 id="先进先出置换算法"><a class="header-anchor" href="#先进先出置换算法">¶</a>先进先出置换算法</h5>
<p><span style="color:red">总是淘汰最先进入内存的页面</span>，即选择在内存中驻留时间最久的页面予以淘汰</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111515908.png" alt="image-20241211151558420"></p>
<p>性能较差。较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。并且有Belady现象。</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady<sup id="fnref:5"><a href="#fn:5" rel="footnote">&lt;span class=“hint–top hint–medium hint–info hint–rounded hint–bounce” aria-label=&quot;贝拉迪：贝拉迪异常（Belady’s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误</h4>
</p>
    </div>
</div><p>&quot;&gt;[5]</span></a></sup>现象</p>
<blockquote>
<p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。</p>
<h4 id="Belady-sup-id-fnref-5-a-href-fn-5-rel-footnote-span-class-“hint–top-hint–medium-hint–info-hint–rounded-hint–bounce”-aria-label-贝拉迪：贝拉迪异常（Belady’s-anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误"><a class="header-anchor" href="#Belady-sup-id-fnref-5-a-href-fn-5-rel-footnote-span-class-“hint–top-hint–medium-hint–info-hint–rounded-hint–bounce”-aria-label-贝拉迪：贝拉迪异常（Belady’s-anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误">¶</a>Belady<sup id="fnref:5"><a href="#fn:5" rel="footnote">&lt;span class=“hint–top hint–medium hint–info hint–rounded hint–bounce” aria-label=&quot;贝拉迪：贝拉迪异常（Belady’s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误</h4>
</blockquote>
<p>&quot;&gt;[5]</span></a></sup>现象的描述</p>
<blockquote>
<p>一个进程P要访问M个页，OS分配N个内存页面给进程P；对一个访问序列S，发生缺页次数为PE（S,N）。当N增大时，PE(S, N)时而增大，时而减小。</p>
<h4 id="Belady-sup-id-fnref-5-a-href-fn-5-rel-footnote-span-class-“hint–top-hint–medium-hint–info-hint–rounded-hint–bounce”-aria-label-贝拉迪：贝拉迪异常（Belady’s-anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误-2"><a class="header-anchor" href="#Belady-sup-id-fnref-5-a-href-fn-5-rel-footnote-span-class-“hint–top-hint–medium-hint–info-hint–rounded-hint–bounce”-aria-label-贝拉迪：贝拉迪异常（Belady’s-anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误-2">¶</a>Belady<sup id="fnref:5"><a href="#fn:5" rel="footnote">&lt;span class=“hint–top hint–medium hint–info hint–rounded hint–bounce” aria-label=&quot;贝拉迪：贝拉迪异常（Belady’s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误</h4>
</blockquote>
<p>&quot;&gt;[5]</span></a></sup>现象的原因</p>
<blockquote>
<p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的。</p>
<blockquote>
<p>反而，先加载进去的页面可能是访问次数最多的，如c语言中，定义的函数往往放在<code>main</code>函数<small>程序入口之前</small>，而且当函数调用另一个函数时，被调用的函数必须放在当前函数之前。</p>
</blockquote>
</blockquote>

<div class="callout callout-info">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">INFO</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady现象的例子</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>进程P有5页程序访问页的顺序为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5；</p>
</li>
<li class="lvl-2">
<p>如果在内存中分配3个页面，则缺页情况如下：12次访问中有缺页9次；</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111539081.png" alt="image-20241211153920646"></p>
</li>
<li class="lvl-2">
<p>如果在内存中分配4个页面，则缺页情况如下：12次访问中有缺页10次</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111540590.png" alt="image-20241211154006562"></p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最近最久未使用-LRU"><a class="header-anchor" href="#最近最久未使用-LRU">¶</a>最近最久未使用 LRU</h5>
<p>选择内存中<span style="color:blue;">最久未使用的页面</span>被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111631081.png" alt="image-20241211163148299"></p>
<h6 id="硬件支持-2"><a class="header-anchor" href="#硬件支持-2">¶</a>硬件支持</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>寄存器</p>
<p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个<a href="/posts/3d2c198d">移位寄存器</a><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--medium hint--info hint--rounded hint--bounce" aria-label="**移位寄存器**（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。">[6]</span></a></sup>，可表示为<br>
$$<br>
R=R_{n-1}R_{n-2}R_{n-3}…R_2R_1R_0<br>
$$</p>
<p><strong>某进程具有</strong> <strong>8</strong> <strong>个页面时的</strong> <strong>LRU</strong> <strong>访问情况</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111652427.png" alt="image-20241211165224336"></p>
</li>
<li class="lvl-2">
<p>栈</p>
<p>用栈保存时，栈的变换情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111656423.png" alt="image-20241211165630180"></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现<small><a href="/posts/f041ded5">详细实现过程</a></small></h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><h5 id="Clock置换算法"><a class="header-anchor" href="#Clock置换算法">¶</a>Clock置换算法</h5>
<p>LRU的近似算法，又称最近未用(NRU)或二次机会页面置换算法</p>
<h6 id="简单的Clock算法"><a class="header-anchor" href="#简单的Clock算法">¶</a>简单的Clock算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页都与一个访问位相关联，初始值为0</p>
</li>
<li class="lvl-2">
<p>当页被访问时置访问位为1</p>
</li>
<li class="lvl-2">
<p>置换时选择访问位为0的页 ；若为1，重新置为0</p>
</li>
</ul>
<p><left><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111709272.png" alt="image-20241211170935261" style="zoom:45%;" /></left><br>
<right><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111714913.png" alt="image-20241211171426161" style="zoom:45%;" /></right></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>像是时钟一样，在需要进行页表置换时，转着圈访问上图所示的访问位</p>
<p><small>若顺时针</small></p>
<p>当转到每一个访问位时，如果当前转到的访问位的值为1，则将该访问位置为0，然后接着访问下一个访问位</p>
<p>直到遇到第一个为0的访问位，则将该访问位对应的页表换出。</p>
</p>
    </div>
</div><h6 id="改进Clock置换算法"><a class="header-anchor" href="#改进Clock置换算法">¶</a>改进Clock置换算法</h6>
<p>除须考虑页面的使用情况外，还须增加置换代价</p>
<p>淘汰时，同时检查访问位A与修改位M</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><div id="footnotelist"><h5>相关脚注</h5><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">调入功能 是 指将进程所需的数据或指令从磁盘调入主存<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">进程页表 是操作系统管理虚拟存储器时，用于映射进程的 <strong>虚拟地址</strong>和 <strong>物理地址</strong> 的一个重要数据结构。<br>每个进程都有自己的 <strong>页表</strong> ，它记录了该进程所有虚拟页的相关信息，<br>包括虚拟页是否已被加载到主存以及其对应的物理页框地址。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><strong>CISC（Complex Instruction Set Computer）</strong> 架构是一种处理器设计理念，其特点是提供 <strong>复杂且多样化的指令集</strong><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">policy：/ˈpɒləsi/ n.  策略；方针；<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">贝拉迪：贝拉迪异常（Belady’s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>考试时间统计</title>
    <url>/posts/28f58f35.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<ul class="lvl-0">
<li class="lvl-2">计组：25号</li>
</ul>
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配策略</title>
    <url>/posts/907f4c43.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配策略</h3>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在操作系统中，<strong>物理块分配策略</strong>主要决定了内存如何分配给进程以及页面置换的策略。以下是这些策略的详细解释：</p>
<hr>
<h3 id="1-固定分配，局部置换"><a class="header-anchor" href="#1-固定分配，局部置换">¶</a><strong>1. 固定分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配：每个进程在创建时，分配固定数量的物理块（即页面框）。这些物理块数量在整个运行过程中不再改变。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，一个进程可能被分配 5 个页面框，另一个进程被分配 10 个页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>局部置换：当一个进程需要置换页面时，只能在它自己的物理块中进行替换，而不会占用或影响其他进程的物理块。</p>
<ul class="lvl-2">
<li class="lvl-4">换句话说，每个进程有自己的物理块范围，页面置换仅限于该范围内。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：避免了进程之间的干扰，保证了各自的内存独立性。</p>
<p><strong>缺点</strong>：如果某个进程的需求量超过了固定分配的物理块数，可能会出现高频率的页面置换（抖动问题）。</p>
<hr>
<h3 id="2-可变分配，全局置换"><a class="header-anchor" href="#2-可变分配，全局置换">¶</a><strong>2. 可变分配，全局置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以根据进程的运行情况动态调整分配给每个进程的物理块数量。例如，一个进程内存需求增加时，可以从其他进程的分配中借用页面框。</p>
</li>
<li class="lvl-2">
<p>全局置换：当某个进程需要置换页面时，可以在整个系统的所有物理块中选择受影响的页面，不局限于自身的物理块范围。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，某个进程的页面置换可能会影响到其他进程正在使用的页面。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：提高了系统内存的利用率，允许内存资源在进程之间灵活分配。</p>
<p><strong>缺点</strong>：进程之间可能会互相干扰，导致某些进程因内存不足而性能下降。</p>
<hr>
<h3 id="3-可变分配，局部置换"><a class="header-anchor" href="#3-可变分配，局部置换">¶</a><strong>3. 可变分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以动态调整每个进程的物理块数量，具体分配数量由操作系统根据进程的需求决定。</p>
</li>
<li class="lvl-2">
<p><strong>局部置换</strong>：尽管分配数量可变，但每个进程仍只能在自己当前拥有的物理块中进行页面置换，而不能影响其他进程的页面。</p>
</li>
</ul>
<p><strong>优点</strong>：结合了固定分配和可变分配的优点，既能根据需求调整资源，又避免了进程之间的直接干扰。</p>
<p><strong>缺点</strong>：动态分配增加了操作系统的复杂性。</p>
<hr>
<h3 id="总结对比"><a class="header-anchor" href="#总结对比">¶</a><strong>总结对比</strong></h3>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>物理块分配</th>
<th>页面置换范围</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定分配，局部置换</td>
<td>固定数量</td>
<td>自己的物理块</td>
<td>简单、稳定，避免进程干扰</td>
<td>缺乏灵活性，可能导致个别进程性能下降</td>
</tr>
<tr>
<td>可变分配，全局置换</td>
<td>动态调整</td>
<td>全局</td>
<td>高效利用内存资源，支持动态调整</td>
<td>进程间干扰可能导致系统不稳定</td>
</tr>
<tr>
<td>可变分配，局部置换</td>
<td>动态调整</td>
<td>自己的物理块</td>
<td>兼顾灵活性和稳定性</td>
<td>系统复杂度较高</td>
</tr>
</tbody>
</table>
<p>这三种策略在实际中会根据操作系统的设计目标与应用场景选择适用的方案。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-LRU的实际实现过程</title>
    <url>/posts/f041ded5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现</h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><span id="more"></span>
<p>以下是使用<strong>移位寄存器</strong>和<strong>栈</strong>实现最近最久未使用（LRU）算法的详细过程：</p>
<hr>
<h3 id="1-用移位寄存器实现-LRU"><a class="header-anchor" href="#1-用移位寄存器实现-LRU">¶</a><strong>1. 用移位寄存器实现 LRU</strong></h3>
<p>移位寄存器通过记录页面的访问历史，来跟踪最近最久未使用的页面。</p>
<h4 id="基本原理"><a class="header-anchor" href="#基本原理">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页面框对应一个寄存器（n 位宽）。</p>
</li>
<li class="lvl-2">
<p>每次访问页面时：</p>
<ol>
<li class="lvl-5">将对应寄存器的最高位设置为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ol>
</li>
<li class="lvl-2">
<p>随着时间推移，未被访问的页面寄存器的值会逐渐变小。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面（即最久未使用的页面）。</p>
</li>
</ul>
<h4 id="实现步骤"><a class="header-anchor" href="#实现步骤">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化寄存器</strong>：为每个页面框分配一个寄存器，初始值为全 0。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">找到访问的页面对应的寄存器。</li>
<li class="lvl-5">设置寄存器的最高位为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">在页面不在内存中且内存已满时，找到寄存器值最小的页面并将其替换。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>更新寄存器</strong>：置换完成后，初始化新页面的寄存器值为最高位为 1，其他位为 0。</p>
</li>
</ol>
<h4 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h4>
<p>假设有 4 个页面框，对应 4 个 4 位寄存器，初始值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并对所有寄存器右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>再次访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1100  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R2 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0110  R2: 1000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-用栈实现-LRU"><a class="header-anchor" href="#2-用栈实现-LRU">¶</a><strong>2. 用栈实现 LRU</strong></h3>
<p>栈结构利用最近使用的页面总是在栈顶，而最久未使用的页面总是在栈底的特点，实现页面置换。</p>
<h4 id="基本原理-2"><a class="header-anchor" href="#基本原理-2">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用一个栈存储页面框号，栈顶是最近访问的页面。</p>
</li>
<li class="lvl-2">
<p>页面访问时：</p>
<ol>
<li class="lvl-5">如果页面已在栈中，将其移到栈顶。</li>
<li class="lvl-5">如果页面不在栈中：
<ul class="lvl-4">
<li class="lvl-7">栈未满时，将页面直接插入栈顶。</li>
<li class="lvl-7">栈已满时，移除栈底页面（最久未使用），然后插入新页面到栈顶。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="实现步骤-2"><a class="header-anchor" href="#实现步骤-2">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化栈</strong>：创建一个空栈，大小等于内存页面框数。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">检查页面是否在栈中：
<ul class="lvl-4">
<li class="lvl-7">如果在，将该页面从原位置移到栈顶。</li>
<li class="lvl-7">如果不在：
<ul class="lvl-6">
<li class="lvl-9">栈未满时，直接将页面插入栈顶。</li>
<li class="lvl-9">栈已满时，移除栈底页面，插入新页面到栈顶。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">置换操作在栈已满时，删除<strong>栈底</strong>页面，插入新页面到栈顶。</li>
</ul>
</li>
</ol>
<h4 id="示例-2"><a class="header-anchor" href="#示例-2">¶</a><strong>示例</strong></h4>
<p>假设有 3 个页面框，初始栈为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[]</span><br></pre></td></tr></table></figure>
<p>访问页面 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[1]</span><br></pre></td></tr></table></figure>
<p>访问页面 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p>再次访问页面 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将页面 2 移到栈顶：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 3, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 4（超出容量，需要置换）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>移除栈底页面（1），插入 4：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[4, 2, 3]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="比较与选择"><a class="header-anchor" href="#比较与选择">¶</a><strong>比较与选择</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>移位寄存器</strong>实现简单，占用较少存储资源，但适合小型固定容量系统。</p>
</li>
<li class="lvl-2">
<p><strong>栈</strong>灵活性更高，适合动态管理和较大规模的页面置换问题。</p>
</li>
</ul>
<p>以上两种实现可以结合实际需求与硬件条件选择【18】【19】。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配算法</title>
    <url>/posts/8ba68849.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配算法<strong>对比总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在物理块分配中，操作系统通过不同的分配算法将内存中的页面框分配给各个进程，以提高内存利用率和系统性能。以下是这些算法的详细解释：</p>
<hr>
<h3 id="1-平均分配算法"><a class="header-anchor" href="#1-平均分配算法">¶</a><strong>1. 平均分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">系统将所有的物理块平均分配给当前运行的进程。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个页面框和 <code>M</code> 个进程，则每个进程分配到的页面框数量为 <code>N / M</code>，如果有余数，可以通过某种方式分配剩余的页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">简单易实现，适用于所有进程的内存需求大致相同的场景。</li>
<li class="lvl-4">对于需求量大的进程可能导致页面置换频繁（抖动问题），而需求量小的进程可能浪费内存。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：公平、实现简单。</p>
<p><strong>缺点</strong>：无法动态适应进程的实际需求，可能导致资源分配不合理。</p>
<hr>
<h3 id="2-按比例分配算法"><a class="header-anchor" href="#2-按比例分配算法">¶</a><strong>2. 按比例分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">根据每个进程所需的页面数占比，按比例分配物理块。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个物理块，<code>M</code> 个进程，进程 <code>i</code> 所需页面数为 <code>Si</code>，则分配给进程 <code>i</code> 的页面框数为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{S_i}{\sum_{j=1}^{M} S_j}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">进程内存需求较大时分配更多页面框，内存需求较小时分配更少。</li>
<li class="lvl-4">适用于进程内存需求差异较大的场景，能较好地满足高需求进程的性能。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：充分利用资源，能够根据需求动态调整分配。</p>
<p><strong>缺点</strong>：计算复杂度较高，对需求量估计不准确时可能影响性能。</p>
<hr>
<h3 id="3-考虑优先权的分配算法"><a class="header-anchor" href="#3-考虑优先权的分配算法">¶</a><strong>3. 考虑优先权的分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">在按比例分配的基础上，结合进程的优先级分配物理块。</li>
<li class="lvl-4">系统会为高优先级进程分配更多的页面框，而低优先级进程分配较少。</li>
<li class="lvl-4">假设优先级为 <code>Pi</code>，则分配公式可以扩展为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{P_i \cdot S_i}{\sum_{j=1}^{M} (P_j \cdot S_j)}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">确保高优先级进程在资源分配上得到保障。</li>
</ul>
</li>
<li class="lvl-2">
<p>适用于多任务操作系统，优先保证关键任务或重要用户的性能。</p>
</li>
</ul>
<p><strong>优点</strong>：保障高优先级任务的运行性能。</p>
<p><strong>缺点</strong>：可能导致低优先级进程长时间无法获得足够的资源，影响其运行。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-移位寄存器</title>
    <url>/posts/3d2c198d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="移位寄存器的基本功能"><a class="header-anchor" href="#移位寄存器的基本功能">¶</a><strong>移位寄存器的基本功能</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据存储</strong>：可以临时存储一定数量的二进制数据。</p>
</li>
<li class="lvl-3">
<p><strong>数据移位</strong>：按照时钟信号，将数据向左或向右移位。</p>
</li>
<li class="lvl-3">
<p>数据串并转换</p>
<p>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>串行输入并行输出（SIPO）</strong>：将串行输入的数据逐位移入，然后一次性输出并行数据。</p>
</li>
<li class="lvl-5">
<p><strong>并行输入串行输出（PISO）</strong>：将并行输入的数据一次性装载，然后逐位移出。</p>
</li>
<li class="lvl-5">
<p><strong>串行输入串行输出（SISO）</strong>：数据逐位输入后，逐位移出。</p>
</li>
<li class="lvl-5">
<p><strong>并行输入并行输出（PIPO）</strong>：并行方式输入和输出数据。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的分类"><a class="header-anchor" href="#移位寄存器的分类">¶</a><strong>移位寄存器的分类</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>按移位方向分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>左移寄存器</strong>：数据向左移位，低位补零或引入外部输入。</li>
<li class="lvl-5"><strong>右移寄存器</strong>：数据向右移位，高位补零或引入外部输入。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>按输入输出方式分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>SISO（串行输入串行输出）</strong>：数据逐位输入并逐位输出，适合数据流传输。</li>
<li class="lvl-5"><strong>SIPO（串行输入并行输出）</strong>：串行输入，移位完成后并行读取，常用于串行转并行。</li>
<li class="lvl-5"><strong>PISO（并行输入串行输出）</strong>：并行数据装载后逐位输出，常用于并行转串行。</li>
<li class="lvl-5"><strong>PIPO（并行输入并行输出）</strong>：同时装载和输出并行数据，用于数据缓存。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的组成与工作原理"><a class="header-anchor" href="#移位寄存器的组成与工作原理">¶</a><strong>移位寄存器的组成与工作原理</strong></h3>
<p>移位寄存器通常由以下部分组成：</p>
<ol>
<li class="lvl-3">
<p><strong>触发器</strong>：每个触发器存储一个位的数据。</p>
</li>
<li class="lvl-3">
<p><strong>时钟信号</strong>：控制数据移位的节奏。</p>
</li>
<li class="lvl-3">
<p><strong>输入控制逻辑</strong>：决定数据的输入方式（串行或并行）。</p>
</li>
<li class="lvl-3">
<p><strong>输出控制逻辑</strong>：决定数据的输出方式。</p>
</li>
</ol>
<p><strong>工作原理</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个时钟周期，寄存器中的数据根据设定方向进行一次移位。</p>
</li>
<li class="lvl-2">
<p>输入数据按要求补充到移位方向的空位。</p>
</li>
<li class="lvl-2">
<p>移出的数据可以输出到其他模块。</p>
</li>
</ul>
<hr>
<h3 id="移位寄存器的应用"><a class="header-anchor" href="#移位寄存器的应用">¶</a><strong>移位寄存器的应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据延迟</strong>：移位寄存器可以延迟数据的传输，用于信号同步。</p>
</li>
<li class="lvl-3">
<p><strong>串并转换</strong>：实现串行和并行数据的转换。</p>
</li>
<li class="lvl-3">
<p><strong>计数器</strong>：通过移位操作实现二进制计数功能。</p>
</li>
<li class="lvl-3">
<p><strong>加密与解码</strong>：如线性反馈移位寄存器（LFSR）常用于伪随机数生成和加密。</p>
</li>
<li class="lvl-3">
<p><strong>信号处理</strong>：在数字信号处理中，用于滤波器设计、数据流处理等。</p>
</li>
</ol>
<hr>
<h3 id="示例电路：4位右移寄存器"><a class="header-anchor" href="#示例电路：4位右移寄存器">¶</a><strong>示例电路：4位右移寄存器</strong></h3>
<p>假设有 4 个触发器（D1, D2, D3, D4）组成一个右移寄存器，初始状态为 <code>1010</code>，右移过程如下：</p>
<ol>
<li class="lvl-3">
<p><strong>时钟周期 1</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1101</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 2</strong>：输入新数据 <code>0</code>，移位后数据为 <code>0110</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 3</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1011</code>。</p>
</li>
</ol>
<p><strong>右移逻辑</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个触发器的输入来自于它左侧触发器的输出（例如，D4 的输入来自 D3 的输出）。</p>
</li>
</ul>
<hr>
<p>移位寄存器在数字系统中是一种基础组件，可以通过设计不同的逻辑电路实现各种复杂功能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-页面框</title>
    <url>/posts/6dc856e2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3><strong>总结</strong></h3>
<ul class="lvl-1">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
</p>
    </div>
</div><span id="more"></span>
<p><strong>页面框</strong>（Page Frame）是操作系统中物理内存管理的一个重要概念。</p>
<hr>
<h3 id="页面框的定义"><a class="header-anchor" href="#页面框的定义">¶</a><strong>页面框的定义</strong></h3>
<p>页面框是指<strong>物理内存中的固定大小的块</strong>，它是虚拟内存管理中用于存放<strong>页</strong>（Page）的单位。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页</strong>：虚拟内存被划分为大小固定的块，每块称为一个页（Page）。</p>
</li>
<li class="lvl-2">
<p><strong>页面框</strong>：物理内存也被划分为同样大小的固定块，这些块称为页面框（Page Frame）。</p>
</li>
</ul>
<p>页面框和页的大小相同（通常为 4KB 或 8KB，具体取决于操作系统和硬件架构），这样可以方便地实现虚拟内存和物理内存之间的映射。</p>
<hr>
<h3 id="页面框的作用"><a class="header-anchor" href="#页面框的作用">¶</a><strong>页面框的作用</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>存储页</strong>：页面框用于存储从虚拟内存中调入的页。</p>
</li>
<li class="lvl-2">
<p><strong>虚拟内存与物理内存的映射</strong>：操作系统通过页表（Page Table）将虚拟内存的页与物理内存的页面框一一对应，从而实现虚拟内存管理。</p>
</li>
<li class="lvl-2">
<p><strong>提升内存利用率</strong>：通过分页机制，进程无需全部加载到内存中，只需将常用的页装入页面框即可，减少内存的浪费。</p>
</li>
</ul>
<hr>
<h3 id="页面框的分配过程"><a class="header-anchor" href="#页面框的分配过程">¶</a><strong>页面框的分配过程</strong></h3>
<ol>
<li class="lvl-3">
<p>虚拟地址空间划分：进程的虚拟地址被划分为多个页。</p>
<ul class="lvl-2">
<li class="lvl-5">假设某进程需要 16KB 的虚拟内存，且每页大小为 4KB，则虚拟内存被划分为 4 个页。</li>
</ul>
</li>
<li class="lvl-3">
<p>物理内存划分：操作系统将物理内存划分为等大小的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">假设有 1GB 的物理内存，页面框大小为 4KB，则物理内存被划分为 262,144 个页面框。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面调度：当进程运行时，操作系统将虚拟内存中的页映射到物理内存中的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">若某页需要访问但不在内存（缺页中断），操作系统从磁盘将该页加载到某个空闲页面框中，或通过页面置换算法腾出一个页面框。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="页面框相关机制"><a class="header-anchor" href="#页面框相关机制">¶</a><strong>页面框相关机制</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页表（Page Table）</strong>：存储每个页与页面框的映射关系。</p>
</li>
<li class="lvl-2">
<p><strong>页面置换</strong>：当页面框不足时，操作系统通过页面置换算法（如 LRU、FIFO）将某些不常用的页移出页面框，以腾出空间给新的页。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>大学</tag>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
