<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/posts/55009.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>写在前面</h1>
<p>这个博客用于发布一些笔者认为需要多端查看的各种笔记，或者用于记录想要分享的各种知识</p>
<p>另外，由于笔者还并没有完全掌握<code>hexo</code>的各种用法，这个博客同时也会记录一些在使用<code>hexo</code>时的个人心得。</p>
<span id="more"></span>
<h2 id="博客支持的callout块"><a class="header-anchor" href="#博客支持的callout块">¶</a>博客支持的callout块</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&quot;important&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">&quot;warning&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">&quot;caution&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">&quot;success&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">&quot;note&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">&quot;tip&quot;: &#123; &quot;<span class="attribute">color</span>&quot;: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<div class="callout callout-important">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">IMPORTANT</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
</p>
    </div>
</div>
<div class="callout callout-caution">
    <div class="callout-head">
        <span class="callout-head-icon">❌</span>
        <span class="callout-head-text" style="color:#d32f2f">CAUTION</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
</p>
    </div>
</div>
<div class="callout callout-success">
    <div class="callout-head">
        <span class="callout-head-icon">✔️</span>
        <span class="callout-head-text" style="color:#2e7d32">SUCCESS</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>好吧，typora支持的内容有点少了</p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太好了，typora支持<code>note</code></p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>测试callout</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h2>测试一下是否支持应该支持的 md 语法</h2>
<p>警告！</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p>     $\uparrow  \ \ \ \      \uparrow  \ \ \ \     \uparrow$ 其他所有人</p>
<p>     $\uparrow  \ \ \ \      \uparrow$ 用户组</p>
<p>      $\uparrow$ 文件所有者</p>
<p>普通文本内容，其他段落不受影响。</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>d</code> <code>rwx</code> <code>rwx</code> <code>rwx</code></p>
<p><strong>Markdown 语法支持</strong>：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>列表项 1</p>
</li>
<li class="lvl-2">
<p>列表项 2</p>
</li>
</ul>
<blockquote>
<p>嵌套引用块</p>
</p>
    </div>
</div><p>普通文本内容，其他段落不受影响。</p>
</blockquote>
<h2 id="关于博客中自定义渲染callout块的部分"><a class="header-anchor" href="#关于博客中自定义渲染callout块的部分">¶</a>关于博客中自定义渲染<code>callout</code>块的部分</h2>
<h3 id="首先是callout语法"><a class="header-anchor" href="#首先是callout语法">¶</a>首先是<code>callout</code>语法</h3>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; [!tag]</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; content2</span></span><br></pre></td></tr></table></figure>
<p>由于笔者在编写此博客时使用的编写工具是<code>typora</code>，故将原来<code>obsidian</code>的语法做了一些改动，因为<code>typora</code>的引用块，行与行之间也会自动添加空行。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>渲染器部分，详见<a href="/posts/4179">关于callout块渲染</a></p>
</p>
    </div>
</div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!info] 信息头</span><br><span class="line">这是第一行内容。</span><br><span class="line">这是第二行内容。</span><br></pre></td></tr></table></figure>
<p><a href="https://mermaid.nodejs.cn/syntax/zenuml.html">ZenUML | Mermaid 中文网</a>Mermaind使用</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/posts/cd647b6c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>操作系统复习笔记的章节目录</p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131555663.png" alt="image-20241213155517713"></p>
<h4 id="操作系统章节目录"><a class="header-anchor" href="#操作系统章节目录">¶</a>操作系统章节目录</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/posts/6070b0ed">第五章</a></p>
</li>
<li class="lvl-2">
<p><a href="/posts/b90b7ae5">第六章</a></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown中latex的使用记录</title>
    <url>/posts/3d12274.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>总结一些在<code>markdown</code>中书写<code>Latex</code>公式的用法</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="一些常用的希腊字母"><a class="header-anchor" href="#一些常用的希腊字母">¶</a>一些常用的希腊字母</h2>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>LaTex形式</th>
<th>希腊字母</th>
<th>LaTex形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\alpha$ $\Alpha$</td>
<td>\alpha</td>
<td>$\mu$ $\Mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$\beta$ $\Beta$</td>
<td>\beta</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$\gamma$ $\Gamma$</td>
<td>\gamma</td>
<td>$\rho$ $\varrho$ $\Rho$</td>
<td>\rho \varrho \Rho</td>
</tr>
<tr>
<td>$\delta$ $\Delta$</td>
<td>\delta</td>
<td>$\sigma$ $\Sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\epsilon$ $\varepsilon$ $\Epsilon$</td>
<td>\epsilon \varepsilon \Epsilon</td>
<td>$\tau$ $\Tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\zeta$ $\Zeta$</td>
<td>\zeta</td>
<td>$\upsilon$ $\Upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\eta$ $\Eta$</td>
<td>\eta</td>
<td>$\phi$ $\varphi$ $\Phi$</td>
<td>\phi \varphi \Phi</td>
</tr>
<tr>
<td>$\theta$ $\vartheta$ $\Theta$</td>
<td>\theta \vartheta \Theta</td>
<td>$\chi$ $\Chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\omega$ $\Omega$</td>
<td>\omega</td>
<td>$\psi$ $\Psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\kappa$ $\Kappa$</td>
<td>\kappa</td>
<td>$\iota$ $\Iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$\lambda$ $\Lambda$</td>
<td>\lambda</td>
<td>$\theta$ $\Theta$</td>
<td>\theta</td>
</tr>
</tbody>
</table>
<h2 id="上标下标"><a class="header-anchor" href="#上标下标">¶</a>上标下标</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>上标$a^2$： <code>a^2</code></p>
</li>
<li class="lvl-2">
<p>下标$H_2O$：<code>H_2O</code></p>
</li>
</ul>
<h2 id="顶标"><a class="header-anchor" href="#顶标">¶</a>顶标</h2>
<p>通用标签：<code>\overset&#123;顶标&#125;&#123;字体&#125;</code>：$\overset{顶标}{字体}$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于通用顶标的拓展尝试</h4>
<ul class="lvl-1">
<li class="lvl-3">
<p>$\overset{_}{a}$ ：<code>\overset&#123;\_&#125;&#123;a&#125;</code></p>
</li>
<li class="lvl-2">
<p>$\overset{·}{a}$：<code>\overset&#123;·&#125;&#123;a&#125;</code></p>
<p><small>这里的<code>·</code>是中文的<big><big>`</big></big></small></p>
</li>
<li class="lvl-2">
<p>$\overset{~}{a}$：失败的尝试，若不使用<code>\</code>转义，则<code>~</code>不会显示，就像这样$\overset{~}{a}$</p>
</li>
<li class="lvl-2">
<p>$\overset{^}{a}$：<code>$\overset&#123;\^&#125;&#123;a&#125;</code></p>
</li>
</ul>
</p>
    </div>
</div><p>常用顶标：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>\hat&#123;1&#125;</code> : $\hat{1}$</p>
</li>
<li class="lvl-2">
<p><code>\overline&#123;1&#125;</code> : $\overline{1}$</p>
</li>
<li class="lvl-2">
<p><code>\dot&#123;1&#125;</code> : $\dot{1}$</p>
</li>
<li class="lvl-2">
<p><code>\widetilde&#123;1&#125;</code> : $\widetilde{1}$</p>
</li>
</ul>
<h2 id="分数"><a class="header-anchor" href="#分数">¶</a>分数</h2>
<p>$5/6$ <code>5/6</code>，美中不足，不同渲染器渲染结果不同，比如<code>typora</code>就是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121457874.png" alt="image-20241212145726822"></p>
<center><small>这显然不是我们想要的样子</small></center>
<p>规范的分式写法：</p>
<p>$\frac{a}{b}$:<code>\frac&#123;a&#125;&#123;b&#125;</code></p>
<p>但其实也不太必要。😰</p>
<h2 id="求和与积分"><a class="header-anchor" href="#求和与积分">¶</a>求和与积分</h2>
<p>$\sum_{i=1}^n i^2$</p>
<p><code>\sum_&#123;i=1&#125;^n i^2</code></p>
<p>$ \int_a^b x^2 , dx$</p>
<p><code> \int_a^b x^2 \, dx</code></p>
<blockquote>
<p>有趣🎃</p>
<p>$,$<small>：<code>$,$</code></small>是会被<code>latex</code>渲染出来的，</p>
<p>$,$<small>$\leftarrow$这里有东西</small><small>：<code>$\,$</code></small>就像会把 ’ ,’ 忽略一样，可能只渲染出一个空格吧</p>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实就是$\sum$：<code>$\sum$</code>加个上标，加个下标$\sum_a^b$<code>$\sum_a^b$</code>，就变成求和的这个了</p>
<p>积分符号<code>$\int$</code><small>：$\int$</small> ，同理，加个上标加个下标就好了，$\int_a^b$<code>$\int_a^b$</code></p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>感觉需要补一下知识</h4>
<p>例如，我们可以很方便的将一个字母或者数字作为上标或者下标：</p>
<p>$a_2, b^3$ <code>$a_2, b^3$</code></p>
<p>而我们想将$(n-1)$<code>$(n-1)$</code>作为上标或者下标时，我们就会涉及到将$(n-1)$作为一个整体，当作下标和上标。</p>
<p>在$\LaTeX$中如果想将一组符号<small>如$n-1$</small>，就需要用到<code>$&#123;&#125;$</code></p>
<p>例如，$a_{n-1}$：<code>$a_&#123;n-1&#125;$</code>，就将<code>n-1</code>用<code>&#123;&#125;</code>括起来，当成一个整体。</p>
</p>
    </div>
</div><h2 id="逻辑符号"><a class="header-anchor" href="#逻辑符号">¶</a>逻辑符号</h2>
<p>$\forall, \exists, \neg, \land, \lor, \implies, \iff$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$\forall$：<code>$forall$</code></p>
</li>
<li class="lvl-2">
<p>$\exists$：<code>$\exists$</code></p>
</li>
<li class="lvl-2">
<p>$\neg$：<code>$\neg$</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="negative 英 /ˈneɡətɪv/ 否定的，拒绝的；">[1]</span></a></sup></p>
</li>
<li class="lvl-2">
<p>$\land$：<code>$\land$</code><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="logical AND">[2]</span></a></sup> l-and</p>
</li>
<li class="lvl-2">
<p>$\lor$：<code>$\lor$</code><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="logical OR">[3]</span></a></sup> l-or</p>
</li>
<li class="lvl-2">
<p>$\implies$：<code>$\implies$</code></p>
</li>
<li class="lvl-2">
<p>$\iff$：<code>$\iff$</code></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>贴张趣图:happy:</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121530568.png" alt="image-20241212153056632"></p>
</p>
    </div>
</div><h2 id="方程"><a class="header-anchor" href="#方程">¶</a>方程</h2>
<p>$$<br>
\begin{aligned}<br>
x &amp;= y + z \\<br>
a &amp;= b + c<br>
\end{aligned}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x <span class="built_in">&amp;</span>= y + z <span class="keyword">\\</span><span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span>= b + c</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>因为<code>hexo</code>渲染器问题，<code>\\</code>会被转成<code>\</code>无论是不是在公式块中，而<code>\</code>在latex中是空格的意思，而<code>\\</code>是换行的意思，但是在被渲染处理后<code>\\</code>就会变成<code>\</code>，这样在mathjax渲染是可就bug了🙁</p>
<p>网上并没有好的解决方案，有修改渲染器源代码的，有用个分割块让渲染器强制不处理的，但是这样在正文块还正常，在引用块中就出现各种问题了</p>
</p>
    </div>
</div><p>哎，还得是这个没办法的方案了</p>
<p>就是，hexo不是会吧<code>\\</code>转义成<code>\</code>吗，那就索性让他转义，我们直接<code>\\\\</code>不就好了，<code>\\\\</code>就会变成<code>\\</code>，不过这样在自己的编辑器中就会中间多一行空行了</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412121555139.png" alt="image-20241212155459686"></p>
<center><small>会中间多一行空行</small></center>
<p>但其实无伤大雅对吧。</p>
<p>另外，用<code>&amp;</code>可以对其方程，<code>&amp;</code>所在的位置会被上下对齐</p>
<h2 id="矩阵"><a class="header-anchor" href="#矩阵">¶</a>矩阵</h2>
<p>$$<br>
\begin{bmatrix}<br>
a &amp; b \\<br>
c &amp; d<br>
\end{bmatrix}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="keyword">\\</span><span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向量与点积"><a class="header-anchor" href="#向量与点积">¶</a>向量与点积</h2>
<p>$\vec{a}, \vec{b}, \cdot$</p>
<p><code>$\vec&#123;a&#125;, \vec&#123;b&#125;, \cdot$</code></p>
<h2 id="根号"><a class="header-anchor" href="#根号">¶</a>根号</h2>
<p>$\sqrt{a}, \sqrt[3]{b}, \sqrt{x^2 + y^2}$</p>
<p><code>$\sqrt&#123;a&#125;, \sqrt[3]&#123;b&#125;, \sqrt&#123;x^2 + y^2&#125;$</code></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">negative 英 /ˈneɡətɪv/ 否定的，拒绝的；<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">logical AND<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3" class="footnote-item"><span class="footnote-content">logical OR<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>双口RAM和多模块存储器</title>
    <url>/posts/eb3d57f9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181945596.png" alt="image-20241218194526205"></p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="双端口ROM"><a class="header-anchor" href="#双端口ROM">¶</a>双端口ROM</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181946113.png" alt="image-20241218194614774"></p>
<blockquote>
<p>需要由两组完全独立的数据线、地址线、控制线。</p>
<p>CPU、RAM中也要有更复杂的控制电路</p>
</blockquote>
<p>两个端口对同一主存操作有一下4种情况</p>
<ol>
<li class="lvl-3">
<p>两个端口同时对不同的地址单元存取数据。👌</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一地址单元读出数据👌</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一地址单元写入数据🚫</p>
</li>
<li class="lvl-3">
<p>两个端口同时对同一个地址单元,一个写入数据,一个读出数据🚫</p>
</li>
</ol>
<blockquote>
<p>对比操作系统,”读者写者问题”</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328791.png" alt="image-20241218202233225"></p>
<h2 id="多体并行存储器"><a class="header-anchor" href="#多体并行存储器">¶</a>多体并行存储器</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328241.png" alt="image-20241218202740359"></p>
<h3 id="交叉编址"><a class="header-anchor" href="#交叉编址">¶</a>交叉编址</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328327.png" alt="image-20241218202847344"></p>
<h4 id="高位交叉编址"><a class="header-anchor" href="#高位交叉编址">¶</a>高位交叉编址</h4>
<p>地址的前几位表示是哪一个芯片</p>
<p>如 ,  上图中 ,  高位部分  (前面的<span style="color:blue">00</span>)  就是用于表示选择$M_0$芯片的</p>
<h4 id="低位交叉编址"><a class="header-anchor" href="#低位交叉编址">¶</a>低位交叉编址</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328323.png" alt="image-20241218203356731"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>对于高位交叉编址,   和低位交叉编址.</p>
<p>地址的实际值是不太一样的</p>
<p>对于高位交叉编址,  就像是在第一个内存条编完0~7</p>
<p>在到下一个内存条边8之后的</p>
<p>而,   地位交叉编址,  就像是横着编址</p>
<p>先从第一个存储器到最后一个存储器,  依次在第一个存储单元上编上0~4</p>
<p>在从第一个存储器第二个存储单元开始,依次往后编址</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182039551.png" alt="image-20241218203939989"></p>
</p>
    </div>
</div>
<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在交叉编址的多体存储器部分</p>
<p><big><strong>连续访问同一个存储体,   是需要等待刷新时间的</strong></big></p>
<p>即,    需要等待一个整个存取时间<small>(加上了刷新时间)</small></p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182048168.png" alt="image-20241218204838550"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182328881.png" alt="image-20241218205030135"></p>
<p>当需要读出地址连续的四个单元时,   低位交叉编址和高位交叉编址访存时间不同</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对高位交叉编址,   访问连续地址时,    由于高位不变,   实际上是访问同一块存储体的连续地址,   则每次读取都需要等待一整个存取周期</p>
</li>
<li class="lvl-2">
<p>对于低位交叉编址,   访问连续地址时,   由于低位是变化的,   实际上是在分别访问每块存储体的相同位置的存储单元,   而访存完第一个存储体,   无需等待第一个存储体是否完成刷新,   直接访问第二个就可以</p>
</li>
</ul>
<p>若,   设每个存储体存取周期为$T$</p>
<p>存取时间为$r$,  假设$T=4r$</p>
<p>则,   访问高地址交叉编址需要耗时$5T$,   访问低地址交叉编址需要耗时$T+4r$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>低位交叉编址的多体存储器，连续取n个存储字耗时$T+(n-1)r$</p>
</p>
    </div>
</div><blockquote>
<p>宏观上来看，读写一个字的时间接近$r$</p>
</blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>因为，在实际使用中，程序寻访的通常是连续的地址空间</p>
<p>所以这里讨论的就是连续访问连续地址的情况</p>
</p>
    </div>
</div><h3 id="应该取几个“体”"><a class="header-anchor" href="#应该取几个“体”">¶</a>应该取几个“体”</h3>
<p>采用<mark>流水线</mark>的方式并行存取（宏观上并行，微观上串行）</p>
<p>宏观上，一个存储周期内，m体交叉存储器可以提供的数据量位单个模块m倍</p>
<p>存取周期为T，<span style="color:red">存取时间为$r$</span></p>
<p>为了使流水线不间断，应保证模块数 m&gt;=T/r</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329040.png" alt="image-20241218230442183"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>如何判断当前读取的是那个存储体？</p>
<p>首先可以将地址转为2进制，然后看最后几个</p>
<p>或者，将地址对单元数取余</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329702.png" alt="image-20241218231050318"></p>
<h2 id="多模块存储器"><a class="header-anchor" href="#多模块存储器">¶</a>多模块存储器</h2>
<h3 id="多体并行存储器-2"><a class="header-anchor" href="#多体并行存储器-2">¶</a>多体并行存储器</h3>
<p>每个模块都有相同的容量和存取速度。</p>
<p>各模块都有独立的读写控制电路、地址寄存器和数据寄存器。</p>
<p>他们既能并行工作，又能交叉工作</p>
<h3 id="单体多字存储器"><a class="header-anchor" href="#单体多字存储器">¶</a>单体多字存储器</h3>
<p>每个存储单元存储$m$个字</p>
<p>总线宽度为$m$个字</p>
<p>一次并行读出$m$个字</p>
<p>每次只能同时取$m$个字，不能单独存取其中某个字</p>
<p>指令和数据在主存内必须是连续存放的</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412182329600.png" alt="image-20241218231856328"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-只读存储器ROM</title>
    <url>/posts/4bd706e9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180945837.png" alt="image-20241218094522856"></p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="了解各种ROM"><a class="header-anchor" href="#了解各种ROM">¶</a>了解各种ROM</h2>
<h3 id="MROM"><a class="header-anchor" href="#MROM">¶</a>MROM</h3>
<p>掩模式只读ROM</p>
<p>厂家按照客户需求，在芯片生产过长中直接写入信息，之后<span style="color:red">任何人不可重写</span>（只能读出）</p>
<p>可靠性高、灵活性差、生产周期长、只适合批量定制</p>
<h3 id="PROM"><a class="header-anchor" href="#PROM">¶</a>PROM</h3>
<p>可编程只读ROM</p>
<p>用户可用专门PROM写入器写入信息，写<span style="color:red">写一次之后就无法更改</span></p>
<h3 id="EPROM"><a class="header-anchor" href="#EPROM">¶</a>EPROM</h3>
<p>可擦除可编程只读存储器</p>
<p>允许用户写入信息，之后用某种方法擦除数据，<span style="color:red">可进行多次重写</span></p>
<h3 id="UVEPROM"><a class="header-anchor" href="#UVEPROM">¶</a>UVEPROM</h3>
<p>用紫外线照射8~20分钟，擦除<mark>所有信息</mark></p>
<h3 id="EEROM"><a class="header-anchor" href="#EEROM">¶</a>EEROM</h3>
<p>(也常记为$E^2PROM$，第一个E是Electioneering)</p>
<p>可用“电擦除”的方式，擦除<mark>特定的字</mark></p>
<h3 id="Flash-Mermory"><a class="header-anchor" href="#Flash-Mermory">¶</a>Flash Mermory</h3>
<p>闪速存储器（注：U盘，SD卡，就是闪存)</p>
<p>在EEPROM基础上发展而来，断电后也能保持信息，且<span style="color:red">可进行多次快速擦除重写</span></p>
<p>注意：由于闪存需要擦除再写入，因此<mark>闪存的“写”速度要比“读”速度更慢</mark></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>每个存储元只需单个MOS管，位密度比RAM高</p>
</p>
    </div>
</div><h3 id="SSD-Solid-State-Drives"><a class="header-anchor" href="#SSD-Solid-State-Drives">¶</a>SSD(Solid State Drives)</h3>
<p>固态硬盘</p>
<p>由控制单元+存储单元（Flash芯片）构成，与闪存存储器的核心区别在于控制单元不一样，但存储介质都类似，<span style="color:red">可进行多次快速擦除重写</span>.</p>
<p>SSD速度块、功耗低、价格高。目前个人电脑常常用SSD取代传统的机械硬盘</p>

<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>虽然**SSD与Flash（U盘、SD卡）**都可读可写，但他们都还属于ROM，</p>
<p><big><strong>即<mark>只读存储器</mark></strong></big></p>
</p>
    </div>
</div><h2 id="计算机内的重要ROM"><a class="header-anchor" href="#计算机内的重要ROM">¶</a>计算机内的重要ROM</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181924131.png" alt="image-20241218192456757"></p>
<p>主板上的BIOS芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181929447.png" alt="image-20241218192900504"></p>
<p>我们常所的“内存条”就是主存，但事实上，主板上的ROM芯片也是“主存”的一部分</p>
<p>逻辑上，主存由RAM+ROM组成，且两者常统一编址</p>
</p>
    </div>
</div><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412181934036.png" alt="image-20241218193406493"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>很多ROM芯片虽然名字是“Read-Only”，但是<mark>很多ROM也可以“写”</mark></p>
</li>
<li class="lvl-2">
<p><mark>闪存的写速度一般比读速度更慢</mark>，因为写入前要先擦除</p>
</li>
<li class="lvl-2">
<p>RAM芯片是易失性的，ROM芯片是非易失性的，很多<mark>ROM也都是具有”随机存取“的特性</mark></p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-SRAM和DRAM</title>
    <url>/posts/9e51c077.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172253813.png" alt="image-20241217225313705"></p>
</p>
    </div>
</div><span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172254176.png" alt="image-20241217225433063"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>DRAM<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="Dynamic Random Access Memory，动态--随机--存取--存储器">[1]</span></a></sup>是使用栅极电容作为一个存储元</p>
<p>SRAM<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="Static Random Access Memory，静态--随机--存取--存储器">[2]</span></a></sup>是使用双稳态触发器作为一个存储元</p>
</p>
    </div>
</div><p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172301628.png" alt="image-20241217230118820"></p>
<h2 id="栅极电容与双稳态触发器对比"><a class="header-anchor" href="#栅极电容与双稳态触发器对比">¶</a>栅极电容与双稳态触发器对比</h2>
<h3 id="栅极电容"><a class="header-anchor" href="#栅极电容">¶</a>栅极电容</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>读出1：MOS管接通，电容放电，数据上产生电流</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>电容放电信息被破坏，是<mark>破坏性读出</mark>。读出后应有<mark>重写</mark>操作，也称再生</p>
<p>另外，电容内的电荷只能维持2ms，即使不断电，2ms后信息也会消失，2ms之内必须“刷新”一次(给电容器充电)</p>
</p>
    </div>
</div><ul class="lvl-0">
<li class="lvl-2">
<p>读出0：MOS管接通后，数据线上无电流</p>
</li>
</ul>
<p>每个存储器制造成本更低，集成度高，功耗低</p>
<h3 id="双稳态触发器"><a class="header-anchor" href="#双稳态触发器">¶</a>双稳态触发器</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>读出0：BL为低电平</p>
</li>
<li class="lvl-2">
<p>读出1：BLX为低电平</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>读出数据，触发器状态保持稳定，是<mark>非破坏性读出</mark>，<mark>无需重写</mark></p>
</p>
    </div>
</div><p>每个存储元制造成本更高，集成度低，功耗大</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172317892.png" alt="image-20241217231730785"></p>
<h2 id="DRAM的刷新"><a class="header-anchor" href="#DRAM的刷新">¶</a>DRAM的刷新</h2>
<ol>
<li class="lvl-3">
<p>多久需要刷新一次：刷新周期，一般为2ms</p>
</li>
<li class="lvl-3">
<p>每次刷新多少存储单元：以行为单位，每次刷新一行存储单元</p>
</li>
<li class="lvl-3">
<p>如何刷新：</p>
<p><span style="color:blue">有硬件支持，读出一行的信息后重新写入，占用1个 读/写周期</span></p>
</li>
<li class="lvl-3">
<p>在什么时候刷新：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>思路一：每次读写玩就刷新一次</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>系统的存取周期变为1us</p>
<p>前0.5us用于正常读写</p>
<p>后0.5us用于刷新某行</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>思路二：2ms内集中全部刷新</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>系统的存取周期还是0.4us</p>
<p>有一段时间专门用于刷新</p>
<p>无法访问存储器，称为访存&quot;死区&quot;</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>思路三：2ms内每行刷新1次即可</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>2ms/128 = 15.6us一次</p>
<p>每15.6us内有0.5us的&quot;死时间&quot;</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180922018.png" alt="image-20241218092153796"></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>“刷新”由存储器独立完成，不需要cpu控制</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><big><strong>DRAM通常使用行列地址，以减少选通线的数量</strong></big></p>
<p>因为如果只用一维地址线，大容量存储就会使用非常多的地址线</p>
<p>所以在实际使用时，一般采用二维地址线，即行列地址线</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180853639.png" alt="image-20241218085302674"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180856798.png" alt="image-20241218085631434"></p>
</p>
    </div>
</div><h2 id="DRAM地址线时分复用技术"><a class="header-anchor" href="#DRAM地址线时分复用技术">¶</a>DRAM地址线时分复用技术</h2>
<p>因为DRAM需要很长的寻址，所以将行地址与列地址进行复用</p>
<p>则只需要$\frac{n}{2}$条地址线</p>
<p>在地址解析时，</p>
<p>先将行地址通过地址线放入行地址缓冲器</p>
<p>再将列地址通过地址线放入列地址缓冲区</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412180932106.png" alt="image-20241218093200088"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>地址线复用技术，导致地址线、地址引脚减半</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>现在的主存通常采用SDRAM芯片</p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">Dynamic Random Access Memory，动态--随机--存取--存储器<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">Static Random Access Memory，静态--随机--存取--存储器<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-主存储器的基本组成</title>
    <url>/posts/55b84d3b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>主存储器的基本组成笔记</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="基本的半导体元件及原理"><a class="header-anchor" href="#基本的半导体元件及原理">¶</a>基本的半导体元件及原理</h2>
<p><img src="./assets/image-20241217213252690.png" alt="image-20241217213252690"></p>
<center><small>一个存储元的结构图</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通</p>
</p>
    </div>
</div><h2 id="存储器芯片的基本原理"><a class="header-anchor" href="#存储器芯片的基本原理">¶</a>存储器芯片的基本原理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172155485.png" alt="image-20241217215544934"></p>
<center><small>存储器结构</small></center>
<p>电容的状态，即当前存储元存储数据的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172137191.png" alt="image-20241217213745682"></p>
<center><small>将多个存储元串联，组成存储阵列</small></center>
<p><img src="./assets/image-20241217214844617.png" alt="image-20241217214844617"></p>
<center><small>通过将某根特定的地址线置为高电平，就可以读出存储字</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172154050.png" alt="image-20241217215427377"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172203879.png" alt="image-20241217215712458"></p>
<center><small>译码器</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172203875.png" alt="image-20241217215824431"></p>
<center><small>总容量的计算</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172202131.png" alt="image-20241217220217701"></p>
<center><small>控制电路</small></center>
<p><img src="./assets/image-20241217224002371.png" alt="image-20241217224002371"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172246538.png" alt="image-20241217224634193"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172247986.png" alt="image-20241217224756484"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172248536.png" alt="image-20241217224834432"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412172249976.png" alt="image-20241217224910019"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>计组-第三章-存储系统的基本概念</title>
    <url>/posts/80359a17.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放计组第三章笔记</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="存储器的层次结果"><a class="header-anchor" href="#存储器的层次结果">¶</a>存储器的层次结果</h2>
<p><img src="./assets/image-20241217163358988.png" alt="image-20241217163358988"></p>
<h2 id="存储器的分类"><a class="header-anchor" href="#存储器的分类">¶</a>存储器的分类</h2>
<h3 id="按层次"><a class="header-anchor" href="#按层次">¶</a>按层次</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>高速缓存（cache</p>
</li>
<li class="lvl-2">
<p>主存储器（主存、内存</p>
</li>
<li class="lvl-2">
<p>辅助存储器（辅存、外存</p>
</li>
</ul>
<p>其中高速缓存和主存可以被CPU直接读写</p>
<h3 id="按存储介质分类"><a class="header-anchor" href="#按存储介质分类">¶</a>按存储介质分类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>半导体存储器：以半导体器件存储信息</p>
</li>
<li class="lvl-2">
<p>磁表面存储器：以磁性材料存储</p>
</li>
<li class="lvl-2">
<p>光存储器：以光介质存储</p>
</li>
</ul>
<h3 id="按存取方式"><a class="header-anchor" href="#按存取方式">¶</a>按存取方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机存取存储器：读写任何一个存储单元所需的时间都相同，与存储单元的物理位置无关</p>
</li>
<li class="lvl-2">
<p>顺序存取存储器：读写一个存储单元所需时间取决于存储单元所在的物理位置</p>
</li>
<li class="lvl-2">
<p>直接存取存储器：既有随机存取特性，也有顺序存储特性。先直接选取信息所在区域，再按顺序方式存取</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>特殊的存储器</h4>
<p>相联存储器：即，可以按照内容检索到存储位置进行读写</p>
<p>“快表”就是一种相联存储器</p>
</p>
    </div>
</div><h2 id="按信息的可更改性"><a class="header-anchor" href="#按信息的可更改性">¶</a>按信息的可更改性</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>读写存储器：即可读、也可写（如，磁盘、内存、cache</p>
</li>
<li class="lvl-2">
<p>只读存储器：只能读，不能写（如实体音乐专辑通常采用CD-ROM</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>事实上，很多ROM也可多次读写，只是比较麻烦</p>
</p>
    </div>
</div><h2 id="信息的可保存性"><a class="header-anchor" href="#信息的可保存性">¶</a>信息的可保存性</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>易失性存储器：断电后存储信息消失的存储器</p>
</li>
<li class="lvl-2">
<p>非易失性存储器：断电后，存储器信息任然保持</p>
</li>
<li class="lvl-2">
<p>破环性读出：信息读出后，原存储信息被破坏</p>
</li>
<li class="lvl-2">
<p>非破坏性读出：信息读出后，原存储信息不被破坏</p>
</li>
</ul>
<h2 id="存储器的性能指标"><a class="header-anchor" href="#存储器的性能指标">¶</a>存储器的性能指标</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>存储容量：存储字 * 字长</p>
</li>
<li class="lvl-2">
<p>单位成本：每位价格 = 总成本/总容量</p>
</li>
<li class="lvl-2">
<p>存储速度：<span style="color:red">数据传输率</span> = 数据的宽度<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="即存储字长">[1]</span></a></sup> / 存储周期</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>MDR 位数反应存储字长</p>
<p>MAR 位数反应存储字数</p>
<p>其中，存储字数 = $2^{\text{MAR位数}}$</p>
<p><img src="./assets/image-20241217170716626.png" alt="image-20241217170716626"></p>
</p>
    </div>
</div><p><img src="./assets/image-20241217170820557.png" alt="image-20241217170820557"></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">即存储字长<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理中固定分区的地址重定位与存储保护</title>
    <url>/posts/1c6fec2c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>在内存管理的固定分区方法中，地址重定位和存储保护是两个关键概念，它们确保程序正确执行并保护内存数据的完整性。以下是对这两个方面的详细解释：</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="1-地址重定位（Address-Relocation）"><a class="header-anchor" href="#1-地址重定位（Address-Relocation）">¶</a>1. 地址重定位（Address Relocation）</h3>
<p><strong>地址重定位</strong>是指将程序的逻辑地址转换为物理地址的过程。在固定分区内存管理中，内存被划分为若干固定大小的分区，每个分区都可能被一个进程占用。当程序装载到某个分区时，逻辑地址需要被调整为物理地址，以正确访问内存中的数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>逻辑地址与物理地址</strong></p>
<ul class="lvl-2">
<li class="lvl-4"><strong>逻辑地址</strong>：由程序生成，通常从 0 开始，描述程序内部的内存访问。</li>
<li class="lvl-4"><strong>物理地址</strong>：程序实际运行时的内存地址，由操作系统或硬件计算得出。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>重定位的方式</strong></p>
<ol>
<li class="lvl-5">静态重定位：
<ul class="lvl-4">
<li class="lvl-7">程序在装载时由操作系统将逻辑地址加上分区的起始地址，转换为物理地址。</li>
<li class="lvl-7">该方法简单，但程序装载后地址固定，无法移动。</li>
</ul>
</li>
<li class="lvl-5">动态重定位：
<ul class="lvl-4">
<li class="lvl-7">程序运行时，通过硬件中的**重定位寄存器（Base Register）**实时完成地址转换。</li>
<li class="lvl-7">在访问内存时，硬件会将逻辑地址加上分区的起始地址来计算物理地址。</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>示例</strong>： 如果一个程序需要访问逻辑地址 100，而该程序被加载到起始地址为 1000 的分区中，则：</p>
<ul class="lvl-2">
<li class="lvl-4">物理地址 = 分区起始地址 + 逻辑地址 = 1000 + 100 = 1100</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-存储保护（Memory-Protection）"><a class="header-anchor" href="#2-存储保护（Memory-Protection）">¶</a>2. 存储保护（Memory Protection）</h3>
<p><strong>存储保护</strong>的目的是防止一个程序访问到其他程序或操作系统的内存，确保内存安全性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>实现方法</strong>：</p>
<ol>
<li class="lvl-5">界限寄存器（Limit Register）：
<ul class="lvl-4">
<li class="lvl-7">每个分区设置一个界限寄存器，记录该分区的最大地址范围。</li>
<li class="lvl-7">在访问内存时，硬件检查物理地址是否在分区范围内，超出范围则触发保护异常（Protection Fault）。</li>
</ul>
</li>
<li class="lvl-5">重定位寄存器和界限寄存器联合使用：
<ul class="lvl-4">
<li class="lvl-7"><strong>重定位寄存器</strong>保存分区的起始地址，用于地址转换。</li>
<li class="lvl-7"><strong>界限寄存器</strong>保存分区大小，用于检查是否越界。</li>
<li class="lvl-7">访问内存时，实际地址需满足：<br>
<code>实际地址 &gt;= 起始地址</code> 且 <code>实际地址 &lt; 起始地址 + 分区大小</code></li>
</ul>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>保护机制的作用</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">防止一个程序越界访问其他分区的内存。</li>
<li class="lvl-4">避免意外覆盖操作系统或其他程序的关键数据。</li>
<li class="lvl-4">在多道程序系统中，保障各进程互不干扰。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>示例</strong>： 假设分区起始地址为 1000，分区大小为 500：</p>
<ul class="lvl-2">
<li class="lvl-4">合法范围：1000 ≤ 地址 &lt; 1500</li>
<li class="lvl-4">如果程序试图访问地址 1600，硬件会检测到越界并触发保护异常。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-地址重定位与存储保护的结合"><a class="header-anchor" href="#3-地址重定位与存储保护的结合">¶</a>3. 地址重定位与存储保护的结合</h3>
<p>在固定分区中，地址重定位和存储保护通常通过硬件协作实现：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个分区分配一个<strong>重定位寄存器</strong>和一个<strong>界限寄存器</strong>。</p>
</li>
<li class="lvl-2">
<p>在程序访问内存时：</p>
<ol>
<li class="lvl-5">重定位寄存器负责将逻辑地址转换为物理地址。</li>
<li class="lvl-5">界限寄存器确保转换后的物理地址在合法范围内。</li>
</ol>
</li>
<li class="lvl-2">
<p>若地址转换或越界检查失败，操作系统会终止相关程序，并防止内存损坏。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>地址重定位</strong>解决了程序在不同内存分区中的装载问题，使逻辑地址转换为物理地址。</p>
</li>
<li class="lvl-2">
<p><strong>存储保护</strong>通过限制内存访问范围，确保程序运行的安全性和稳定性。</p>
</li>
<li class="lvl-2">
<p>在固定分区方法中，这两者结合通过硬件（如寄存器）实现高效的内存管理和保护。</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily Words</title>
    <url>/posts/4c75609f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<p>campus /'kæmpəs/  n. 大学，大学生活；</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>动态链接库与CMake</title>
    <url>/posts/376b14fc.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>CMake 和动态链接库（DLL 或共享库）关系密切，因为 CMake 是一种构建工具，可以用来生成、管理和使用动态链接库。通过 CMake，可以轻松地定义动态库的构建规则，并在项目中加载或链接这些库。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CMake-与动态链接库的关系"><a class="header-anchor" href="#CMake-与动态链接库的关系">¶</a>CMake 与动态链接库的关系</h3>
<p>CMake 和动态链接库（DLL 或共享库）关系密切，因为 CMake 是一种构建工具，可以用来生成、管理和使用动态链接库。通过 CMake，可以轻松地定义动态库的构建规则，并在项目中加载或链接这些库。</p>
<hr>
<h3 id="CMake-如何生成动态链接库"><a class="header-anchor" href="#CMake-如何生成动态链接库">¶</a>CMake 如何生成动态链接库</h3>
<p>动态链接库（Dynamic Link Library，Windows 下通常是 <code>.dll</code>，Linux 下是 <code>.so</code>，macOS 下是 <code>.dylib</code>）的构建需要指定库的类型。CMake 提供了灵活的机制来创建动态库。</p>
<h4 id="示例：创建动态链接库"><a class="header-anchor" href="#示例：创建动态链接库">¶</a>示例：创建动态链接库</h4>
<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── library/</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── my_library.cpp</span><br><span class="line">│   └── my_library.h</span><br><span class="line">├── app/</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.cpp</span><br></pre></td></tr></table></figure>
<h4 id="1-编写动态库的代码"><a class="header-anchor" href="#1-编写动态库的代码">¶</a>1. 编写动态库的代码</h4>
<p><code>library/my_library.h</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>library/my_library.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-编写-library-CMakeLists-txt"><a class="header-anchor" href="#2-编写-library-CMakeLists-txt">¶</a>2. 编写 <code>library/CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_library SHARED my_library.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置库的输出名称（可选）</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(my_library PROPERTIES OUTPUT_NAME <span class="string">&quot;my_dynamic_library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库头文件供外部使用</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_library PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><code>SHARED</code> 标志表示生成动态链接库。如果需要生成静态库，可以将其替换为 <code>STATIC</code>。</p>
<hr>
<h3 id="3-使用动态链接库"><a class="header-anchor" href="#3-使用动态链接库">¶</a>3. 使用动态链接库</h3>
<p><code>app/main.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 + 3 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-编写-app-CMakeLists-txt"><a class="header-anchor" href="#4-编写-app-CMakeLists-txt">¶</a>4. 编写 <code>app/CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE my_library)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="5-根目录-CMakeLists-txt"><a class="header-anchor" href="#5-根目录-CMakeLists-txt">¶</a>5. 根目录 <code>CMakeLists.txt</code></h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(DynamicLibraryExample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(library)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(app)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-构建和运行"><a class="header-anchor" href="#6-构建和运行">¶</a>6. 构建和运行</h3>
<p>在项目根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成构建系统</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建项目</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>运行生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/app/my_app</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="CMake-使用动态库的常见场景"><a class="header-anchor" href="#CMake-使用动态库的常见场景">¶</a>CMake 使用动态库的常见场景</h3>
<ol>
<li class="lvl-3">
<p><strong>动态加载动态库</strong><br>
通过操作系统接口（如 <code>dlopen</code> 和 <code>LoadLibrary</code>）加载动态库并调用其函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span> <span class="comment">// Linux/macOS</span></span></span><br><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;my_dynamic_library.so&quot;</span>, RTLD_LAZY);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查找系统动态库</strong><br>
使用 CMake 的 <code>find_library</code> 命令查找系统中已安装的动态库。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(MY_LIB my_library PATHS /usr/lib /usr/local/lib)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE <span class="variable">$&#123;MY_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>安装动态库</strong><br>
配置安装规则，将动态库安装到指定路径。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS my_library DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES my_library.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>控制动态库版本</strong><br>
CMake 支持为动态库设置版本号，用于兼容性管理。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(my_library PROPERTIES VERSION <span class="number">1.0</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="动态库的优点通过-CMake-放大"><a class="header-anchor" href="#动态库的优点通过-CMake-放大">¶</a>动态库的优点通过 CMake 放大</h3>
<ol>
<li class="lvl-3">
<p><strong>模块化构建</strong><br>
动态库可与多个项目共享，CMake 管理动态库的构建和链接更加简单。</p>
</li>
<li class="lvl-3">
<p><strong>跨平台兼容</strong><br>
CMake 抽象了不同平台的动态库细节（如 <code>.dll</code> 和 <code>.so</code> 的差异），开发者只需专注于库的功能实现。</p>
</li>
<li class="lvl-3">
<p><strong>依赖关系管理</strong><br>
CMake 能自动处理动态库的依赖，确保库按正确顺序链接。</p>
</li>
<li class="lvl-3">
<p><strong>动态库的安装和部署</strong><br>
使用 CMake，可以轻松地将动态库与项目一起打包并分发。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>CMake 与动态链接库密切相关，是开发和管理动态库的理想工具。通过 CMake，可以轻松完成动态库的创建、链接、加载、安装和跨平台管理，显著简化复杂项目的开发流程。</p>
<p>如需进一步了解动态库的特定实现或动态加载，可以提供更详细的场景！</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/posts/42cbd3c8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>CMake</strong> 是一种跨平台的构建工具，用于管理软件项目的构建流程。它通过使用配置文件（<code>CMakeLists.txt</code>）来生成适合特定平台的原生构建系统文件，如 <strong>Makefile</strong>（Linux）或 <strong>Visual Studio 工程文件</strong>（Windows）。</p>
<p>CMake 的目标是让开发者在不同的操作系统和编译器之间轻松地构建、测试和打包软件项目。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CMake-简介"><a class="header-anchor" href="#CMake-简介">¶</a>CMake 简介</h3>
<p><strong>CMake</strong> 是一种跨平台的构建工具，用于管理软件项目的构建流程。它通过使用配置文件（<code>CMakeLists.txt</code>）来生成适合特定平台的原生构建系统文件，如 <strong>Makefile</strong>（Linux）或 <strong>Visual Studio 工程文件</strong>（Windows）。</p>
<p>CMake 的目标是让开发者在不同的操作系统和编译器之间轻松地构建、测试和打包软件项目。</p>
<hr>
<h3 id="CMake-的主要特点"><a class="header-anchor" href="#CMake-的主要特点">¶</a>CMake 的主要特点</h3>
<ol>
<li class="lvl-3">
<p><strong>跨平台支持</strong>：支持 Windows、Linux、macOS，以及嵌入式系统开发。</p>
</li>
<li class="lvl-3">
<p><strong>生成原生构建文件</strong>：通过 <code>CMakeLists.txt</code>，生成适合平台的构建系统文件。</p>
</li>
<li class="lvl-3">
<p><strong>模块化管理</strong>：支持分模块编译和依赖关系管理。</p>
</li>
<li class="lvl-3">
<p><strong>灵活的配置</strong>：支持多种构建选项（如 Debug/Release）。</p>
</li>
<li class="lvl-3">
<p><strong>集成测试工具</strong>：可以通过 CTest 实现测试自动化。</p>
</li>
<li class="lvl-3">
<p><strong>广泛支持的工具链</strong>：支持多种编译器（GCC、Clang、MSVC 等）和工具链（Ninja 等）。</p>
</li>
</ol>
<hr>
<h3 id="CMake-的基本使用流程"><a class="header-anchor" href="#CMake-的基本使用流程">¶</a>CMake 的基本使用流程</h3>
<ol>
<li class="lvl-3">
<p><strong>安装 CMake</strong>：在系统中安装 CMake，可通过包管理工具（如 apt、yum、brew）或官网下载安装包。</p>
</li>
<li class="lvl-3">
<p><strong>创建 CMakeLists.txt</strong>：编写一个 <code>CMakeLists.txt</code> 文件，描述项目的构建流程。</p>
</li>
<li class="lvl-3">
<p><strong>运行 CMake</strong>：使用 <code>cmake</code> 命令生成构建系统文件（如 Makefile）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>构建项目</strong>：使用生成的构建文件进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="一个简单的-CMake-示例"><a class="header-anchor" href="#一个简单的-CMake-示例">¶</a>一个简单的 CMake 示例</h3>
<p>假设有以下项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br></pre></td></tr></table></figure>
<h4 id="1-编写-main-cpp"><a class="header-anchor" href="#1-编写-main-cpp">¶</a>1. 编写 <code>main.cpp</code></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, CMake!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-编写-CMakeLists-txt"><a class="header-anchor" href="#2-编写-CMakeLists-txt">¶</a>2. 编写 <code>CMakeLists.txt</code></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 的最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(HelloCMake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br></pre></td></tr></table></figure>
<h4 id="3-构建项目"><a class="header-anchor" href="#3-构建项目">¶</a>3. 构建项目</h4>
<p>在项目根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成构建系统文件</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>运行生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/hello</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="CMake-的核心命令"><a class="header-anchor" href="#CMake-的核心命令">¶</a>CMake 的核心命令</h3>
<ol>
<li class="lvl-3">
<p><code>project</code>：定义项目名称及支持的语言。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject LANGUAGES CXX)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>add_executable</code>：添加可执行文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_program main.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>add_library</code>：添加库文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_library STATIC lib.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>target_include_directories</code>：指定头文件路径。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(my_program PRIVATE <span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><code>target_link_libraries</code>：链接库文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_program PRIVATE my_library)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="CMake-的优势"><a class="header-anchor" href="#CMake-的优势">¶</a>CMake 的优势</h3>
<ol>
<li class="lvl-3">
<p><strong>自动化管理依赖关系</strong>：轻松管理第三方库和自定义模块。</p>
</li>
<li class="lvl-3">
<p><strong>适应性强</strong>：支持不同编译器和平台。</p>
</li>
<li class="lvl-3">
<p><strong>模块支持</strong>：自带许多模块（如查找库、设置编译选项）</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接库</title>
    <url>/posts/29b48e9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>动态链接库（Dynamic Link Library，简称DLL）是包含可以由多个程序共享使用的代码和数据的文件。这种技术使程序能够高效地复用资源、减少重复代码以及节省内存空间。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="动态链接库的特点："><a class="header-anchor" href="#动态链接库的特点：">¶</a>动态链接库的特点：</h3>
<ol>
<li class="lvl-3">
<p><strong>动态加载</strong>：程序运行时，DLL文件才会被加载到内存中。</p>
</li>
<li class="lvl-3">
<p><strong>共享资源</strong>：多个程序可以同时使用同一个DLL文件，减少重复代码占用的磁盘和内存资源。</p>
</li>
<li class="lvl-3">
<p><strong>模块化开发</strong>：通过动态链接库，可以将应用程序拆分为多个模块，方便独立开发、测试和部署。</p>
</li>
<li class="lvl-3">
<p><strong>可更新性</strong>：更新程序时，只需替换DLL文件，无需更改主程序。</p>
</li>
</ol>
<hr>
<h3 id="DLL的应用场景："><a class="header-anchor" href="#DLL的应用场景：">¶</a>DLL的应用场景：</h3>
<ol>
<li class="lvl-3">
<p><strong>共享代码和功能</strong>：如Windows的系统功能（<code>user32.dll</code>、<code>kernel32.dll</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>插件系统</strong>：支持动态加载的插件，提供功能扩展。</p>
</li>
<li class="lvl-3">
<p><strong>跨语言调用</strong>：通过DLL，允许不同编程语言的程序共享同一段功能代码。</p>
</li>
<li class="lvl-3">
<p><strong>节省资源</strong>：避免重复代码的加载。</p>
</li>
</ol>
<hr>
<h3 id="使用动态链接库的注意事项："><a class="header-anchor" href="#使用动态链接库的注意事项：">¶</a>使用动态链接库的注意事项：</h3>
<ol>
<li class="lvl-3">
<p><strong>版本兼容性</strong>：更新DLL时必须保证接口兼容，否则可能导致主程序崩溃。</p>
</li>
<li class="lvl-3">
<p><strong>依赖问题</strong>：动态链接库可能依赖其他库，必须确保相关库也被正确部署。</p>
</li>
<li class="lvl-3">
<p><strong>安全性</strong>：动态链接库容易受到DLL劫持（DLL Hijacking）攻击，加载DLL时需指定明确路径或使用签名校验。</p>
</li>
</ol>
<hr>
<h4 id="如何创建和使用动态链接库？"><a class="header-anchor" href="#如何创建和使用动态链接库？">¶</a>如何创建和使用动态链接库？</h4>
<p><strong>C++（Windows平台示例）</strong><br>
创建一个简单的动态链接库（<code>.dll</code>）并调用。</p>
<h5 id="创建DLL："><a class="header-anchor" href="#创建DLL：">¶</a>创建DLL：</h5>
<ol>
<li class="lvl-3">
<p>创建<code>mydll.cpp</code>文件：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World from DLL!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>使用命令行编译为DLL：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cl /LD mydll.cpp</span><br></pre></td></tr></table></figure>
<p>生成的<code>mydll.dll</code>就是动态链接库。</p>
<h5 id="调用DLL："><a class="header-anchor" href="#调用DLL：">¶</a>调用DLL：</h5>
<ol>
<li class="lvl-3">
<p>创建<code>main.cpp</code>文件：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HelloWorldFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;mydll.dll&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (hModule) &#123;</span><br><span class="line">        HelloWorldFunc hello = (HelloWorldFunc)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hello) &#123;</span><br><span class="line">            <span class="built_in">hello</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hModule);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to load DLL&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>编译并运行，确保<code>mydll.dll</code>在同一目录下。</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>编程知识</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>OS第五章总结</title>
    <url>/posts/6070b0ed.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一下存储器管理的笔记把</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="学习目标"><a class="header-anchor" href="#学习目标">¶</a>学习目标</h2>
<p>Ø能够理解各层存储器的作用</p>
<p>Ø理解存储管理的基本任务</p>
<p>Ø理解逻辑地址、物理地址的概念</p>
<p>Ø理解程序装入的实现方式及特点</p>
<p>Ø理解程序链接的实现方式及特点</p>
<h2 id="目标评价"><a class="header-anchor" href="#目标评价">¶</a>目标评价</h2>
<ol>
<li class="lvl-3">
<p>说出常见的计算机存储硬件</p>
</li>
<li class="lvl-3">
<p>说出存储层次中各硬件的特点</p>
</li>
<li class="lvl-3">
<p>分析源程序、目标程序和可执行程序的地址形式</p>
</li>
<li class="lvl-3">
<p>理解CPU对内存的访问过程</p>
</li>
<li class="lvl-3">
<p>说出程序的装入和链接方式</p>
</li>
</ol>
<h2 id="基础概念"><a class="header-anchor" href="#基础概念">¶</a>基础概念</h2>
<h3 id="内存管理的任务"><a class="header-anchor" href="#内存管理的任务">¶</a>内存管理的任务</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配回收</p>
</li>
<li class="lvl-2">
<p>地址转换</p>
</li>
<li class="lvl-2">
<p>存储扩充</p>
</li>
<li class="lvl-2">
<p>存储保护</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>学后应能够回答的问题</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131403033.png" alt="image-20241213140352275"></p>
</p>
    </div>
</div><h3 id="存储器的层次结构"><a class="header-anchor" href="#存储器的层次结构">¶</a>存储器的层次结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131405756.png" alt="image-20241213140513750"></p>
<center><small>计算机存储层次示意图</small></center>
<h4 id="寄存器"><a class="header-anchor" href="#寄存器">¶</a>寄存器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>存放<code>CPU</code>执行时的数据和指令</p>
</li>
</ul>
<h4 id="高速缓存"><a class="header-anchor" href="#高速缓存">¶</a>高速缓存</h4>
<p>介于寄存器和存储器之间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>备份主存常用数据和指令，减少对主存储器的访问次数</p>
</li>
<li class="lvl-2">
<p>缓和内存和处理机之间的矛盾</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131408580.png" alt="image-20241213140854868"></p>
<center><small>多级缓存</small></center>
<p>l1d：一级数据缓存</p>
<p>L1i：一级指令缓存</p>
<p>L2 cache：二级缓存</p>
<p>L3 cache：三级缓存</p>
</p>
    </div>
</div><h4 id="磁盘缓存"><a class="header-anchor" href="#磁盘缓存">¶</a>磁盘缓存</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>暂时存放频繁使用的一部分磁盘数据和信息</p>
</li>
<li class="lvl-2">
<p>缓和主存和I/O设备在速度上的额不匹配</p>
</li>
<li class="lvl-2">
<p><strong>利用主存的部分空间，主存可看成辅存的高速缓存</strong></p>
</li>
</ul>
<h4 id="主存"><a class="header-anchor" href="#主存">¶</a>主存</h4>
<h5 id="性能指标"><a class="header-anchor" href="#性能指标">¶</a>性能指标</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>按<strong>字节</strong>连续编址，没个存储单元为1个字节<small>(8个二进制位)</small></p>
</li>
<li class="lvl-2">
<p>存储容量：所包含的存储单元总数<small>(单位：MB或GB)</small></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131419619.png" alt="image-20241213141949137"></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>简例</h5>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131421631.png" alt="image-20241213142102753"></p>
</p>
    </div>
</div><h3 id="程序地址"><a class="header-anchor" href="#程序地址">¶</a>程序地址</h3>
<h4 id="程序在成为进程前的准备工作"><a class="header-anchor" href="#程序在成为进程前的准备工作">¶</a>程序在成为进程前的准备工作</h4>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>总结</h5>
<h6>程序在成为进程前的准备工作</h6>
<ul class="lvl-1">
<li class="lvl-2">
<p><span style="color:red">编辑</span>：形成源文件(<span style="color:blue">符号地址</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">编译</span>：形成目标模块(<span style="color:blue">模块内符号地址解析</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">链接</span>：由多个模块或程序库形成可执行文件(<span style="color:blue">模块间符号地址解析</span>)</p>
</li>
<li class="lvl-2">
<p><span style="color:red">装入</span>：构造PCB，形成进程(<span style="color:blue">物理地址</span>)</p>
</li>
</ul>
</p>
    </div>
</div><ol>
<li class="lvl-3">
<p>编辑：编写源程序</p>
</li>
<li class="lvl-3">
<p>编译：由编译程序<small>(Complier)</small>对源程序进行编译，形成若干个目标模块</p>
</li>
<li class="lvl-3">
<p>链接：由链接程序<small>(Linker)</small>将目标模块和他们所需要的库函数链接在一起，形成一个完整的装入模块</p>
</li>
<li class="lvl-3">
<p>装入：由装入程序<small>(Loader)</small>，将装入模块装入内存</p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>就像C语言代码，到运行的过程：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>编译</p>
</li>
<li class="lvl-2">
<p>链接</p>
</li>
<li class="lvl-2">
<p>运行</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="程序各阶段的地址变换"><a class="header-anchor" href="#程序各阶段的地址变换">¶</a>程序各阶段的地址变换</h4>
<ol>
<li class="lvl-3">
<p>源程序编译后的main.s</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131438484.png" alt="image-20241213143808948"></p>
<p>add：符号表示</p>
<p><big><strong>符号地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>源程序汇编后的main.o和test.o反汇编的文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131438521.png" alt="image-20241213143843828"></p>
<p>13：整数值</p>
<p><big><strong>相对地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>可执行程序myprog</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131440028.png" alt="image-20241213144033296"></p>
<p>4004e2 ：整数值</p>
<p><big><strong>相对地址</strong></big></p>
<hr>
</li>
<li class="lvl-3">
<p>可执行文件装入内存执行时的地址？</p>
<p>内存单元地址<small><span style="color:red">由CPU对内存的访问方式决定</span></small></p>
</li>
</ol>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>编译、汇编、链接，三个过程的地址变换是编译器做的</p>
<p>而，将生成好的可执行文件，放到内存中运行，是操作系统要考虑的事情</p>
</p>
    </div>
</div><h4 id="物理地址和逻辑地址"><a class="header-anchor" href="#物理地址和逻辑地址">¶</a>物理地址和逻辑地址</h4>
<h5 id="物理地址-small-绝对地址-small"><a class="header-anchor" href="#物理地址-small-绝对地址-small">¶</a>物理地址<small>(绝对地址)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>物理内存的地址，内存以字节位单位编址</p>
</li>
<li class="lvl-2">
<p>物理地址空间：所有物理地址的集合</p>
</li>
</ul>
<h5 id="逻辑地址-small-虚拟地址、相对地址-small"><a class="header-anchor" href="#逻辑地址-small-虚拟地址、相对地址-small">¶</a>逻辑地址<small>(虚拟地址、相对地址)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>由CPU产生的地址，即成程序编译后使用的相对于0字节的地址</p>
</li>
<li class="lvl-2">
<p>逻辑地址空间：由程序所生成的所有逻辑地址的集合</p>
</li>
</ul>
<h5 id="地址转换-small-地址重定位、地址映射-small"><a class="header-anchor" href="#地址转换-small-地址重定位、地址映射-small">¶</a>地址转换<small>(地址重定位、地址映射)</small></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序中的逻辑地址转换为物理地址</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><span style="color:red">地址转换是操作系统内存管理任务之一</span></p>
</p>
    </div>
</div><h3 id="程序的装入"><a class="header-anchor" href="#程序的装入">¶</a>程序的装入</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131504204.png" alt="image-20241213150423225"></p>
<center><small>程序装入示意图</small></center>
<h4 id="地址转换时期"><a class="header-anchor" href="#地址转换时期">¶</a>地址转换时期</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>绝对装入方式</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>编译</strong>产生的地址使用<strong>绝对地址</strong></li>
<li class="lvl-4">程序或数据被修改时，需要重新编译程序</li>
</ul>
</li>
<li class="lvl-2">
<p>可重定位装入方式</p>
<ul class="lvl-2">
<li class="lvl-4">编译后的目标模块使用相对地址</li>
<li class="lvl-4">在<strong>装入</strong>时，完成<strong>重定位</strong><big>(静态重定位)</big></li>
<li class="lvl-4">需硬件支持</li>
</ul>
</li>
<li class="lvl-2">
<p>动态运行时装入方式</p>
<ul class="lvl-2">
<li class="lvl-4">编译后的目标模块使用相对地址</li>
<li class="lvl-4">在<strong>运行</strong>时，完成重定位<big>(动态重定位)</big></li>
</ul>
</li>
</ul>
<h4 id="程序的链接"><a class="header-anchor" href="#程序的链接">¶</a>程序的链接</h4>
<h5 id="静态链接"><a class="header-anchor" href="#静态链接">¶</a>静态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在程序运行前，将各目标模块及它们所需的库函数链接成一个完整的装配模块</p>
</li>
<li class="lvl-2">
<p>对相对地址进行修改；变换外部调用符号</p>
</li>
</ul>
<h5 id="装入时动态链接"><a class="header-anchor" href="#装入时动态链接">¶</a>装入时动态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>在装入内存时，采用边装入边链接的链接方式</p>
</li>
<li class="lvl-2">
<p>便于修改和更新</p>
</li>
<li class="lvl-2">
<p>便于实现对目标模块的共享</p>
</li>
</ul>
<h5 id="运行时动态链接"><a class="header-anchor" href="#运行时动态链接">¶</a>运行时动态链接</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>将某些目标模块的链接推迟到执行时才执行</p>
</li>
<li class="lvl-2">
<p>加快装入过程，节省大量的内存空间</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>对于<strong>运行时动态链接</strong>，动态链接库像是相关联的东西</p>
<h4>动态链接库<small><a href="/posts/29b48e9">详细介绍</a></small></h4>
<p>动态链接库（Dynamic Link Library，简称DLL）是包含可以由多个程序共享使用的代码和数据的文件。这种技术使程序能够高效地复用资源、减少重复代码以及节省内存空间。</p>
</p>
    </div>
</div>
<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<div style="overflow:hidden;"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131612602.png" alt="image-20241213161228676" style="zoom:40%;float:left;" /><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131614525.png" alt="image-20241213161403091" style="zoom:40%;float:right;" /></div>
<center><small>链接示意图</small></center>
</p>
    </div>
</div><hr>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>各种存储管理方案</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131617839.png" alt="image-20241213161739973"></p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>学习目标</h3>
<p><big><span style="color:blue"><strong>掌握各种存储管理方案的内存分配回收、数据结构、地址转换、存储保护、主要技术、优缺点</strong></span></big></p>
<ul class="lvl-1">
<li class="lvl-2">
<p>能够分析单一分区、固定分区、动态分区的管理方式及优缺点</p>
</li>
<li class="lvl-2">
<p>掌握操作系统分区管理的数据结构、分区分配算法、回收算法</p>
</li>
<li class="lvl-2">
<p>理解并应用分区管理的地址变换方法</p>
</li>
<li class="lvl-2">
<p>掌握分区管理的内存扩充技术：交换、覆盖、紧凑</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131622972.png" alt="image-20241213162230528"></p>
</p>
    </div>
</div><h2 id="连续分配存储管理方式"><a class="header-anchor" href="#连续分配存储管理方式">¶</a>连续分配存储管理方式</h2>
<p><span style="color:red">连续存储方式：</span>为一个用户程序分配一个连续的内存空间</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>分类</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>单一连续分区</p>
</li>
<li class="lvl-2">
<p>固定连续分区</p>
</li>
<li class="lvl-2">
<p>动态分区分配</p>
</li>
<li class="lvl-2">
<p>动态可重定位分区分配</p>
</li>
</ul>
</p>
    </div>
</div><h3 id="单一连续分区"><a class="header-anchor" href="#单一连续分区">¶</a>单一连续分区</h3>
<h4 id="分配方式"><a class="header-anchor" href="#分配方式">¶</a>分配方式</h4>
<p><strong>单道</strong>程序环境下，仅装有一道用户程序，整个内存的用户空间由该程序独占。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配管理非常简单，内存利用率低</p>
</li>
<li class="lvl-2">
<p>用于单用户、单任务OS</p>
</li>
<li class="lvl-2">
<p>CP/M、MS-DOS、RT11</p>
</li>
</ul>
<h3 id="固定分区"><a class="header-anchor" href="#固定分区">¶</a>固定分区</h3>
<h4 id="管理方式"><a class="header-anchor" href="#管理方式">¶</a>管理方式</h4>
<p>多个分区可装多道程序</p>
<p>分区大小固定</p>
<p>分区个数固定</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412131631934.png" alt="image-20241213163147362"></p>
<center><small>固定分区(大小相同)<small>(左)</small>，固定分区(大小不同)<small>(右)</small></small></center>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>固定分区中，使用固定分区使用表来管理分区的使用情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151344340.png" alt="image-20241215134409673"></p>
<center><small>固定分区使用表</small></center>
</p>
    </div>
</div><h4 id="地址重定位与存储保护"><a class="header-anchor" href="#地址重定位与存储保护">¶</a>地址重定位与存储保护</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151346947.png" alt="image-20241215134606043"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态重定位</p>
</li>
<li class="lvl-2">
<p>界限寄存器</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>静态重定位</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>在<strong>程序装载</strong>时，<strong>由操作系统</strong>将逻辑地址加上分区的起始地址，转换为物理地址</p>
</li>
<li class="lvl-2">
<p>该方法简单，但程序装载后地址固定，无法移动<small>(但固定分区情况下，程序确实不会发生移动)</small></p>
</li>
</ul>
<h5>界限寄存器</h5>
<ul class="lvl-1">
<li class="lvl-2">
<p>每一个分区设置一个界限寄存器，记录该分区的最大地址范围。</p>
</li>
<li class="lvl-2">
<p>访问内存时，硬件检查物理地址是否在分区范围内，超出范围则触发包含异常。</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h4>
<p>优点：易于实现，开销小</p>
<p><span style="color:red">问题</span>：</p>
<ol>
<li class="lvl-3">
<p>可能存在内碎片和外碎片</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>内碎片</strong>：占用分区之内未被利用的空间</p>
<p><strong>外碎片</strong>：占用分区之间难以利用的空闲分区<small>通常是小的空闲分区</small></p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>举个例子：</p>
<p>例如，现在操作系统分给的固定分区大小为16k</p>
<p>但是又进程现在申请12k大小的内存，但是由于操作系统为固定分区模式，所以只能给该进程分一个大小为16k的分区，这样就有4k空间被浪费了，这浪费的4K空间称为内碎片</p>
<p>另外，再比如，现在操作系统仅剩下1K的存储空间，所有进程都无法装入，这1K存储空间，就称为内碎片</p>
</p>
    </div>
</div></p>
    </div>
</div></li>
<li class="lvl-3">
<p>分区数固定，限制了并发执行的程序数目</p>
</li>
</ol>
<h3 id="动态分区"><a class="header-anchor" href="#动态分区">¶</a>动态分区</h3>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439067.png" alt="image-20241215143909924"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439724.png" alt="image-20241215143929060"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151439958.png" alt="image-20241215143947058"></p>
<center><small>动态分区示意图</small></center>
<h4 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151500000.png" alt="image-20241215150022370"></p>
<center><small>已分配分区表</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151501017.png" alt="image-20241215150156082"></p>
<center><small>空闲分区表</small></center>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412151503462.png" alt="image-20241215150357079"></p>
<center><small>空闲分区链</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>空闲分区链用于高效的管理空闲内存块</p>
<p>看起来，每一个空闲分区中，都会存放下一个空闲分区的首地址</p>
<p>另外，还会存放当前分区的大小</p>
</p>
    </div>
</div><h4 id="分配算法"><a class="header-anchor" href="#分配算法">¶</a>分配算法</h4>
<h5 id="基于-span-style-color-blue-顺序搜索-span-的动态分区分配算法"><a class="header-anchor" href="#基于-span-style-color-blue-顺序搜索-span-的动态分区分配算法">¶</a>基于<span style="color:blue">顺序搜索</span>的动态分区分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>依次搜索空闲分区链上的空闲分区，寻找一个大小能够满足要求的分区</p>
</li>
<li class="lvl-2">
<p>首次适应算法、循环适应算法、最佳适应算法、最坏适应算法</p>
</li>
</ul>
<h6 id="首次适应算法"><a class="header-anchor" href="#首次适应算法">¶</a>首次适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>空闲分区链以<strong>地址</strong>递增的次序链接<small>(<span style="color:red;">注意！</span>这里不是按照空闲分区的大小进行链接)</small></p>
</li>
<li class="lvl-2">
<p>从链首开始顺序查找，直到找到一个大小能够满足要求的空闲分区为止</p>
<p><span style="color:blue"><small>此处的含义是：当找到一处空闲块，空闲分区的大小<strong>大于</strong>当前需要装入的进程时，就会将该空闲块中<strong>进程所需要的部分</strong>  分给进程，剩下的部分<strong>仍作为空闲分区</strong></small></span></p>
</li>
<li class="lvl-2">
<p>缺点：低址部分留下许多小碎片</p>
</li>
</ul>
<h6 id="循环首次适应算法"><a class="header-anchor" href="#循环首次适应算法">¶</a>循环首次适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p><span style="color:red">从上次找到的空闲分区的下一个空闲分区开始查找</span>，直到找到一个能满足要求的空闲分区</p>
</li>
<li class="lvl-2">
<p>空闲分区分布更均匀，减少了查找的开销</p>
</li>
<li class="lvl-2">
<p>缺乏大的空闲分区</p>
</li>
</ul>
<h6 id="最佳适应算法"><a class="header-anchor" href="#最佳适应算法">¶</a>最佳适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>搜索整个序列，找到适合条件的最小分区进行分配</p>
</li>
<li class="lvl-2">
<p>空闲分区按其<strong>容量</strong>从小到大的顺序链接</p>
</li>
<li class="lvl-2">
<p>用最小空间满足要求；但留下许多难以利用的小碎片</p>
</li>
</ul>
<h6 id="最坏适应算法"><a class="header-anchor" href="#最坏适应算法">¶</a>最坏适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>搜索整个序列，寻找最大分区进行匹配</p>
</li>
<li class="lvl-2">
<p>空闲分区按其容量从大到小的顺序链接</p>
</li>
<li class="lvl-2">
<p>分割后空闲块任为较大空块；缺乏大的空闲分区</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>关于每种分配算法是否会产生 内/外碎片的讨论</h5>
<h6>首次适应算法</h6>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>不会产生内碎片</strong>：因为首次适应算法中，每次分给进程的都是刚好够进程请求的</p>
</li>
<li class="lvl-2">
<p><strong>会产生外碎片</strong>：因为随着申请的进程数越来越多，空闲块就会被拆的越来越小，直到最后无法分给任何一个进程</p>
</li>
</ul>
<h6>循环首次适应</h6>
<p>其实和首次适应算法差不多</p>
<h6>最佳适应算法</h6>
<p>也是动态分区的一种</p>
<p>一般来说，动态分区都是不会产生内碎片的，因为给进程分的，都恰好是进程所需要的</p>
<p>但由于是动态分区，则不可避免空闲块被切的越来越小，直到无法分给任何进程</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实，<em>循环首次适应、最佳适应、最坏适应</em>，都只是对首次适应算法的改进，都只是修改了适应算法，而分配空间的核心相同</p>
</p>
    </div>
</div></p>
    </div>
</div><h5 id="基于-span-style-color-red-索引搜索-span-的动态分区分配算法"><a class="header-anchor" href="#基于-span-style-color-red-索引搜索-span-的动态分区分配算法">¶</a>基于<span style="color:red">索引搜索</span>的动态分区分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>提高搜索分区的速度，在大、中型系统中采用</p>
</li>
<li class="lvl-2">
<p>快速适应算法、伙伴系统和哈希算法</p>
</li>
</ul>
<h6 id="快速适应算法"><a class="header-anchor" href="#快速适应算法">¶</a>快速适应算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>将空闲分区按其容量大小进行分类，具有相同容量的所有空闲分区设有一个空闲分区链表</p>
</li>
<li class="lvl-2">
<p>分配时，根据进程长度，从索引表中寻找能容纳它的最小空闲分区链表；从链表取下第一块进行分配</p>
</li>
<li class="lvl-2">
<p>特点</p>
<ul class="lvl-2">
<li class="lvl-4">优点：不分割分区，不产生碎片，查找效率高</li>
<li class="lvl-4">缺点：分区归还主存时算法复杂，系统开销较大，存在浪费</li>
</ul>
</li>
</ul>
<h6 id="伙伴系统"><a class="header-anchor" href="#伙伴系统">¶</a>伙伴系统</h6>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>固定分区方式不够灵活，当进程大小与空闲分区大小不 匹配时，内存空间利用率很低。 动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。 伙伴系统 (buddy system)是介于固定分区与可变分区之间的动态分区技术。 <strong>伙伴：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块就称为“伙伴”。</strong></p>
<blockquote>
<p>摘自<a href="https://blog.csdn.net/weixin_45951642/article/details/124431231">存储器管理_OS_快速适应算法-CSDN博客</a></p>
</p>
    </div>
</div></blockquote>
<p>伙伴算法规定，无论已分配分区或空闲分区，其<span style="color:blue">大小均为 $2$ 的 $k$ 次幂</span>，$k$ 为整数，$n &lt;= k &lt;= m$，其中：$2^n$ 表示分配的最小分区大小，$2^m$ 标识分配的最大分区的大小，通常$2^m$ 是整个可分配内存的大小。</p>
<p>在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区。</p>
<p>内存管理模块保持有多个空闲块链表，空闲块的大小可以为 2，4，8，$2^m$ 字节（$m$ 为正整数）</p>
<p>系统初起时，只有一个最大的空闲块（整个内存）。</p>
<p><u>当一个长度为$n$的进程申请内存时，系统就分给它一个大于或等于所申请尺寸的最小的2的幂次的空闲块。</u><small>(<span style="color:blue">并没有一定和进程所需内存相同；即，即使进程用不了那么多，操作系统还是会分给它</span>)</small></p>
<p><strong>伙伴系统的缺点</strong>：不能有效的利用内存。进程大小不一定是2的整数被，因此会造成浪费，内碎片严重。</p>
<p>同时也会出现外碎片，因为还是会有进程无法放入较小的分区。</p>
<h4 id="内存分配流程"><a class="header-anchor" href="#内存分配流程">¶</a><strong>内存分配流程</strong></h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152058766.png" alt="image-20241215205802867"></p>
<h4 id="内存回收"><a class="header-anchor" href="#内存回收">¶</a>内存回收</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152059078.png" alt="image-20241215205944359"></p>
<h4 id="地址转换"><a class="header-anchor" href="#地址转换">¶</a>地址转换</h4>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152100324.png" alt="image-20241215210048568"></p>
<center><small>动态重定位示意图</small></center>
<h4 id="相关技术"><a class="header-anchor" href="#相关技术">¶</a>相关技术</h4>
<p>主存不足的存储管理技术</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存紧凑</p>
</li>
<li class="lvl-2">
<p>交换</p>
</li>
<li class="lvl-2">
<p>覆盖</p>
</li>
</ul>
<h2 id="分页存储管理"><a class="header-anchor" href="#分页存储管理">¶</a>分页存储管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152105924.png" alt="image-20241215210511208"></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152105463.png" alt="image-20241215210526994"></p>
<center><small>学习目标及目标评价</small></center>
<h3 id="分页存储的基本原理"><a class="header-anchor" href="#分页存储的基本原理">¶</a>分页存储的基本原理</h3>
<p>将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB）</p>
<p>每个分区就是一个“<strong>页框</strong>”<small>或称“<strong>页帧</strong>”、“<strong>内存块</strong>”、“<strong>物理块</strong>”</small></p>
<p>每个页框有一个编号，即“<strong>页框号</strong>”<small>或者“<strong>内存块号</strong>”、“<strong>页帧号</strong>”、“<strong>物理块号</strong>”</small></p>
<p>页框号从0开始。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152110600.png" alt="页与页框"></p>
<center><small>页与页框</small></center>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
<h3 id="地址结构"><a class="header-anchor" href="#地址结构">¶</a>地址结构</h3>
<p>内存地址(<span style="color:red">逻辑地址</span>)范围（1块大小为1KB）</p>
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152114213.png" alt="image-20241215211426833" style="zoom:50%;" />
<p>内存地址结构：</p>
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152115017.png" alt="image-20241215211502226" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152116919.png" alt="image-20241215211616857" style="zoom:80%;" />
<center><small><span style="color:red"><strong>分页地址中的结构(32位)</strong></span></small></center>
<h4 id="页号P"><a class="header-anchor" href="#页号P">¶</a>页号P</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>12-31位：20位</p>
</li>
<li class="lvl-2">
<p>地址空间最多运行有1M（$2^{20}$）页</p>
</li>
</ul>
<h4 id="位移量W（页内地址）"><a class="header-anchor" href="#位移量W（页内地址）">¶</a>位移量W（页内地址）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>0-11：12位</p>
</li>
<li class="lvl-2">
<p>每页大小为4KB（$2^{12}$）</p>
</li>
</ul>
<p>对某特定机器，地址结构是一定的。</p>
<p>若给抵挡一个逻辑地址空间中的地址为A，页面的大小为L，则<span style="color:red">页号P</span>和<span style="color:red">页内地址d</span>可按下式求得</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152124296.png" alt="image-20241215212411760"></p>
<h3 id="数据结构-2"><a class="header-anchor" href="#数据结构-2">¶</a>数据结构</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><big><span style="color:blue;">进程页表</span></big>：每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序；</p>
<ul class="lvl-2">
<li class="lvl-4">逻辑页表</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412152125190.png" alt="image-20241215212545948"></p>
<center><small>页表结构</small></center>
]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计网第二章</title>
    <url>/posts/bd8dd267.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>在地址转换过程中会访问两次页表嘛？</title>
    <url>/posts/c38ea43e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3><strong>总结</strong></h3>
<ol>
<li class="lvl-3">
<p>没有 TLB 的情况下，单级页表访问一次，多级页表可能需要访问两次甚至更多次。</p>
</li>
<li class="lvl-3">
<p>使用 TLB 后，大部分情况下只需访问一次页表（命中情况下直接完成转换），未命中的情况下才需访问页表的所有层级。</p>
</li>
</ol>
<p>通过 TLB 缓解页表访问延迟是现代虚拟存储管理的重要优化手段。</p>
</p>
    </div>
</div><span id="more"></span>
<hr>
<h3 id="1-单级页表的地址转换"><a class="header-anchor" href="#1-单级页表的地址转换">¶</a><strong>1. 单级页表的地址转换</strong></h3>
<p>在单级页表中，虚拟地址通过以下步骤转换为物理地址：</p>
<ol>
<li class="lvl-3">
<p><strong>页号查找</strong>：通过虚拟地址中的页号部分访问页表，找到对应的页表项，获取物理页号。</p>
</li>
<li class="lvl-3">
<p><strong>偏移量加法</strong>：将物理页号与虚拟地址中的页内偏移量结合，得到物理地址。</p>
</li>
</ol>
<p>此时，页表只需访问一次。但由于页表存储在主存中，这次访问本身也需要访问主存一次，增加了访问延迟。</p>
<hr>
<h3 id="2-多级页表的地址转换"><a class="header-anchor" href="#2-多级页表的地址转换">¶</a><strong>2. 多级页表的地址转换</strong></h3>
<p>在多级页表中（例如二级页表），为了减小页表占用的内存，页表被分解为多个层级。虚拟地址的转换过程如下：</p>
<ol>
<li class="lvl-3">
<p>从虚拟地址中提取多级页号（如一级页号和二级页号）。</p>
</li>
<li class="lvl-3">
<p><strong>第一级页表访问</strong>：使用一级页号查找一级页表，找到指向二级页表的地址。</p>
</li>
<li class="lvl-3">
<p><strong>第二级页表访问</strong>：使用二级页号查找二级页表，找到对应的物理页号。</p>
</li>
<li class="lvl-3">
<p><strong>偏移量加法</strong>：将物理页号与页内偏移量结合，生成最终物理地址。</p>
</li>
</ol>
<p>此时，由于需要分别访问一级页表和二级页表，因此需要两次内存访问。</p>
<hr>
<h3 id="3-TLB-的作用"><a class="header-anchor" href="#3-TLB-的作用">¶</a><strong>3. TLB 的作用</strong></h3>
<p>为了避免多次访问页表带来的性能开销，现代系统中通常会使用 <strong>TLB</strong> 来缓存常用的页表项。如果虚拟地址对应的页表项已经在 TLB 中：</p>
<ol>
<li class="lvl-3">
<p>地址转换直接通过 TLB 完成，只需访问一次主存。</p>
</li>
<li class="lvl-3">
<p>如果 TLB 未命中，则需要按上述流程访问多级页表，并更新 TLB。</p>
</li>
</ol>
<hr>
<h3 id="4-具体分析"><a class="header-anchor" href="#4-具体分析">¶</a><strong>4. 具体分析</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>单级页表</strong>：理论上只需访问一次页表（加上实际的数据访问总共两次主存访问）。</p>
</li>
<li class="lvl-2">
<p><strong>多级页表</strong>：可能需要访问页表两次（或更多次），再加上最终的数据访问，总计三次或更多主存访问。</p>
</li>
<li class="lvl-2">
<p><strong>带 TLB 的多级页表</strong>：在 TLB 命中的情况下，地址转换和数据访问总共只需两次主存访问。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<ol>
<li class="lvl-3">
<p>没有 TLB 的情况下，单级页表访问一次，多级页表可能需要访问两次甚至更多次。</p>
</li>
<li class="lvl-3">
<p>使用 TLB 后，大部分情况下只需访问一次页表（命中情况下直接完成转换），未命中的情况下才需访问页表的所有层级。</p>
</li>
</ol>
<p>通过 TLB 缓解页表访问延迟是现代虚拟存储管理的重要优化手段。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>调页策略</title>
    <url>/posts/f830ee25.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>虚拟存储管理中的调页技术是操作系统为管理虚拟内存和物理内存而采取的一种核心策略。调页技术的主要目的是高效地将内存页面在主存（RAM）和辅助存储（通常是磁盘）之间进行交换，以实现内存的扩展并提高程序执行效率。以下是调页技术的关键点及其分类：</p>
</p>
    </div>
</div><span id="more"></span>
<hr>
<h3 id="1-调页技术的基本原理"><a class="header-anchor" href="#1-调页技术的基本原理">¶</a><strong>1. 调页技术的基本原理</strong></h3>
<p>虚拟存储管理允许程序使用比物理内存容量更大的地址空间。当程序访问的虚拟地址未被映射到物理内存时，会触发<strong>页面错误（Page Fault）</strong>。此时，操作系统会根据调页策略选择适当的页面进行替换。</p>
<p>调页技术的核心流程：</p>
<ol>
<li class="lvl-3">
<p><strong>页面加载</strong>：将所需的页面从磁盘加载到物理内存。</p>
</li>
<li class="lvl-3">
<p><strong>页面置换</strong>：当内存已满时，根据页面置换算法选择一个页面从内存中移出。</p>
</li>
<li class="lvl-3">
<p><strong>页面回写</strong>：如果被替换的页面被修改，则需要将其写回磁盘。</p>
</li>
</ol>
<hr>
<h3 id="2-调页的分类"><a class="header-anchor" href="#2-调页的分类">¶</a><strong>2. 调页的分类</strong></h3>
<p>调页技术主要分为以下几种类型：</p>
<h4 id="1-请求调页-Demand-Paging"><a class="header-anchor" href="#1-请求调页-Demand-Paging">¶</a><strong>(1) 请求调页 (Demand Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：仅当程序访问某页面时才将其加载到内存。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：减少了不必要的页面加载，提高内存利用率。</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：大部分程序的访问具有<strong>局部性原理</strong>，即程序倾向于访问最近使用过的页面或临近页面。</p>
</li>
</ul>
<h4 id="2-预调页-Pre-paging"><a class="header-anchor" href="#2-预调页-Pre-paging">¶</a><strong>(2) 预调页 (Pre-paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：在加载当前页面时，预先加载与其相关的其他页面。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：可以减少未来的页面错误次数，提高程序执行效率。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：可能会加载一些实际上不需要使用的页面，导致资源浪费。</p>
</li>
</ul>
<h4 id="3-局部调页-Local-Paging"><a class="header-anchor" href="#3-局部调页-Local-Paging">¶</a><strong>(3) 局部调页 (Local Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：每个进程只能在其被分配的物理页面中进行页面置换。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：确保每个进程的内存页面是独立管理的，避免被其他进程干扰。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：在内存分配不足时，可能导致某些进程频繁发生页面错误（抖动）。</p>
</li>
</ul>
<h4 id="4-全局调页-Global-Paging"><a class="header-anchor" href="#4-全局调页-Global-Paging">¶</a><strong>(4) 全局调页 (Global Paging)</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>特点</strong>：所有进程共享物理页面，页面置换可以选择任意进程的页面。</p>
</li>
<li class="lvl-2">
<p><strong>优点</strong>：内存利用率更高，系统能更动态地调整内存分配。</p>
</li>
<li class="lvl-2">
<p><strong>缺点</strong>：某些进程可能因为其他进程频繁置换其页面而受到干扰。</p>
</li>
</ul>
<hr>
<h3 id="3-调页算法"><a class="header-anchor" href="#3-调页算法">¶</a><strong>3. 调页算法</strong></h3>
<p>调页技术需要依赖页面置换算法来决定哪一页需要被替换。以下是几种常见的页面置换算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>FIFO（First In First Out）</strong>：最先进入内存的页面最先被替换。</p>
</li>
<li class="lvl-2">
<p><strong>LRU（Least Recently Used）</strong>：选择最近最久未使用的页面进行置换。</p>
</li>
<li class="lvl-2">
<p><strong>LFU（Least Frequently Used）</strong>：选择访问频率最少的页面进行置换。</p>
</li>
<li class="lvl-2">
<p><strong>OPT（Optimal Page Replacement）</strong>：理想情况下选择将来不再使用或最晚被使用的页面。</p>
</li>
<li class="lvl-2">
<p><strong>Clock（时钟算法）</strong>：基于页面的访问位，结合环形链表实现的近似 LRU 算法。</p>
</li>
</ul>
<hr>
<h3 id="4-调页的优缺点"><a class="header-anchor" href="#4-调页的优缺点">¶</a><strong>4. 调页的优缺点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：</p>
<ul class="lvl-2">
<li class="lvl-4">提高了内存利用率和系统的多任务能力。</li>
<li class="lvl-4">支持程序运行时动态扩展内存需求。</li>
</ul>
</li>
<li class="lvl-2">
<p>缺点：</p>
<ul class="lvl-2">
<li class="lvl-4">页面置换和调页操作会增加系统开销。</li>
<li class="lvl-4">如果频繁发生页面错误，会导致性能下降（抖动现象）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-实际应用场景"><a class="header-anchor" href="#5-实际应用场景">¶</a><strong>5. 实际应用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>服务器环境</strong>：通过请求调页减少内存占用，同时根据负载动态调整进程的页面分配。</p>
</li>
<li class="lvl-2">
<p><strong>嵌入式系统</strong>：通常采用局部调页，确保关键任务的内存资源得到优先保证。</p>
</li>
<li class="lvl-2">
<p><strong>高性能计算</strong>：结合预调页和全局调页，充分利用内存和缓存的空间局部性。</p>
</li>
</ul>
<hr>
<h3 id="6-优化方向"><a class="header-anchor" href="#6-优化方向">¶</a><strong>6. 优化方向</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页面大小</strong>：适当增大页面大小可以减少页面错误，但也会增加内存浪费。</p>
</li>
<li class="lvl-2">
<p><strong>缓存技术</strong>：通过硬件缓存或高速内存进一步减少调页操作。</p>
</li>
<li class="lvl-2">
<p><strong>智能预取</strong>：结合程序运行的访问模式预测未来可能需要的页面。</p>
</li>
</ul>
<hr>
<p>调页技术是现代操作系统虚拟存储管理的重要组成部分。通过结合不同的调页策略和优化方法，可以显著提升内存利用率和系统性能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-LFU</title>
    <url>/posts/78bb016d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>最少使用置换算法 (LFU, Least Frequently Used)</strong> 是一种基于页面访问频率的页面置换算法，其核心思想是将内存中使用频率最少的页面作为置换候选，确保较少被访问的页面优先被淘汰。LFU 算法适用于需要精确控制页面访问频率的场景，但在实际应用中常常因为实现复杂性和性能瓶颈而需要进行优化。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="LFU-算法原理"><a class="header-anchor" href="#LFU-算法原理">¶</a><strong>LFU 算法原理</strong></h3>
<p>LFU 算法通过记录每个页面的访问频率（即页面被访问的次数）来决定哪些页面应该被淘汰。当需要替换页面时，选择访问频率最少的页面进行替换。如果有多个页面的访问频率相同，则通常按照其他规则（如 FIFO）进一步选择页面。</p>
<h3 id="LFU-的实现步骤"><a class="header-anchor" href="#LFU-的实现步骤">¶</a><strong>LFU 的实现步骤</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>初始化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">为每个页面分配一个计数器，用于记录该页面的访问次数。</li>
<li class="lvl-5">页面访问时，计数器加一。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>页面访问</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">如果页面在内存中，增加页面的访问频率（计数器加一）。</li>
<li class="lvl-5">如果页面不在内存中：
<ul class="lvl-4">
<li class="lvl-7">若内存已满，则选择访问频率最少的页面进行置换。</li>
<li class="lvl-7">将新页面加载到内存，并设置访问频率为 1。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>页面置换</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在内存已满时，选择访问频率最小的页面进行淘汰。</li>
<li class="lvl-5">如果有多个页面的访问频率相同，则使用其他策略（如 FIFO）进一步确定淘汰页面。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>优化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在实际应用中，为了避免频繁淘汰的情况，可以引入衰减机制，即定期减少页面的访问频率，使得较久未访问的页面可以逐渐“过期”。</li>
<li class="lvl-5">结合其他策略（如时间局部性）可以进一步优化 LFU 的效果。</li>
</ul>
</li>
</ol>
<h3 id="LFU-的优缺点"><a class="header-anchor" href="#LFU-的优缺点">¶</a><strong>LFU 的优缺点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：</p>
<ul class="lvl-2">
<li class="lvl-4">LFU 更能反映页面的实际使用情况，尤其适合处理那些经常使用的页面和较少访问的页面之间的差异。</li>
<li class="lvl-4">与 FIFO 不同，LFU 会根据页面的访问历史来判断哪些页面应该继续留在内存中，从而避免了 FIFO 在某些场景下的缺陷（如热点页面被淘汰的情况）。</li>
</ul>
</li>
<li class="lvl-2">
<p>缺点：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>实现复杂性</strong>：LFU 算法需要为每个页面维护一个访问计数器，这增加了系统的开销。</li>
<li class="lvl-4"><strong>性能瓶颈</strong>：每次访问页面时，都需要更新访问计数器，并且置换时需要遍历所有页面，找到访问频率最小的页面，这在大规模系统中可能会导致性能问题。</li>
<li class="lvl-4"><strong>长时间未使用页面</strong>：LFU 在某些情况下可能会保留一些长期未访问但仍然有高访问频率的页面，这在时间局部性较强的场景中可能不适用。</li>
</ul>
</li>
</ul>
<h3 id="优化方法"><a class="header-anchor" href="#优化方法">¶</a><strong>优化方法</strong></h3>
<p>由于 LFU 算法容易受到高频页面占用内存的影响，现代系统中往往采用以下优化方法：</p>
<ol>
<li class="lvl-3">
<p><strong>衰减机制</strong>：定期减小页面的访问计数，使得长期未访问的页面计数器值会逐渐降低，避免低频页面被长期保留。</p>
</li>
<li class="lvl-3">
<p><strong>结合其他算法</strong>：例如，结合 LRU（最近最久未使用）策略，使用 LFU+LRU（如 LFU 结合链表）来同时考虑页面的访问频率和最近的访问时间，提升整体性能。</p>
</li>
</ol>
<h3 id="LFU-与-FIFO-比较"><a class="header-anchor" href="#LFU-与-FIFO-比较">¶</a><strong>LFU 与 FIFO 比较</strong></h3>
<p>LFU 算法是 FIFO 算法的一种改进。FIFO 仅根据页面进入内存的顺序来决定置换，而 LFU 则考虑了页面的使用频率，从而能更精确地反映页面的实际需求。相比 FIFO，LFU 更能避免热点页面被淘汰的情况，但其实现和维护的复杂性较高。</p>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h3>
<p>假设我们有一个大小为 3 的页面框，页面访问序列如下：<code>1, 2, 3, 1, 2, 4, 5</code>。初始时，所有页面的访问频率为 0。每次访问时，页面的频率会增加，最终进行置换时会选择频率最小的页面。</p>
<ol>
<li class="lvl-3">
<p>访问页面 <code>1</code>：内存中插入页面 <code>1</code>，频率为 <code>[1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>2</code>：内存中插入页面 <code>2</code>，频率为 <code>[1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>3</code>：内存中插入页面 <code>3</code>，频率为 <code>[1, 1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>再次访问页面 <code>1</code>：频率更新为 <code>[2, 1, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>再次访问页面 <code>2</code>：频率更新为 <code>[2, 2, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>4</code>：页面 <code>3</code> 被淘汰（频率最小），插入页面 <code>4</code>，频率为 <code>[2, 2, 1]</code>。</p>
</li>
<li class="lvl-3">
<p>访问页面 <code>5</code>：页面 <code>1</code> 被淘汰（频率最小），插入页面 <code>5</code>，频率为 <code>[2, 2, 1]</code>。</p>
</li>
</ol>
<p>在这个过程中，LFU 根据访问频率选择淘汰页面，相比 FIFO 更能有效管理频繁访问的页面。</p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<p>LFU 算法是一种有效的页面置换策略，适用于处理那些访问频率差异较大的场景。它相比 FIFO 更能反映页面的实际使用情况，但其实现复杂度和性能问题可能需要结合其他策略进行优化。在现代操作系统中，LFU 和其改进版本（如 LFU+LRU）通常会与其他页面管理策略一起使用，以达到更好的性能效果。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-LRU的实际实现过程</title>
    <url>/posts/f041ded5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现</h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><span id="more"></span>
<p>以下是使用<strong>移位寄存器</strong>和<strong>栈</strong>实现最近最久未使用（LRU）算法的详细过程：</p>
<hr>
<h3 id="1-用移位寄存器实现-LRU"><a class="header-anchor" href="#1-用移位寄存器实现-LRU">¶</a><strong>1. 用移位寄存器实现 LRU</strong></h3>
<p>移位寄存器通过记录页面的访问历史，来跟踪最近最久未使用的页面。</p>
<h4 id="基本原理"><a class="header-anchor" href="#基本原理">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页面框对应一个寄存器（n 位宽）。</p>
</li>
<li class="lvl-2">
<p>每次访问页面时：</p>
<ol>
<li class="lvl-5">将对应寄存器的最高位设置为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ol>
</li>
<li class="lvl-2">
<p>随着时间推移，未被访问的页面寄存器的值会逐渐变小。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面（即最久未使用的页面）。</p>
</li>
</ul>
<h4 id="实现步骤"><a class="header-anchor" href="#实现步骤">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化寄存器</strong>：为每个页面框分配一个寄存器，初始值为全 0。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">找到访问的页面对应的寄存器。</li>
<li class="lvl-5">设置寄存器的最高位为 1。</li>
<li class="lvl-5">对所有寄存器执行右移操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">在页面不在内存中且内存已满时，找到寄存器值最小的页面并将其替换。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>更新寄存器</strong>：置换完成后，初始化新页面的寄存器值为最高位为 1，其他位为 0。</p>
</li>
</ol>
<h4 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h4>
<p>假设有 4 个页面框，对应 4 个 4 位寄存器，初始值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并对所有寄存器右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1000  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>再次访问页面框 1：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R1 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 1100  R2: 0000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<p>访问页面框 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置 R2 的最高位为 1，并右移：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1: 0110  R2: 1000  R3: 0000  R4: 0000</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-用栈实现-LRU"><a class="header-anchor" href="#2-用栈实现-LRU">¶</a><strong>2. 用栈实现 LRU</strong></h3>
<p>栈结构利用最近使用的页面总是在栈顶，而最久未使用的页面总是在栈底的特点，实现页面置换。</p>
<h4 id="基本原理-2"><a class="header-anchor" href="#基本原理-2">¶</a><strong>基本原理</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用一个栈存储页面框号，栈顶是最近访问的页面。</p>
</li>
<li class="lvl-2">
<p>页面访问时：</p>
<ol>
<li class="lvl-5">如果页面已在栈中，将其移到栈顶。</li>
<li class="lvl-5">如果页面不在栈中：
<ul class="lvl-4">
<li class="lvl-7">栈未满时，将页面直接插入栈顶。</li>
<li class="lvl-7">栈已满时，移除栈底页面（最久未使用），然后插入新页面到栈顶。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="实现步骤-2"><a class="header-anchor" href="#实现步骤-2">¶</a><strong>实现步骤</strong></h4>
<ol>
<li class="lvl-3">
<p><strong>初始化栈</strong>：创建一个空栈，大小等于内存页面框数。</p>
</li>
<li class="lvl-3">
<p>页面访问：</p>
<ul class="lvl-2">
<li class="lvl-5">检查页面是否在栈中：
<ul class="lvl-4">
<li class="lvl-7">如果在，将该页面从原位置移到栈顶。</li>
<li class="lvl-7">如果不在：
<ul class="lvl-6">
<li class="lvl-9">栈未满时，直接将页面插入栈顶。</li>
<li class="lvl-9">栈已满时，移除栈底页面，插入新页面到栈顶。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>页面置换：</p>
<ul class="lvl-2">
<li class="lvl-5">置换操作在栈已满时，删除<strong>栈底</strong>页面，插入新页面到栈顶。</li>
</ul>
</li>
</ol>
<h4 id="示例-2"><a class="header-anchor" href="#示例-2">¶</a><strong>示例</strong></h4>
<p>假设有 3 个页面框，初始栈为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[]</span><br></pre></td></tr></table></figure>
<p>访问页面 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[1]</span><br></pre></td></tr></table></figure>
<p>访问页面 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p>再次访问页面 2：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将页面 2 移到栈顶：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[2, 3, 1]</span><br></pre></td></tr></table></figure>
<p>访问页面 4（超出容量，需要置换）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>移除栈底页面（1），插入 4：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：[4, 2, 3]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="比较与选择"><a class="header-anchor" href="#比较与选择">¶</a><strong>比较与选择</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>移位寄存器</strong>实现简单，占用较少存储资源，但适合小型固定容量系统。</p>
</li>
<li class="lvl-2">
<p><strong>栈</strong>灵活性更高，适合动态管理和较大规模的页面置换问题。</p>
</li>
</ul>
<p>以上两种实现可以结合实际需求与硬件条件选择【18】【19】。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-移位寄存器</title>
    <url>/posts/3d2c198d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。</p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="移位寄存器的基本功能"><a class="header-anchor" href="#移位寄存器的基本功能">¶</a><strong>移位寄存器的基本功能</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据存储</strong>：可以临时存储一定数量的二进制数据。</p>
</li>
<li class="lvl-3">
<p><strong>数据移位</strong>：按照时钟信号，将数据向左或向右移位。</p>
</li>
<li class="lvl-3">
<p>数据串并转换：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>串行输入并行输出（SIPO）</strong>：将串行输入的数据逐位移入，然后一次性输出并行数据。</li>
<li class="lvl-5"><strong>并行输入串行输出（PISO）</strong>：将并行输入的数据一次性装载，然后逐位移出。</li>
<li class="lvl-5"><strong>串行输入串行输出（SISO）</strong>：数据逐位输入后，逐位移出。</li>
<li class="lvl-5"><strong>并行输入并行输出（PIPO）</strong>：并行方式输入和输出数据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的分类"><a class="header-anchor" href="#移位寄存器的分类">¶</a><strong>移位寄存器的分类</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>按移位方向分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>左移寄存器</strong>：数据向左移位，低位补零或引入外部输入。</li>
<li class="lvl-5"><strong>右移寄存器</strong>：数据向右移位，高位补零或引入外部输入。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>按输入输出方式分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>SISO（串行输入串行输出）</strong>：数据逐位输入并逐位输出，适合数据流传输。</li>
<li class="lvl-5"><strong>SIPO（串行输入并行输出）</strong>：串行输入，移位完成后并行读取，常用于串行转并行。</li>
<li class="lvl-5"><strong>PISO（并行输入串行输出）</strong>：并行数据装载后逐位输出，常用于并行转串行。</li>
<li class="lvl-5"><strong>PIPO（并行输入并行输出）</strong>：同时装载和输出并行数据，用于数据缓存。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="移位寄存器的组成与工作原理"><a class="header-anchor" href="#移位寄存器的组成与工作原理">¶</a><strong>移位寄存器的组成与工作原理</strong></h3>
<p>移位寄存器通常由以下部分组成：</p>
<ol>
<li class="lvl-3">
<p><strong>触发器</strong>：每个触发器存储一个位的数据。</p>
</li>
<li class="lvl-3">
<p><strong>时钟信号</strong>：控制数据移位的节奏。</p>
</li>
<li class="lvl-3">
<p><strong>输入控制逻辑</strong>：决定数据的输入方式（串行或并行）。</p>
</li>
<li class="lvl-3">
<p><strong>输出控制逻辑</strong>：决定数据的输出方式。</p>
</li>
</ol>
<p><strong>工作原理</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个时钟周期，寄存器中的数据根据设定方向进行一次移位。</p>
</li>
<li class="lvl-2">
<p>输入数据按要求补充到移位方向的空位。</p>
</li>
<li class="lvl-2">
<p>移出的数据可以输出到其他模块。</p>
</li>
</ul>
<hr>
<h3 id="移位寄存器的应用"><a class="header-anchor" href="#移位寄存器的应用">¶</a><strong>移位寄存器的应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>数据延迟</strong>：移位寄存器可以延迟数据的传输，用于信号同步。</p>
</li>
<li class="lvl-3">
<p><strong>串并转换</strong>：实现串行和并行数据的转换。</p>
</li>
<li class="lvl-3">
<p><strong>计数器</strong>：通过移位操作实现二进制计数功能。</p>
</li>
<li class="lvl-3">
<p><strong>加密与解码</strong>：如线性反馈移位寄存器（LFSR）常用于伪随机数生成和加密。</p>
</li>
<li class="lvl-3">
<p><strong>信号处理</strong>：在数字信号处理中，用于滤波器设计、数据流处理等。</p>
</li>
</ol>
<hr>
<h3 id="示例电路：4位右移寄存器"><a class="header-anchor" href="#示例电路：4位右移寄存器">¶</a><strong>示例电路：4位右移寄存器</strong></h3>
<p>假设有 4 个触发器（D1, D2, D3, D4）组成一个右移寄存器，初始状态为 <code>1010</code>，右移过程如下：</p>
<ol>
<li class="lvl-3">
<p><strong>时钟周期 1</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1101</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 2</strong>：输入新数据 <code>0</code>，移位后数据为 <code>0110</code>。</p>
</li>
<li class="lvl-3">
<p><strong>时钟周期 3</strong>：输入新数据 <code>1</code>，移位后数据为 <code>1011</code>。</p>
</li>
</ol>
<p><strong>右移逻辑</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个触发器的输入来自于它左侧触发器的输出（例如，D4 的输入来自 D3 的输出）。</p>
</li>
</ul>
<hr>
<p>移位寄存器在数字系统中是一种基础组件，可以通过设计不同的逻辑电路实现各种复杂功能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo插件hexo-graph的使用</title>
    <url>/posts/1bd5413e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记一下文章&quot;关于&quot;页的书写</p>
<p>插件地址<a href="https://github.com/codepzj/hexo-graph">codepzj/hexo-graph: hexo-graph，一个基于echarts，集成博客热力图，博客月份统计图，分类统计图，标签统计图的多元化插件。</a></p>
</p>
    </div>
</div><span id="more"></span>
<p>略</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>折腾 hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-页面框</title>
    <url>/posts/6dc856e2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3><strong>总结</strong></h3>
<ul class="lvl-1">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
</p>
    </div>
</div><span id="more"></span>
<p><strong>页面框</strong>（Page Frame）是操作系统中物理内存管理的一个重要概念。</p>
<hr>
<h3 id="页面框的定义"><a class="header-anchor" href="#页面框的定义">¶</a><strong>页面框的定义</strong></h3>
<p>页面框是指<strong>物理内存中的固定大小的块</strong>，它是虚拟内存管理中用于存放<strong>页</strong>（Page）的单位。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页</strong>：虚拟内存被划分为大小固定的块，每块称为一个页（Page）。</p>
</li>
<li class="lvl-2">
<p><strong>页面框</strong>：物理内存也被划分为同样大小的固定块，这些块称为页面框（Page Frame）。</p>
</li>
</ul>
<p>页面框和页的大小相同（通常为 4KB 或 8KB，具体取决于操作系统和硬件架构），这样可以方便地实现虚拟内存和物理内存之间的映射。</p>
<hr>
<h3 id="页面框的作用"><a class="header-anchor" href="#页面框的作用">¶</a><strong>页面框的作用</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>存储页</strong>：页面框用于存储从虚拟内存中调入的页。</p>
</li>
<li class="lvl-2">
<p><strong>虚拟内存与物理内存的映射</strong>：操作系统通过页表（Page Table）将虚拟内存的页与物理内存的页面框一一对应，从而实现虚拟内存管理。</p>
</li>
<li class="lvl-2">
<p><strong>提升内存利用率</strong>：通过分页机制，进程无需全部加载到内存中，只需将常用的页装入页面框即可，减少内存的浪费。</p>
</li>
</ul>
<hr>
<h3 id="页面框的分配过程"><a class="header-anchor" href="#页面框的分配过程">¶</a><strong>页面框的分配过程</strong></h3>
<ol>
<li class="lvl-3">
<p>虚拟地址空间划分：进程的虚拟地址被划分为多个页。</p>
<ul class="lvl-2">
<li class="lvl-5">假设某进程需要 16KB 的虚拟内存，且每页大小为 4KB，则虚拟内存被划分为 4 个页。</li>
</ul>
</li>
<li class="lvl-3">
<p>物理内存划分：操作系统将物理内存划分为等大小的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">假设有 1GB 的物理内存，页面框大小为 4KB，则物理内存被划分为 262,144 个页面框。</li>
</ul>
</li>
<li class="lvl-3">
<p>页面调度：当进程运行时，操作系统将虚拟内存中的页映射到物理内存中的页面框。</p>
<ul class="lvl-2">
<li class="lvl-5">若某页需要访问但不在内存（缺页中断），操作系统从磁盘将该页加载到某个空闲页面框中，或通过页面置换算法腾出一个页面框。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="页面框相关机制"><a class="header-anchor" href="#页面框相关机制">¶</a><strong>页面框相关机制</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>页表（Page Table）</strong>：存储每个页与页面框的映射关系。</p>
</li>
<li class="lvl-2">
<p><strong>页面置换</strong>：当页面框不足时，操作系统通过页面置换算法（如 LRU、FIFO）将某些不常用的页移出页面框，以腾出空间给新的页。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>页面框是<strong>物理内存中的固定大小块</strong>，用于存储虚拟内存的页。</p>
</li>
<li class="lvl-2">
<p>通过分页机制，操作系统可以高效管理内存，提高内存利用率，并支持更大的虚拟地址空间。</p>
</li>
</ul>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配算法</title>
    <url>/posts/8ba68849.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配算法<strong>对比总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在物理块分配中，操作系统通过不同的分配算法将内存中的页面框分配给各个进程，以提高内存利用率和系统性能。以下是这些算法的详细解释：</p>
<hr>
<h3 id="1-平均分配算法"><a class="header-anchor" href="#1-平均分配算法">¶</a><strong>1. 平均分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">系统将所有的物理块平均分配给当前运行的进程。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个页面框和 <code>M</code> 个进程，则每个进程分配到的页面框数量为 <code>N / M</code>，如果有余数，可以通过某种方式分配剩余的页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">简单易实现，适用于所有进程的内存需求大致相同的场景。</li>
<li class="lvl-4">对于需求量大的进程可能导致页面置换频繁（抖动问题），而需求量小的进程可能浪费内存。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：公平、实现简单。</p>
<p><strong>缺点</strong>：无法动态适应进程的实际需求，可能导致资源分配不合理。</p>
<hr>
<h3 id="2-按比例分配算法"><a class="header-anchor" href="#2-按比例分配算法">¶</a><strong>2. 按比例分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">根据每个进程所需的页面数占比，按比例分配物理块。</li>
<li class="lvl-4">假设系统有 <code>N</code> 个物理块，<code>M</code> 个进程，进程 <code>i</code> 所需页面数为 <code>Si</code>，则分配给进程 <code>i</code> 的页面框数为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{S_i}{\sum_{j=1}^{M} S_j}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">进程内存需求较大时分配更多页面框，内存需求较小时分配更少。</li>
<li class="lvl-4">适用于进程内存需求差异较大的场景，能较好地满足高需求进程的性能。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：充分利用资源，能够根据需求动态调整分配。</p>
<p><strong>缺点</strong>：计算复杂度较高，对需求量估计不准确时可能影响性能。</p>
<hr>
<h3 id="3-考虑优先权的分配算法"><a class="header-anchor" href="#3-考虑优先权的分配算法">¶</a><strong>3. 考虑优先权的分配算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分配方法：</p>
<ul class="lvl-2">
<li class="lvl-4">在按比例分配的基础上，结合进程的优先级分配物理块。</li>
<li class="lvl-4">系统会为高优先级进程分配更多的页面框，而低优先级进程分配较少。</li>
<li class="lvl-4">假设优先级为 <code>Pi</code>，则分配公式可以扩展为：<br>
$$<br>
\text{分配的页面框数} = N \times \frac{P_i \cdot S_i}{\sum_{j=1}^{M} (P_j \cdot S_j)}<br>
$$</li>
</ul>
</li>
<li class="lvl-2">
<p>特点：</p>
<ul class="lvl-2">
<li class="lvl-4">确保高优先级进程在资源分配上得到保障。</li>
</ul>
</li>
<li class="lvl-2">
<p>适用于多任务操作系统，优先保证关键任务或重要用户的性能。</p>
</li>
</ul>
<p><strong>优点</strong>：保障高优先级任务的运行性能。</p>
<p><strong>缺点</strong>：可能导致低优先级进程长时间无法获得足够的资源，影响其运行。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>请求分页-物理块分配策略</title>
    <url>/posts/907f4c43.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>请求分页-物理块分配策略</h3>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><span id="more"></span>
<p>在操作系统中，<strong>物理块分配策略</strong>主要决定了内存如何分配给进程以及页面置换的策略。以下是这些策略的详细解释：</p>
<hr>
<h3 id="1-固定分配，局部置换"><a class="header-anchor" href="#1-固定分配，局部置换">¶</a><strong>1. 固定分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配：每个进程在创建时，分配固定数量的物理块（即页面框）。这些物理块数量在整个运行过程中不再改变。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，一个进程可能被分配 5 个页面框，另一个进程被分配 10 个页面框。</li>
</ul>
</li>
<li class="lvl-2">
<p>局部置换：当一个进程需要置换页面时，只能在它自己的物理块中进行替换，而不会占用或影响其他进程的物理块。</p>
<ul class="lvl-2">
<li class="lvl-4">换句话说，每个进程有自己的物理块范围，页面置换仅限于该范围内。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：避免了进程之间的干扰，保证了各自的内存独立性。</p>
<p><strong>缺点</strong>：如果某个进程的需求量超过了固定分配的物理块数，可能会出现高频率的页面置换（抖动问题）。</p>
<hr>
<h3 id="2-可变分配，全局置换"><a class="header-anchor" href="#2-可变分配，全局置换">¶</a><strong>2. 可变分配，全局置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以根据进程的运行情况动态调整分配给每个进程的物理块数量。例如，一个进程内存需求增加时，可以从其他进程的分配中借用页面框。</p>
</li>
<li class="lvl-2">
<p>全局置换：当某个进程需要置换页面时，可以在整个系统的所有物理块中选择受影响的页面，不局限于自身的物理块范围。</p>
<ul class="lvl-2">
<li class="lvl-4">例如，某个进程的页面置换可能会影响到其他进程正在使用的页面。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：提高了系统内存的利用率，允许内存资源在进程之间灵活分配。</p>
<p><strong>缺点</strong>：进程之间可能会互相干扰，导致某些进程因内存不足而性能下降。</p>
<hr>
<h3 id="3-可变分配，局部置换"><a class="header-anchor" href="#3-可变分配，局部置换">¶</a><strong>3. 可变分配，局部置换</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可变分配</strong>：系统可以动态调整每个进程的物理块数量，具体分配数量由操作系统根据进程的需求决定。</p>
</li>
<li class="lvl-2">
<p><strong>局部置换</strong>：尽管分配数量可变，但每个进程仍只能在自己当前拥有的物理块中进行页面置换，而不能影响其他进程的页面。</p>
</li>
</ul>
<p><strong>优点</strong>：结合了固定分配和可变分配的优点，既能根据需求调整资源，又避免了进程之间的直接干扰。</p>
<p><strong>缺点</strong>：动态分配增加了操作系统的复杂性。</p>
<hr>
<h3 id="总结对比"><a class="header-anchor" href="#总结对比">¶</a><strong>总结对比</strong></h3>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>物理块分配</th>
<th>页面置换范围</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定分配，局部置换</td>
<td>固定数量</td>
<td>自己的物理块</td>
<td>简单、稳定，避免进程干扰</td>
<td>缺乏灵活性，可能导致个别进程性能下降</td>
</tr>
<tr>
<td>可变分配，全局置换</td>
<td>动态调整</td>
<td>全局</td>
<td>高效利用内存资源，支持动态调整</td>
<td>进程间干扰可能导致系统不稳定</td>
</tr>
<tr>
<td>可变分配，局部置换</td>
<td>动态调整</td>
<td>自己的物理块</td>
<td>兼顾灵活性和稳定性</td>
<td>系统复杂度较高</td>
</tr>
</tbody>
</table>
<p>这三种策略在实际中会根据操作系统的设计目标与应用场景选择适用的方案。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>一条指令在执行期间，可能产生多次缺页中断</title>
    <url>/posts/52e033e8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>一条指令在执行期间，可能产生多次缺页中断 的详细解析</p>
</p>
    </div>
</div><span id="more"></span>
<p>是的，一条指令在执行期间<strong>可能产生多次缺页中断</strong>。这是因为指令的执行可能涉及到多个内存地址的访问，而每个地址的访问都有可能导致缺页中断。以下是几种可能导致这种情况的场景：</p>
<hr>
<h3 id="1-指令本身产生的缺页中断"><a class="header-anchor" href="#1-指令本身产生的缺页中断">¶</a><strong>1. 指令本身产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>指令取指</strong><br>
CPU在执行一条指令时，需要从内存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="2-操作数访问导致的缺页中断"><a class="header-anchor" href="#2-操作数访问导致的缺页中断">¶</a><strong>2. 操作数访问导致的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>直接操作数</strong><br>
如果指令使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>间接访问（如指针或数组访问）</strong><br>
指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="3-指令操作多次访问内存"><a class="header-anchor" href="#3-指令操作多次访问内存">¶</a><strong>3. 指令操作多次访问内存</strong></h3>
<p>一些复杂指令（尤其在CISC架构中）可能在执行期间涉及多个内存访问，每次访问都可能触发缺页中断。例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<hr>
<h3 id="4-页表访问产生的缺页中断"><a class="header-anchor" href="#4-页表访问产生的缺页中断">¶</a><strong>4. 页表访问产生的缺页中断</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<hr>
<h3 id="5-内存管理器的间接操作"><a class="header-anchor" href="#5-内存管理器的间接操作">¶</a><strong>5. 内存管理器的间接操作</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
<hr>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a><strong>示例</strong></h3>
<p>假设有一条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i] = b[j] + c[k];</span><br></pre></td></tr></table></figure>
<p>执行这条指令可能涉及以下几个内存访问：</p>
<ol>
<li class="lvl-3">
<p>取出指令本身（指令所在页面可能触发缺页中断）。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>a</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>b</code>的地址。</p>
</li>
<li class="lvl-3">
<p>读取数组<code>c</code>的地址。</p>
</li>
<li class="lvl-3">
<p>访问<code>b[j]</code>的值。</p>
</li>
<li class="lvl-3">
<p>访问<code>c[k]</code>的值。</p>
</li>
<li class="lvl-3">
<p>写入<code>a[i]</code>。</p>
</li>
</ol>
<p>如果这些访问的页面都未加载到主存，则可能触发<strong>多次缺页中断</strong>。</p>
<hr>
<h3 id="如何缓解缺页中断带来的开销"><a class="header-anchor" href="#如何缓解缺页中断带来的开销">¶</a><strong>如何缓解缺页中断带来的开销</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>预取机制</strong><br>
操作系统可预测程序的访问模式，提前将相关页面加载到主存，减少缺页中断。</p>
</li>
<li class="lvl-3">
<p><strong>使用更大的页面（大页）</strong><br>
使用大页面（如2MB或1GB）可以减少页表项数量，降低缺页中断概率。</p>
</li>
<li class="lvl-3">
<p><strong>优化程序内存访问模式</strong><br>
开发者可以优化数据结构和算法，尽量减少跨页面访问。</p>
</li>
<li class="lvl-3">
<p><strong>TLB优化</strong><br>
提高页表缓存（TLB）的命中率，加快地址转换速度。</p>
</li>
</ol>
<hr>
<p>综上，虽然一条指令可能导致多次缺页中断，但通过合理的内存管理策略和优化，可以有效降低缺页中断的频率，提高系统性能。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>CISC架构</title>
    <url>/posts/7436c65f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><strong>CISC（Complex Instruction Set Computer）<strong>架构是一种处理器设计理念，其特点是提供</strong>复杂且多样化的指令集</strong></p>
</p>
    </div>
</div><span id="more"></span>
<h3 id="CISC架构的定义"><a class="header-anchor" href="#CISC架构的定义">¶</a><strong>CISC架构的定义</strong></h3>
<p>**CISC（Complex Instruction Set Computer）*<em>架构是一种处理器设计理念，其特点是提供*<em>复杂且多样化的指令集</em></em>，每条指令可以完成多种复杂操作。这种设计理念的目标是通过简化程序的指令数目，减少程序代码量，提高开发效率。</p>
<p>CISC是传统计算机架构的典型代表，如<strong>x86架构</strong>和早期的<strong>VAX</strong>、<strong>IBM System/360</strong>等处理器。</p>
<hr>
<h3 id="CISC架构的特点"><a class="header-anchor" href="#CISC架构的特点">¶</a><strong>CISC架构的特点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>复杂指令集</strong></p>
<ul class="lvl-2">
<li class="lvl-5">每条指令的功能非常强大，可能同时执行多个步骤（如取数、运算、存储）。</li>
<li class="lvl-5">如<code>MOV</code>, <code>ADD</code>, <code>MULT</code>等指令，不仅支持寄存器操作，还支持直接对内存操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令长度不固定</strong></p>
<ul class="lvl-2">
<li class="lvl-5">指令可以是不同长度的字节组合，使得编码更加灵活，但解码复杂。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>丰富的寻址模式</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提供多种内存寻址模式，如立即寻址、直接寻址、间接寻址、基址寻址等，支持对复杂数据结构的直接操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>微码实现</strong></p>
<ul class="lvl-2">
<li class="lvl-5">通常使用**微程序控制器（Microcode Control Unit）**来解码复杂指令，这种方式简化了硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>指令执行时间较长</strong></p>
<ul class="lvl-2">
<li class="lvl-5">单条指令可能需要多个时钟周期完成，因为其内部可能包含多个微操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>高度依赖内存</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构允许指令直接操作内存，而不是先将数据加载到寄存器，这增加了对内存访问的频率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的优点"><a class="header-anchor" href="#CISC架构的优点">¶</a><strong>CISC架构的优点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>程序代码紧凑</strong></p>
<ul class="lvl-2">
<li class="lvl-5">强大的指令集可以用更少的指令实现复杂功能，减少程序代码量。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>易于编写高层语言编译器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">高级语言中复杂的语句可以直接映射为CISC指令，简化了编译器的设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>向后兼容性强</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构通过扩展指令集可以保持对旧程序的兼容性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适合复杂的计算任务</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令和多样化的寻址模式使其适合复杂的数据处理任务。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC架构的缺点"><a class="header-anchor" href="#CISC架构的缺点">¶</a><strong>CISC架构的缺点</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>指令解码复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">不固定的指令长度和复杂的指令集增加了CPU解码指令的难度，降低了效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>执行速度较慢</strong></p>
<ul class="lvl-2">
<li class="lvl-5">一条CISC指令可能需要多个时钟周期完成，无法充分发挥现代高速硬件的性能。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>硬件设计复杂</strong></p>
<ul class="lvl-2">
<li class="lvl-5">支持多样化指令和寻址模式需要更复杂的硬件设计。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>能耗较高</strong></p>
<ul class="lvl-2">
<li class="lvl-5">复杂指令的实现通常需要更多的电力支持。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="CISC与RISC的对比"><a class="header-anchor" href="#CISC与RISC的对比">¶</a><strong>CISC与RISC的对比</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CISC</strong></th>
<th><strong>RISC（Reduced Instruction Set Computer）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令集</strong></td>
<td>复杂、多样化</td>
<td>简单、固定长度</td>
</tr>
<tr>
<td><strong>指令执行时间</strong></td>
<td>单条指令执行时间长，可能需要多个时钟周期</td>
<td>单条指令执行时间短，通常一个时钟周期完成</td>
</tr>
<tr>
<td><strong>硬件设计</strong></td>
<td>复杂的硬件支持复杂指令集</td>
<td>简化的硬件设计，执行更高效</td>
</tr>
<tr>
<td><strong>代码密度</strong></td>
<td>高，程序代码量少</td>
<td>低，通常需要更多指令完成相同的功能</td>
</tr>
<tr>
<td><strong>能耗</strong></td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td><strong>典型代表</strong></td>
<td>x86, VAX</td>
<td>ARM, MIPS, RISC-V</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="CISC架构的实际应用"><a class="header-anchor" href="#CISC架构的实际应用">¶</a><strong>CISC架构的实际应用</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>x86处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">现代的PC和服务器大多基于x86架构，该架构是CISC的典型代表。</li>
<li class="lvl-5">如Intel和AMD的处理器均采用该架构。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>嵌入式系统中的老一代处理器</strong></p>
<ul class="lvl-2">
<li class="lvl-5">如8086、80286处理器，广泛应用于工业控制和嵌入式系统中。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>专用硬件系统</strong></p>
<ul class="lvl-2">
<li class="lvl-5">需要复杂数据处理的场景，如传统银行机房的大型机。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="现代CISC的改进"><a class="header-anchor" href="#现代CISC的改进">¶</a><strong>现代CISC的改进</strong></h3>
<p>尽管CISC架构在指令执行效率上不如RISC，但现代CISC处理器通过以下方式提升性能：</p>
<ol>
<li class="lvl-3">
<p><strong>指令解码优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">使用硬件将CISC复杂指令拆解为更简单的微操作（micro-operations）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>流水线设计</strong></p>
<ul class="lvl-2">
<li class="lvl-5">CISC架构中引入RISC的流水线思想，提高指令执行效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多核技术</strong></p>
<ul class="lvl-2">
<li class="lvl-5">增加多核处理能力，弥补单核执行速度的不足。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>缓存优化</strong></p>
<ul class="lvl-2">
<li class="lvl-5">提高指令和数据缓存的命中率，减少内存访问延迟。</li>
</ul>
</li>
</ol>
<hr>
<p>总结来说，CISC架构通过强大的指令集提供了高度灵活性，特别适合某些需要复杂指令处理的应用场景。尽管其在效率和硬件设计方面有一定劣势，但通过现代优化技术，CISC架构依然在许多领域保持了强大的竞争力。</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>408/OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>typora破解</title>
    <url>/posts/8fcf3ec6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>太逆天了，笔者是在花<big><big>89</big></big>米😕 之后，偶然搜到了这个，虽然已经没用了，但还是摘一下</p>
</p>
    </div>
</div><span id="more"></span>
<p><small>放个error以表愤怒！</small>😠</p>

<div class="callout callout-error">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">ERROR</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>Typora 是一款由 Abner Lee 开发的轻量级 Markdown 编辑器，适用于 OS X、Windows 和 Linux 三种操作系统。</p>
<p>与其他 Markdown 编辑器不同的是，Typora 没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p>
<p>该软件目前只有 15 天免费试用，后续使用续费付费才行！这里分享一个自己破解的方法！不再从网上下载破解版或者补丁了！</p>
<p>免责声明：本文内容仅为技术分享、交流、探讨，推荐大家支持官方正版软件！</p>
<h2>官网地址</h2>
<p>国外：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmEuaW8v">https://typora.io/</a></p>
<p>国内：<a href="https://blog.captainz.cc/go/#aHR0cHM6Ly90eXBvcmFpby5jbi8=">https://typoraio.cn/</a></p>
<h2>省流步骤</h2>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 <code>\ resources\page-dist\static\js\LicenseIndex.xxxxxxxxx.xxxxxxx.chunk.js</code>，激活主程序</p>
</li>
</ol>
<p>查找：<code>e.hasActivated=&quot;true&quot;==e.hasActivated,</code></p>
<p>替换：<code>e.hasActivated=&quot;true&quot;==&quot;true&quot;,</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\page-dist\license.html，关闭每次启动时的已激活弹窗</p>
</li>
</ol>
<p>查找：<code>&lt;/body&gt;&lt;/html&gt;</code>替换：<code>&lt;/body&gt;&lt;script&gt;window.onload=function()&#123;setTimeout(()=&gt;&#123;window.close();&#125;,5);&#125;&lt;/script&gt;&lt;/html&gt;</code></p>
<ol>
<li class="lvl-3">
<p>修改 Typora 安装目录 \ resources\locales\zh-Hans.lproj\Panel.json，去除左下角 “未激活” 提示（不完美方案，仅去除文字，小框框还在）</p>
</li>
</ol>
<p>查找：<code>&quot;UNREGISTERED&quot;:&quot;未激活&quot;</code></p>
<p>替换：<code>&quot;UNREGISTERED&quot;:&quot; &quot;</code></p>
<h2>最后总结</h2>
<ul class="lvl-1">
<li class="lvl-2">
<p>我的许可证页面无法查看</p>
</li>
<li class="lvl-2">
<p>左下角关闭的小框还存在</p>
</li>
<li class="lvl-2">
<p>其他平台如 MAC，Linux 参考本文自己摸索一下</p>
</li>
<li class="lvl-2">
<p>一旦程序启动崩溃，可能是替换时有误操作，重新安装再尝试</p>
</li>
<li class="lvl-2">
<p>随着新版本更新，可能该方法会失效，亲测 1.7.6 没有问题</p>
</li>
</ul>
<p>—— <a href="https://blog.captainz.cc/posts/typora_crack.html">自己动手破解 Markdown 软件 Typora，支持官网最新版 | Hyper Tech</a></p>
</p>
    </div>
</div><hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>footnote使用</title>
    <url>/posts/64648fb9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>关于博客中使用的脚注功能</title>
    <url>/posts/c6910d47.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下博客中脚注配置的相关内容</p>
</p>
    </div>
</div><span id="more"></span>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<ol>
<li class="lvl-3">打开 hexo 官方插件页面 <a href="https://hexo.io/plugins/">Plugins</a></li>
<li class="lvl-3">搜索 <code>footnotes</code> 并安装 <a href="https://github.com/kchen0x/hexo-reference">hexo-reference</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure>
<p>配置根目录 <code>_config.yml</code> 文件，新增一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-reference</span><br></pre></td></tr></table></figure>
<h4>参考文档</h4>
<p><a href="https://kchen.cc/2016/11/10/footnotes-in-hexo/#fnref:4">Hexo 里的脚注插件</a></p>
<p>—— 摘自 <a href="https://toypipi.github.io/2024/05/10/hexo-%E5%A2%9E%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%8A%9F%E8%83%BD/">hexo 增加脚注功能 | Toypipi’s blog</a></p>
</p>
    </div>
</div><h2 id="修改footnote脚注样式"><a class="header-anchor" href="#修改footnote脚注样式">¶</a>修改footnote脚注样式</h2>
<p>由于笔者实在是不太喜欢<code>hexo-reference</code>提供的红色的<code>footnote</code>然后鉴于笔者是使用插件渲染<code>footnote</code>的，所以笔者就准备对插件的代码做一下改造：</p>
<ol>
<li class="lvl-3">
<p>我们先进入博客根目录下的<code>/node_modules/hexo-reference</code></p>
<p><small>没错，笔者准备对这个插件进行修改</small></p>
</li>
<li class="lvl-3">
<p>然后查看文件<code>index.js</code></p>
<p><small>不出意外的话这个一般是插件的入口文件</small></p>
<p>我们看到这个文件前有一段<code>js</code>引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renderFootnotes = <span class="built_in">require</span>(<span class="string">&#x27;./src/footnotes&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没错，笔者在看完其后代码之后认为核心渲染程序应该在</p>
<p><code>./src/footnotes</code></p>
</li>
<li class="lvl-3">
<p>然后我们找到这个文件，即插件根目录下的<code>/src/footnotes.js</code>文件，笔者打开了它并把<code>hint--error</code>给删了</p>
</li>
<li class="lvl-3">
<p>然后就好了</p>
</li>
</ol>
<p><small>其实笔者在记录过程是一边做一边写的，<u>所幸笔者猜对了</u></small></p>
<p><small>Oops! 笔者在阅读代码的时候发现这个插件好像依赖插件<code>markdown-it</code></small></p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>折腾hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第六章复习</title>
    <url>/posts/b90b7ae5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />  

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>放一下操作系统第六章复习笔记吧</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="虚拟存储器的概念"><a class="header-anchor" href="#虚拟存储器的概念">¶</a>虚拟存储器的概念</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>局部性原理</p>
</li>
<li class="lvl-2">
<p>虚拟存储器的概念</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>局部性的特征体现</p>
</li>
<li class="lvl-3">
<p>理解虚拟存储器</p>
</li>
<li class="lvl-3">
<p>虚拟存储器的容量</p>
</li>
</ol>
<h3 id="虚拟存储器的任务"><a class="header-anchor" href="#虚拟存储器的任务">¶</a>虚拟存储器的任务</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>逻辑上扩充内存容量</p>
</li>
</ul>
<h3 id="局部性原理"><a class="header-anchor" href="#局部性原理">¶</a>局部性原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间局部性：</p>
<p>一条指令被执行了，则在不久的将来它可能再被执行。</p>
</li>
<li class="lvl-2">
<p>空间局部性：</p>
<p>若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。</p>
</li>
</ul>
<blockquote>
<p>只需要让程序当前需要运行的内容存在于内存中，程序就能跑</p>
</blockquote>
<h3 id="虚拟存储器的定义"><a class="header-anchor" href="#虚拟存储器的定义">¶</a>虚拟存储器的定义</h3>
<p>具有请求调入功能<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="调入功能 是 指将进程所需的数据或指令从磁盘调入主存">[1]</span></a></sup>和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<p><big>虚拟存储器的容量 = $min($ 内存 $+$ 外存 $,$ <code>cpu</code>寻址空间 $)$ </big></p>
<h3 id="虚拟存储器的特征"><a class="header-anchor" href="#虚拟存储器的特征">¶</a>虚拟存储器的特征</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>多次性</p>
</li>
<li class="lvl-2">
<p>对换性</p>
</li>
<li class="lvl-2">
<p>虚拟性</p>
</li>
</ul>
<h3 id="虚拟存储器的实现"><a class="header-anchor" href="#虚拟存储器的实现">¶</a>虚拟存储器的实现</h3>
<h4 id="请求分页系统"><a class="header-anchor" href="#请求分页系统">¶</a>请求分页系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：页表、缺页中断、地址变换机构</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调页软件、页面置换软件</p>
</li>
</ul>
<h4 id="请求分段系统"><a class="header-anchor" href="#请求分段系统">¶</a>请求分段系统</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件支持：段表、缺段中断、地址变换机构。</p>
</li>
<li class="lvl-2">
<p>软件支持：请求调段软件、段置换软件。</p>
</li>
</ul>
<h4 id="段页式虚拟存储器"><a class="header-anchor" href="#段页式虚拟存储器">¶</a>段页式虚拟存储器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>增加请求调页和页面置换。</p>
</li>
</ul>
<h2 id="请求分页存储管理"><a class="header-anchor" href="#请求分页存储管理">¶</a>请求分页存储管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101903431.png" alt="image-20241210190318202"></p>
<h3 id="目标评价"><a class="header-anchor" href="#目标评价">¶</a>目标评价</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0"><label for="checkbox0">请求分页中的页表需要如何修改？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1"><label for="checkbox1">缺页中断有何特点？缺页中断如何处理？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2"><label for="checkbox2">请求分页管理中地址转换如何完成？</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3"><label for="checkbox3">页面置换算法有哪些？如何完成页面置换？有何特点？缺页率如何计算？</label></p>
</li>
</ul>
<h3 id="硬件支持"><a class="header-anchor" href="#硬件支持">¶</a>硬件支持</h3>
<h4 id="页表机制"><a class="header-anchor" href="#页表机制">¶</a>页表机制</h4>
<p>需要在进程页表<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="进程页表 是操作系统管理虚拟存储器时，用于映射进程的 **虚拟地址**和 **物理地址** 的一个重要数据结构。&lt;br&gt;每个进程都有自己的 **页表** ，它记录了该进程所有虚拟页的相关信息，&lt;br&gt;包括虚拟页是否已被加载到主存以及其对应的物理页框地址。">[2]</span></a></sup>中添加若干项</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态位P：指示该页是否在内存</p>
</li>
<li class="lvl-2">
<p>访问字段A：记录该页在一段时间内被访问的次数</p>
</li>
<li class="lvl-2">
<p>修改位M：也称脏位，标志该页是否被修改过</p>
</li>
<li class="lvl-2">
<p>外存地址：指示该页在外存中的地址（物理块号）</p>
</li>
</ul>
<h4 id="缺页中断机构"><a class="header-anchor" href="#缺页中断机构">¶</a>缺页中断机构</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>在指令执行期间产生和处理中断信号</p>
</li>
<li class="lvl-2">
<p>一条指令在执行期间，可能产生多次缺页中断</p>
</li>
</ul>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>关于 <em><a href="/posts/52e033e8"><code>一条指令在执行期间，可能产生多次缺页中断</code></a></em></h4>
<h4>指令本身产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>指令取指</strong></p>
<p><code>cpu</code>在只从一条指令时，需要从主存取出指令。如果指令所在的虚拟页面尚未加载到主存，就会触发缺页中断。</p>
</li>
</ul>
<h4>操作数访问导致的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>直接操作数</strong></p>
<p>如果指令是使用了内存中的数据作为操作数，操作数对应的页面可能尚未加载，触发缺页中断</p>
</li>
<li class="lvl-2">
<p><strong>间接访问</strong></p>
<p>指令可能需要通过指针或索引来访问内存中的数据。如果这些地址指向的页面不在主存，也会触发缺页中断</p>
</li>
</ul>
<h4>指令操作多次访问内存</h4>
<p>一些复杂的指令（尤其在<a href="/posts/7436c65f">CISC架构</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="**CISC（Complex Instruction Set Computer）** 架构是一种处理器设计理念，其特点是提供 **复杂且多样化的指令集**">[3]</span></a></sup>中）可能在执行期间涉及多个内存访问，每次访问可能触发缺页中断。例如：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>字符串处理指令</strong><br>
一条指令可能遍历一个数组或字符串，多次访问内存中的页面。</p>
</li>
<li class="lvl-2">
<p><strong>多维数组操作</strong><br>
在访问二维或三维数组时，可能涉及多个页面。</p>
</li>
</ul>
<h4>页表访问产生的缺页中断</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>多级页表</strong><br>
虚拟地址到物理地址的转换需要访问页表。如果页表本身存储在磁盘中，访问页表时可能触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>页目录和页表分级加载</strong><br>
如果多级页表结构中的多个级别对应的页面都不在主存，每一级别都会触发一次缺页中断。</p>
</li>
</ul>
<h4>内存管理器的间接操作</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>堆栈操作</strong><br>
某些指令（如函数调用或返回）会隐式修改堆栈指针。如果堆栈页面未加载，也会触发缺页中断。</p>
</li>
<li class="lvl-2">
<p><strong>动态内存分配</strong><br>
指令可能涉及动态分配的内存区域（如<code>malloc</code>或<code>new</code>），而这些区域的页面可能尚未加载到主存。</p>
</li>
</ul>
</p>
    </div>
</div><h4 id="缺页中断的特殊性"><a class="header-anchor" href="#缺页中断的特殊性">¶</a>缺页中断的特殊性</h4>
<p>缺页中断在指令执行期间产生和进行处理，而不是在一条指令执行完毕之后。所缺的页面调入之后，重新执行被中断的指令</p>
<h4 id="地址变换机构"><a class="header-anchor" href="#地址变换机构">¶</a>地址变换机构</h4>
<p>与分页内存管理方式类似</p>
<p>由逻辑地址检索页表，根据对应页表项的标志位判断，若在内存中，则直接形成物理地址。</p>
<p>如不在内存中，产生缺页中断，从对应页表项的外存地址，从外存找到该页，内存满，则选择页面换出，否则从外存直接调入内存。完成地址转换。<img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412102029580.png" alt="image-20241210202946621"></p>
<h4 id="内存分配"><a class="header-anchor" href="#内存分配">¶</a>内存分配</h4>
<h5 id="最小物理块数的确定"><a class="header-anchor" href="#最小物理块数的确定">¶</a>最小物理块数的确定</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>保证进程正常运行所需的最小物理块数</p>
</li>
</ul>
<h5 id="物理块的分配策略"><a class="header-anchor" href="#物理块的分配策略">¶</a>物理块的分配策略</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配，局部置换</p>
</li>
<li class="lvl-2">
<p>可变分配，全局置换</p>
</li>
<li class="lvl-2">
<p>可变分配，局部置换</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/907f4c43">物理块的分配策略</a></p>
<h5>固定与可变</h5>
<p><strong>固定</strong>与<strong>可变</strong>的区别在于给进程分配的物理块数</p>
<p>即<strong>固定</strong>是指在给<strong>每个进程</strong>均分配<strong>固定数量</strong>的物理块</p>
<p>可变即根据进程的不同，分配<strong>不同数量</strong>的物理块</p>
<h5>全局与局部</h5>
<p>即，当进程执行是发生缺页后，换入换出操作执行的范围</p>
<p><strong>局部</strong> 即，当进程要执行换入换出操作时，仅在操作系统为<strong>该进程分配的物理空间</strong>之内发生替换，而不会影响其他进程块</p>
<p><strong>全局</strong> 即，当前进程需要换入缺页的部分时，不仅仅会挑选当前进程拥有的物理块，还可能会换出其他进程的物理块。</p>
</p>
    </div>
</div><h5 id="物理块分配算法"><a class="header-anchor" href="#物理块分配算法">¶</a>物理块分配算法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>平均分配算法</p>
</li>
<li class="lvl-2">
<p><span style="color: red">按比例分配算法</span></p>
</li>
<li class="lvl-2">
<p>考虑优先权的分配算法</p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><a href="/posts/8ba68849">物理块分配算法</a></p>
<p><strong>对比总结</strong></p>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>分配依据</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>平均分配算法</td>
<td>平均分配</td>
<td>进程需求量相近的场景</td>
<td>简单、公平</td>
<td>无法动态适应需求，可能浪费资源</td>
</tr>
<tr>
<td>按比例分配算法</td>
<td>内存需求比例</td>
<td>进程需求量差异大的场景</td>
<td>资源利用率高，满足需求较大的进程</td>
<td>计算复杂度较高</td>
</tr>
<tr>
<td>考虑优先权的分配算法</td>
<td>需求量和优先级</td>
<td>多任务场景，优先保证关键任务</td>
<td>确保关键任务优先，灵活调整分配策略</td>
<td>可能导致低优先级任务资源匮乏</td>
</tr>
</tbody>
</table>
<p>在实际系统中，按比例分配算法和考虑优先权的分配算法更常见，因为它们能够更好地适应动态环境的需求。</p>
</p>
    </div>
</div><h4 id="调页策略-small-又称-调页技术-small-详解-small-small"><a class="header-anchor" href="#调页策略-small-又称-调页技术-small-详解-small-small">¶</a>调页策略<small>又称  调页技术<small><a href="/posts/f830ee25">详解</a></small></small></h4>
<h5 id="何时调入页面"><a class="header-anchor" href="#何时调入页面">¶</a>何时调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>预调页策略：预先调入一些页面到内存</p>
</li>
<li class="lvl-2">
<p>请求调页策略：发现需要访问的页面不在内存时，调入内存</p>
</li>
</ul>
<h5 id="从何处调入页面"><a class="header-anchor" href="#从何处调入页面">¶</a>从何处调入页面</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>如系统拥有足够的对换区空间，全部从对换区调入所需页面</p>
</li>
<li class="lvl-2">
<p>如系统缺少足够的对换区空间，凡是不会被修改的文件，都直接从文件区调入</p>
<p>当换出这些页面时，由于未被修改而不必再将它们重写磁盘，以后再调入时，仍从文件区直接调入</p>
</li>
<li class="lvl-2">
<p>UNIX方式：未运行过的页面，从文件区调入；曾经运行过但又被换出的页面，从对换区调入</p>
</li>
</ul>
<h5 id="span-style-color-red-如何调入页面-span"><a class="header-anchor" href="#span-style-color-red-如何调入页面-span">¶</a><span style="color:red">如何调入页面</span></h5>
<ol>
<li class="lvl-3">
<p>查找所需页在磁盘上的位置</p>
</li>
<li class="lvl-3">
<p>查找一内存空闲块：</p>
<ul class="lvl-2">
<li class="lvl-5">如果有空闲块，就直接使用它</li>
<li class="lvl-5">如果没有空闲块，使用页面置换算法选择一个&quot;牺牲&quot;内存块</li>
<li class="lvl-5">将“牺牲”块的内容写到磁盘上，更新页表和物理块表</li>
</ul>
</li>
<li class="lvl-3">
<p>将所需页读入新空闲块，更新页表</p>
</li>
<li class="lvl-3">
<p>重启用户进程</p>
</li>
</ol>
<h5 id="缺页率"><a class="header-anchor" href="#缺页率">¶</a>缺页率</h5>
<p>缺页率的计算：<br>
$$<br>
f= F/A<br>
$$</p>
<center><small>s为访问页面成功<small>(在内存中)</small>次数</small></center>
<center><small>F为访问页面失败<small>(不在内存)</small>次数</small></center>
<center><small>A为总访问次数 A = s+F</small></center>
<ul class="lvl-0">
<li class="lvl-2">
<p>影响因素：页面大小、分配内存块的数目、页面置换算法、程序固有属性</p>
</li>
</ul>
<p>缺页中断处理的时间：</p>
<p>$$<br>
t = β×t_a + (1- β)×t_b<br>
$$</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h5>例子</h5>
<p>存取内存的时间= 200 nanoseconds (ns)</p>
<p>平均缺页处理时间 = 8 milliseconds (ms)</p>
<p><em>t</em> = (1 – p) × 200ns + p × 8ms</p>
<p>= (1 – p) × 200ns + p ×8,000,000ns</p>
<p>= 200ns + p × 7,999,800ns</p>
<p>如果每1,000次访问中有一个缺页中断，那么：</p>
<p><em>t</em> = 8.2 ms</p>
<p><strong>这是导致计算机速度放慢</strong> <strong>40</strong> <strong>倍的影响因子！</strong></p>
</p>
    </div>
</div><h4 id="页面置换算法"><a class="header-anchor" href="#页面置换算法">¶</a>页面置换算法</h4>
<p><strong>功能</strong>：需要调入页面时，选择内存中年哪个物理页面被置换。称为replacement policy<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="policy：/ˈpɒləsi/ n.  策略；方针；">[4]</span></a></sup></p>
<p><small><strong>目标</strong>：把未来不再使用的或短期内较少使用的页面调出，通常只能在局部性原理指导下依据过去的统计数据进行预测；</small></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>算法一览</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>最佳算法(<strong>OPT</strong>, optimal)</p>
</li>
<li class="lvl-2">
<p>先进先出算法(<strong>FIFO</strong>)</p>
</li>
<li class="lvl-2">
<p>最近最久未使用算法(<strong>LRU</strong>, Least Recently Used)</p>
</li>
<li class="lvl-2">
<p>轮转算法(clock)</p>
</li>
<li class="lvl-2">
<p>最不常用算法(<strong>LFU</strong>, Least Frequently Used)</p>
</li>
<li class="lvl-2">
<p>页面缓冲算法(page buffering)</p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最佳置换算法-OPT"><a class="header-anchor" href="#最佳置换算法-OPT">¶</a>最佳置换算法 OPT</h5>
<p>被置换的页将是之后最长时间不被使用的页</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111512688.png" alt="image-20241211151237943"></p>
<p>无法实现的算法，可用来评价其他算法</p>
<h5 id="先进先出置换算法"><a class="header-anchor" href="#先进先出置换算法">¶</a>先进先出置换算法</h5>
<p><span style="color:red">总是淘汰最先进入内存的页面</span>，即选择在内存中驻留时间最久的页面予以淘汰</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111515908.png" alt="image-20241211151558420"></p>
<p>性能较差。较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。并且有Belady现象。</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="贝拉迪  贝拉迪异常（Belady&#039;s anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误">[5]</span></a></sup> 现象</h4>
<p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。</p>
<h4>Belady现象的描述</h4>
<p>一个进程P要访问M个页，OS分配N个内存页面给进程P；对一个访问序列S，发生缺页次数为PE（S,N）。当N增大时，PE(S, N)时而增大，时而减小。</p>
<h4>Belady现象的原因</h4>
<p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的。</p>
<blockquote>
<p>反而，先加载进去的页面可能是访问次数最多的，如c语言中，定义的函数往往放在<code>main</code>函数<small>程序入口之前</small>，而且当函数调用另一个函数时，被调用的函数必须放在当前函数之前。</p>
</p>
    </div>
</div></blockquote>

<div class="callout callout-info">
    <div class="callout-head">
        <span class="callout-head-icon">ℹ️</span>
        <span class="callout-head-text" style="color:#3178c6">INFO</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>Belady现象的例子</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>进程P有5页程序访问页的顺序为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5；</p>
</li>
<li class="lvl-2">
<p>如果在内存中分配3个页面，则缺页情况如下：12次访问中有缺页9次；</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111539081.png" alt="image-20241211153920646"></p>
</li>
<li class="lvl-2">
<p>如果在内存中分配4个页面，则缺页情况如下：12次访问中有缺页10次</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111540590.png" alt="image-20241211154006562"></p>
</li>
</ul>
</p>
    </div>
</div><h5 id="最近最久未使用-LRU"><a class="header-anchor" href="#最近最久未使用-LRU">¶</a>最近最久未使用 LRU</h5>
<p>选择内存中<span style="color:blue;">最久未使用的页面</span>被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111631081.png" alt="image-20241211163148299"></p>
<h6 id="硬件支持-2"><a class="header-anchor" href="#硬件支持-2">¶</a>硬件支持</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>寄存器</p>
<p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个<a href="/posts/3d2c198d">移位寄存器</a><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="**移位寄存器**（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。">[6]</span></a></sup>，可表示为<br>
$$<br>
R=R_{n-1}R_{n-2}R_{n-3}…R_2R_1R_0<br>
$$</p>
<p><strong>某进程具有</strong> <strong>8</strong> <strong>个页面时的</strong> <strong>LRU</strong> <strong>访问情况</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111652427.png" alt="image-20241211165224336"></p>
</li>
<li class="lvl-2">
<p>栈</p>
<p>用栈保存时，栈的变换情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111656423.png" alt="image-20241211165630180"></p>
</li>
</ul>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>实际实现<small><a href="/posts/f041ded5">详细实现过程</a></small></h4>
<p><strong>最近最久未使用（LRU）算法</strong> 的实现可以通过移位寄存器或栈的方式完成。这两种方式各有特点：</p>
<h5><strong>1. 用移位寄存器实现 LRU</strong></h5>
<p>移位寄存器是一种硬件或软件模拟的寄存结构，通过移位操作记录页面访问的历史。实现过程如下：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个页面框分配一个寄存器，初始值为 0。</p>
</li>
<li class="lvl-2">
<p>每次页面访问时，将该寄存器的最高位置为 1，其余位依次右移。</p>
</li>
<li class="lvl-2">
<p>未访问的页面寄存器位移后会逐渐变成更小的值。</p>
</li>
<li class="lvl-2">
<p>页面置换时，选择寄存器值最小的页面，即最久未使用的页面。</p>
</li>
</ul>
<p>这种实现方式简单直观，但寄存器的位数增加会带来更多硬件需求，因此通常适合于特定规模的小型系统【18】【19】。</p>
<h5><strong>2. 用栈实现 LRU</strong></h5>
<p>通过栈来管理页面访问，栈顶表示最近使用的页面，栈底表示最久未使用的页面：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次页面被访问时，若其已在栈中，则将其从原位置移除并放到栈顶。</p>
</li>
<li class="lvl-2">
<p>若页面不在栈中，则将其直接插入栈顶。</p>
</li>
<li class="lvl-2">
<p>如果栈已满，移除栈底元素（最久未使用页面），然后插入新页面。</p>
</li>
</ul>
<p>栈的实现可以通过链表实现动态插入删除操作，同时保证页面顺序的调整。相比移位寄存器，栈方法适合于较大规模的系统，灵活性更高，但需要额外的空间来存储栈【18】【19】。</p>
<p>以上两种方法在实际系统中应用时，还会因性能需求选择优化的数据结构（如哈希表结合链表），以便实现更高效的页面访问与置换管理。</p>
</p>
    </div>
</div><h5 id="Clock置换算法"><a class="header-anchor" href="#Clock置换算法">¶</a>Clock置换算法</h5>
<p>LRU的近似算法，又称最近未用(NRU)或二次机会页面置换算法</p>
<h6 id="简单的Clock算法"><a class="header-anchor" href="#简单的Clock算法">¶</a>简单的Clock算法</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个页都与一个访问位相关联，初始值为0</p>
</li>
<li class="lvl-2">
<p>当页被访问时置访问位为1</p>
</li>
<li class="lvl-2">
<p>置换时选择访问位为0的页 ；若为1，重新置为0</p>
</li>
</ul>
<p><left><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111709272.png" alt="image-20241211170935261" style="zoom:45%;" /></left><br>
<right><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412111714913.png" alt="image-20241211171426161" style="zoom:45%;" /></right></p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>像是时钟一样，在需要进行页表置换时，转着圈访问上图所示的访问位</p>
<p><small>若顺时针</small></p>
<p>当转到每一个访问位时，如果当前转到的访问位的值为1，则将该访问位置为0，然后接着访问下一个访问位</p>
<p>直到遇到第一个为0的访问位，则将该访问位对应的页表换出。</p>
</p>
    </div>
</div>
<div class="callout callout-warning">
    <div class="callout-head">
        <span class="callout-head-icon">⚠️</span>
        <span class="callout-head-text" style="color:#e5a700">WARNING</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>概述：当使用<code>clock</code>算法换入缺失的页面后，指针会指向当前换入页的后一个页。</p>
<h4>细节辨析</h4>
<p>当算法已经选择好了一个页面并将其换出的细节过程</p>
<p>比如替换前的序列</p>
<p>$[\overset{\downarrow}{1_1}, 2_1, 3_1]$</p>
<p>现在需要调入页面$4$在使用<code>clock</code>算法计算后：</p>
<p>$[\overset{\downarrow}{1_0}, 2_0, 3_0]$</p>
<p>此时页面$1$被选择，然后替换</p>
<p>$[\overset{\downarrow}{4_1}, 2_1, 3_1]$</p>
<p>然后指针指向刚换入页面的<strong>后一个页面</strong></p>
<p>$[{1_1}, \overset{\downarrow}{2_1}, 3_1]$</p>
<p>然后才完成一次完整的$clock$</p>
</p>
    </div>
</div><h6 id="改进Clock置换算法"><a class="header-anchor" href="#改进Clock置换算法">¶</a>改进Clock置换算法</h6>
<p>除须考虑页面的使用情况外，还须增加置换代价</p>

<div class="callout callout-note">
    <div class="callout-head">
        <span class="callout-head-icon">📝</span>
        <span class="callout-head-text" style="color:#673ab7">NOTE</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>考虑置换代价，即考虑当前页表是否被修改</p>
<p>因为被修改的页表，需要写入磁盘更加耗时</p>
<p><small>没有被修改的页表，在换出后直接丢掉就好了</small></p>
</p>
    </div>
</div><p>即，淘汰时，同时检查访问位A与修改位M</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第1类（A=0，M=0）：表示该页最近既未被访问、又未被修改，是最佳淘汰页。</p>
</li>
<li class="lvl-2">
<p>第2类（A=0，M=1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。</p>
</li>
<li class="lvl-2">
<p>第3类（A=1，M=0）：表示该页最近已被访问，但未被修改，该页有可能再被访问。</p>
</li>
<li class="lvl-2">
<p>第4类（A=1，M=1）：表示该页最近已被访问且被修改，该页有可能再被访问。</p>
</li>
</ul>
<p>置换时，循环依次查找第1类、第2类页面，找到为止。</p>
<h5 id="最少使用置换算法-LFU-small-详细解释-small"><a class="header-anchor" href="#最少使用置换算法-LFU-small-详细解释-small">¶</a>最少使用置换算法 LFU<small><a href="/posts/78bb016d">详细解释</a></small></h5>
<p>为内存中的每个页面设置一个移位寄存器，用来记录该页面的被访问频率</p>
<p>LFU 选择在<span style="color:red">最近时期使用最少的额页面内</span>作为淘汰页</p>
<h5 id="页面缓冲算法-PBA"><a class="header-anchor" href="#页面缓冲算法-PBA">¶</a>页面缓冲算法 PBA</h5>
<p>是对 FIFO<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--medium hint--rounded hint--bounce" aria-label="先进先出算法">[7]</span></a></sup> 算法的发展，通过被置换页面的缓冲，有机会找回刚被置换的页面</p>
<h6 id="被置换页面的选择和处理："><a class="header-anchor" href="#被置换页面的选择和处理：">¶</a><strong>被置换页面的选择和处理</strong>：</h6>
<p>用 FIFO 算法选择被置换页，把被置换的页面放入两个链表之一</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果页面未被修改，就将其归入到空闲页面链表的末尾</p>
</li>
<li class="lvl-2">
<p>否则将其归入到已修改页面链表。</p>
</li>
</ul>
<h6 id="处理过程"><a class="header-anchor" href="#处理过程">¶</a>处理过程</h6>
<p>需要调入新的物理页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除。</p>
<p>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面再次被访问，只需要较小的开销就可以将被访问的页面返还，重新作为进程的内容页。</p>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>其实，空闲页面链表和已修改页面链表就像两个缓冲区，等过了缓冲时间任未访问的页面就真的扔了。</p>
</p>
    </div>
</div><p>当已修改页面达到一定次数后，在将它们一起调出到外存，然后将他们归入空闲页面链表，这样能大大减少I/O操作次数<small>也相当于是一个缓冲区吧，页表I/O缓冲区，因为I/O操作比较慢</small></p>
<h4 id="访问内存的有效时间"><a class="header-anchor" href="#访问内存的有效时间">¶</a>访问内存的有效时间</h4>
<p>系统中有快表，</p>
<center><small>快表时间λ，</small></center>
<center><small>页表时间t，</small></center>
<center><small>缺页处理时间ε，</small></center>
<center><small>快表命中率a，</small></center>
<center><small>缺页率f</small></center>
<p>具有快表的请求分页管理方式的内存访问操作：</p>
<p>（1）被访问页在内存中，对应页表项在快表中</p>
<p>​    EAT=λ+t</p>
<p>（2）被访问页在内存中，对应页表项不在快表中</p>
<p>​    EAT=λ+t+λ+t=2×（λ+t）</p>
<p>（3）被访问页不在内存中</p>
<p>​    EAT= λ+t+ε+λ+t=2×（λ+t）+ε</p>
<p>（4）快表命中率为a，缺页率为f，缺页中断处理时间为ε</p>
<p>EAT= λ+a×t+(1-a)×((1-f)×(λ+t)+f×(t+ε+ λ)+t)</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412122117572.png" alt="image-20241212211714003"></p>
<center><small>耗费时间计算</small></center>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p><code>cache</code>是用来加速<code>cpu</code>访问主存，如果<code>cache</code>中有数据，<code>cpu</code>就可以直接拿</p>
<p>快表是用来加速地址转换的</p>
<blockquote>
<p><a href="/posts/c38ea43e">在地址转换过程中会访问两次页表嘛？</a></p>
</p>
    </div>
</div></blockquote>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h4>勘误</h4>
<p>经过讨论，该部分的计算应该以题目给出图片为准。</p>
<p>我们首先对上图进行详细声明：</p>
<p>第一行的$\lambda$，即查询对应页表是否在<code>TLB</code>的时间</p>
<p>第二行第一列$t$，即访问主存中的页表花费时间</p>
<p>第二行第二列$\lambda$，即更新TLB，并将$V_A$转换为物理地址花费时间</p>
<p>第三行第一列$\varepsilon$，即缺页处理总时间</p>
<p>第三行右侧 $t$，即<code>cache</code>缺页处理总时间</p>
<p>最后一行 $c$，访问<code>cache</code>存取数据时间。</p>
<p>则根据流程图，各情况处理的实际耗费时间就显而易见了。</p>
<p><big>值得一提的是，上图之前所给的时间计算是没有将<code>cache</code>考虑进去的</big></p>
</p>
    </div>
</div><h4 id="抖动与工作集"><a class="header-anchor" href="#抖动与工作集">¶</a>抖动与工作集</h4>
<h5 id="抖动-颠簸-Thrashing"><a class="header-anchor" href="#抖动-颠簸-Thrashing">¶</a>抖动/颠簸(Thrashing)</h5>
<p>页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象为颠簸。</p>
<h6 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h6>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统中运行的进程太多</p>
</li>
<li class="lvl-2">
<p>页面淘汰算法不合理</p>
</li>
<li class="lvl-2">
<p>分配给进程的物理页面数太少</p>
</li>
</ul>
<h5 id="常驻集"><a class="header-anchor" href="#常驻集">¶</a>常驻集</h5>
<p>常驻集指虚拟页式管理中给进程分配的物理页面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412112032913.png" alt="image-20241211201956645"></p>
<center><small>缺页率和物理块数（常驻集）之间的关系图</small></center>
<h5 id="工作集"><a class="header-anchor" href="#工作集">¶</a>工作集</h5>
<blockquote>
<p>1968年由Denning提出，目的是依据进程在过去的一段时间内访问的页面来调整常驻集大小。</p>
</blockquote>
<p>所谓工作集，指在某段时间间隔Δ里进程实际要访问页面的集合。</p>
<p>把某进程在时间t的工作集记为w(t，Δ),其中的变量Δ称为工作集的“窗口尺寸”</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$\Delta$是一个虚拟时间段，称为窗口大小(window size)，它采用&quot;虚拟时间&quot;单位(阻塞时不计时)，大致可以用执行的指令数目，或处理器执行时间来计算；</p>
</li>
<li class="lvl-2">
<p>工作集是在[t - $\Delta$, t]时间段内所访问的页面的集合；</p>
</li>
<li class="lvl-2">
<p>| W(t, $\Delta$) | 指工作集大小即页面数目；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412112032473.png" alt="image-20241211202426933"></p>
<h6 id="抖动的预防方法"><a class="header-anchor" href="#抖动的预防方法">¶</a>抖动的预防方法</h6>
<ol>
<li class="lvl-3">
<p>采取局部置换策略：只能在分配给自己的内存空间内进行置换；</p>
</li>
<li class="lvl-3">
<p>把工作集算法融入到处理机调度中，让常驻集包含工作集；</p>
</li>
<li class="lvl-3">
<p>利用“L=S”准则调节缺页率：</p>
 <center><small>L是缺页之间的平均时间</small></center>
 <center><small>S是平均缺页服务时间，即用于置换一个页面的时间</small></center>
<ul class="lvl-2">
<li class="lvl-6">
<p>L&gt;S，说明很少发生缺页</p>
</li>
<li class="lvl-6">
<p>L&lt;S，说明频繁缺页</p>
</li>
<li class="lvl-6">
<p>L=S，磁盘和处理机都可达到最大利用率</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>选择暂停进程。</p>
</li>
</ol>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div><div id="footnotes"><hr><h4>相关注解</h4><ol class="custom-footnotes"><li id="fn:1" class="footnote-item"><span class="footnote-content">调入功能 是 指将进程所需的数据或指令从磁盘调入主存<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="footnote-item"><span class="footnote-content">进程页表 是操作系统管理虚拟存储器时，用于映射进程的 <strong>虚拟地址</strong>和 <strong>物理地址</strong> 的一个重要数据结构。<br>每个进程都有自己的 <strong>页表</strong> ，它记录了该进程所有虚拟页的相关信息，<br>包括虚拟页是否已被加载到主存以及其对应的物理页框地址。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3" class="footnote-item"><span class="footnote-content"><strong>CISC（Complex Instruction Set Computer）</strong> 架构是一种处理器设计理念，其特点是提供 <strong>复杂且多样化的指令集</strong><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4" class="footnote-item"><span class="footnote-content">policy：/ˈpɒləsi/ n.  策略；方针；<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5" class="footnote-item"><span class="footnote-content">贝拉迪  贝拉迪异常（Belady's anomaly）是一种计算机科学中的现象，指的是在某些页面置换算法中，增加可用的物理内存可能导致更多的页面错误<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6" class="footnote-item"><span class="footnote-content"><strong>移位寄存器</strong>（Shift Register）是一种数字电路，用于将数据按照一定规则在其存储单元之间移动。它是由一组触发器（Flip-Flop）组成的逻辑电路，每个触发器存储一个位数据。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7" class="footnote-item"><span class="footnote-content">先进先出算法<a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div>]]></content>
      <categories>
        <category>408 - OS</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>408</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾hexo</title>
    <url>/posts/8dc8b2ab.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
  </entry>
  <entry>
    <title>关于本博客的客制化css</title>
    <url>/posts/d9cd1415.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>当然是记一些关于本博客客制化<code>css</code>相关的内容啦</p>
</p>
    </div>
</div><span id="more"></span>
<p><strong>由于之前说到<a href="/posts/4179">用自定义渲染器渲染<code>callout</code></a></strong></p>
<p>但是其中其实还有一个问题有待解决：</p>
<p><big>如何将自定义的<code>callout</code>样式块渲染出来</big></p>
<p><small>这里指的是，<code>Markdown</code>已经成功的转换成显示在网站中的<code>html</code>代码块了</small></p>
<p>但是实际上我们发现，解析的<code>html</code>我们确实有了，但是<code>callout</code>并非是我们想要的样式，而是一个并没有进行任何着色的状态。</p>
<h2 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义<code>css</code>样式</h2>

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<h3>2.1 添加客制化css</h3>
<p>虽然在<code>css</code>目录下任意<code>.styl</code>下添加<code>css</code>样式代码可以生效，但是为了方便以后修改，最好创建一个新的<code>.styl</code>文件记录自己的修改。</p>
<ol>
<li class="lvl-3">
<p>在<code>themes/next/source/css/main.styl</code>最后加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;_custom/custom&quot;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>在<code>themes/next/source/css</code>目录下创建<code>_custom</code>文件夹；</p>
</li>
<li class="lvl-3">
<p>在目录<code>themes/next/source/css/_custom</code>下新建文件<code>custom.styl</code>。</p>
</li>
<li class="lvl-3">
<p>在<code>custom.styl</code>中添加<code>css</code>样式修改博客的<code>css</code>。</p>
</li>
</ol>
<p>—— 摘自 <a href="https://zachary116699.github.io/2024/05/09/hexo-next-css/">hexo-next主题配置css | 大水笔✰档案室</a></p>
</p>
    </div>
</div><p>然后就是将自己自定义的<code>css</code>样式放在里面</p>
<p>这里贴一下<code>callout</code>样式部分：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基础样式 */</span></span><br><span class="line"><span class="selector-class">.callout</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">4px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Info 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-info</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#3178c6</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e3f2fd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Warning 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-warning</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#e5a700</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff3e0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Error 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-error</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#d32f2f</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffebee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Success 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-success</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#2e7d32</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e8f5e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-note</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#673ab7</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ede7f6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tip 样式 */</span></span><br><span class="line"><span class="selector-class">.callout-tip</span> &#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="number">#009688</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0f2f1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，就好了，现在整个<code>callout</code>块的部分就完整了🙌</p>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
  <entry>
    <title>考试时间统计</title>
    <url>/posts/28f58f35.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />
<ul class="lvl-0">
<li class="lvl-2">计组：25号</li>
</ul>
<span id="more"></span>
<hr />
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>]]></content>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 callout 块渲染</title>
    <url>/posts/4179.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="https://cdn.jsdelivr.net/gh/03xiaoyuhe/PicStore/img/202412101418265.png" alt="" style="width:100%" />

<div class="callout callout-tip">
    <div class="callout-head">
        <span class="callout-head-icon">💡</span>
        <span class="callout-head-text" style="color:#009688">TIP</span>
    </div>
    <div class="callout-contents">
        <p><p></p>
<p>记录一下<code>callout</code>支持过程。</p>
</p>
    </div>
</div><span id="more"></span>
<h2 id="初期想法"><a class="header-anchor" href="#初期想法">¶</a>初期想法</h2>
<p>因为<code>hexo</code>支持<code>markdown</code>基础语法，而笔者在使用<code>hexo</code>之前，恰好使用过<code>Obsidian</code>笔记软件，非常喜欢使用<code>Obsidian</code>中的<code>Callout</code>块。</p>
<p>但发现网上并没有相关解决方案，虽然可以使用自定义代码块的方式书写类似<code>callout</code>块的效果，但是这样就和当前使用的<code>markdown</code>编辑器不兼容，而且自定义代码块的样式并不好看。<small><del>笔者还是比较喜欢即写即渲染的编辑模式</del></small></p>
<p>所以，笔者就想提供一个专门用于渲染<code>callout</code>块的自定义渲染器，<small>笔者曾经写过一个<code>python</code>的<code>md</code>渲染器，就在书写本文章不久前，也是为了解决<code>callout</code>块问题</small></p>
<p><small><del>笔者对<code>callout</code>还是非常喜爱的</del></small></p>
<h2 id="实际实现"><a class="header-anchor" href="#实际实现">¶</a>实际实现</h2>
<p>首先，安装<code>hexo-renderer-markdown-it</code> 以及 <code>markdown-it-container</code> 插件来扩展 <code>Markdown</code> 功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-container --save</span><br></pre></td></tr></table></figure>
<p>在 <code>hexo-renderer-markdown-it</code> 配置中启用容器解析： 修改 <code>Hexo</code> 的 <code>_config.yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-container</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时，<code>hexo</code>已经支持运行自定义的<code>markdown</code>了。</p>
<p>接下来，我们书写<code>callout</code>渲染器。</p>
<p><small><del>其实笔者在该部分废了老大的劲</del></small></p>
<p>我先贴下代码</p>
<h3 id="自定义渲染器代码"><a class="header-anchor" href="#自定义渲染器代码">¶</a>自定义渲染器代码</h3>
<p><small>二编了🤡代码最终还是没躲过bug，当然鲁棒性肯定更高了</small></p>
<p><small>三编了，这次是加了支持表情符的功能，这个也是typora支持的😴</small></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iconConfig = &#123;</span><br><span class="line">    <span class="string">&quot;important&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#3178c6&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;ℹ️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;warning&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#e5a700&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;⚠️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;caution&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#d32f2f&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;❌&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;success&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#2e7d32&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;✔️&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;note&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#673ab7&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;📝&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;tip&quot;</span>: &#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#009688&quot;</span>, <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;💡&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadIcon</span>(<span class="params">iconName</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[iconName] || iconConfig[<span class="string">&quot;important&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;span class=&quot;callout-head-icon&quot;&gt;<span class="subst">$&#123;iconInfo.icon&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateCalloutHTML</span>(<span class="params">type, tokens, state</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化 markdown-it 实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MarkdownIt</span> = <span class="built_in">require</span>(<span class="string">&#x27;markdown-it&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> md = <span class="keyword">new</span> <span class="title class_">MarkdownIt</span>(&#123;</span><br><span class="line">        <span class="attr">html</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">linkify</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">typographer</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">breaks</span>: <span class="literal">true</span></span><br><span class="line">    &#125;).<span class="title function_">use</span>(<span class="built_in">require</span>(<span class="string">&#x27;markdown-it-emoji&#x27;</span>)); <span class="comment">// 添加 Emoji 插件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并渲染参数</span></span><br><span class="line">    <span class="keyword">const</span> options = &#123; ...state.<span class="property">options</span>, <span class="attr">breaks</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> wrappedTokens = [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_open&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: <span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        ...tokens,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;paragraph_close&#x27;</span>, <span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">attrs</span>: <span class="literal">null</span>, <span class="attr">map</span>: <span class="literal">null</span>, <span class="attr">nesting</span>: -<span class="number">1</span>, <span class="attr">level</span>: <span class="number">0</span> &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染 Callout 内容</span></span><br><span class="line">    <span class="keyword">let</span> calloutBody = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        calloutBody = md.<span class="property">renderer</span>.<span class="title function_">render</span>(wrappedTokens, options, state.<span class="property">env</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Callout rendering error:&quot;</span>, error);</span><br><span class="line">        calloutBody = <span class="string">&quot;&lt;!-- Render Error --&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iconInfo = iconConfig[type] || iconConfig[<span class="string">&quot;important&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;callout callout-<span class="subst">$&#123;type&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-head&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;loadIcon(type)&#125;</span></span></span><br><span class="line"><span class="string">        &lt;span class=&quot;callout-head-text&quot; style=&quot;color:<span class="subst">$&#123;iconInfo.color&#125;</span>&quot;&gt;<span class="subst">$&#123;type.toUpperCase()&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;callout-contents&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;calloutBody&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Hexo 的 markdown-it 渲染器扩展</span></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown-it:renderer&#x27;</span>, <span class="keyword">function</span> (<span class="params">md</span>) &#123;</span><br><span class="line">    md.<span class="property">core</span>.<span class="property">ruler</span>.<span class="title function_">push</span>(<span class="string">&#x27;render_callout&#x27;</span>, <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tokens = state.<span class="property">tokens</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历 token，找到 blockquote 块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = tokens.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> token = tokens[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测到 blockquote_open 类型</span></span><br><span class="line">            <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;blockquote_open&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> blockquoteTokens = [];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 收集 blockquote 内容</span></span><br><span class="line">                <span class="keyword">while</span> (tokens[j] &amp;&amp; tokens[j].<span class="property">type</span> !== <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    blockquoteTokens.<span class="title function_">push</span>(tokens[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 确保找到了 blockquote_close</span></span><br><span class="line">                <span class="keyword">if</span> (tokens[j]?.<span class="property">type</span> === <span class="string">&#x27;blockquote_close&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> calloutType = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">const</span> calloutBodyTokens = [];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 检测 blockquote 内容中的 callout 类型</span></span><br><span class="line">                    blockquoteTokens.<span class="title function_">forEach</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (token.<span class="property">type</span> === <span class="string">&#x27;inline&#x27;</span> &amp;&amp; !calloutType) &#123;</span><br><span class="line">                            <span class="keyword">const</span> match = token.<span class="property">content</span>.<span class="title function_">match</span>(<span class="regexp">/\[!(\w+)]/</span>);</span><br><span class="line">                            <span class="keyword">if</span> (match) calloutType = match[<span class="number">1</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            calloutBodyTokens.<span class="title function_">push</span>(token);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果检测到了合法的 callout 类型</span></span><br><span class="line">                    <span class="keyword">if</span> (calloutType) &#123;</span><br><span class="line">                        <span class="keyword">const</span> calloutHtml = <span class="title function_">generateCalloutHTML</span>(calloutType, calloutBodyTokens, state);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 替换 blockquote_open 类型为 html_block</span></span><br><span class="line">                        token.<span class="property">type</span> = <span class="string">&#x27;html_block&#x27;</span>;</span><br><span class="line">                        token.<span class="property">content</span> = calloutHtml;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 删除多余的 token</span></span><br><span class="line">                        tokens.<span class="title function_">splice</span>(i + <span class="number">1</span>, j - i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><small>其实在阅读这段代码我们能够发现，这段脚本支持用户自定义自己喜欢的callout块，这是后话</small></p>
<p><small>二编：发现有<code>hexo</code>有时候会报<code>breaks</code>和<code>xhtmlOut</code>的错，最后看了一下详细的报错信息发现和这个<code>callout</code>脱不了干系，果不其然要改了😰</small></p>
<h3 id="代码放置位置"><a class="header-anchor" href="#代码放置位置">¶</a>代码放置位置</h3>
<p><strong>然后就是代码的放置位置</strong>，虽然笔者并不了解<code>hexo</code></p>
<ol>
<li class="lvl-3">
<p>总之，在你的<em>博客根目录</em><br>
<small>(虽然不知道博客根目录是否难懂，但如果跟着教程配好了博客的人一定都很聪明)</small></p>
</li>
<li class="lvl-3">
<p>新建一个<code>scripts</code>文件夹<small>当然，也可能有的大佬已经有了，<del>萌新瑟瑟发抖</del></small></p>
</li>
<li class="lvl-3">
<p>然后在该文件夹下新建文件<code>markdown-it-callout.js</code><small>当然，笔者的文件名取的是这个，但并不清楚其他名字是否可用</small></p>
</li>
<li class="lvl-3">
<p>然后把上面那段<code>callout</code>渲染代码贴进去</p>
</li>
</ol>
<h3 id="自定义css样式"><a class="header-anchor" href="#自定义css样式">¶</a>自定义css样式</h3>
<p>然后由于笔者使用的callout块是自己渲染的，需要<strong>自定义css样式</strong></p>
<p>这个部分在<a href="/posts/d9cd1415">客制化css</a>有详细介绍</p>
<h3 id="支持表情符部分"><a class="header-anchor" href="#支持表情符部分">¶</a>支持表情符部分</h3>
<h4 id="安装-markdown-it-emoji-插件"><a class="header-anchor" href="#安装-markdown-it-emoji-插件">¶</a>安装 <code>markdown-it-emoji</code> 插件</h4>
<p>使用 npm 安装 <code>markdown-it-emoji</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install markdown-it-emoji</span><br></pre></td></tr></table></figure>
<p>当然，如果不喜欢表情符的话，可以把<code>.use(require('markdown-it-emoji')</code>删除。</p>
<hr>
<p>然后！<big>然后！<big>然后！</big></big>你就获得了一个可以渲染<code>callout</code>的<code>hexo</code></p>
<h2 id="然后就是效果展示了"><a class="header-anchor" href="#然后就是效果展示了">¶</a>然后就是效果展示了</h2>
<p>其实看<a href="/posts/55009">写在前面</a>就可以了</p>
<hr>
<div style="text-align: center;color:rgba(0,0,0,0.8);"><big><big>(完)</big></big></div>
]]></content>
      <tags>
        <tag>hexo 建设</tag>
      </tags>
  </entry>
</search>
