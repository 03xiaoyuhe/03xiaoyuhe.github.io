<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link rel="stylesheet" href="/css/custom.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你好，我是黄佳，欢迎来到 LangChain 实战课！ 在默认情况下，无论是 LLM 还是代理都是无状态的，每次模型的调用都是独立于其他交互的。也就是说，我们每次通过 API 开始和大语言模型展开一次新的对话，它都不知道你其实昨天或者前天曾经和它聊过天了。 你肯定会说，不可能啊，每次和 ChatGPT 聊天的时候，ChatGPT 明明白白地记得我之前交待过的事情。  的确如此，ChatGPT 之所">
<meta property="og:type" content="article">
<meta property="og:title" content="O3xiaoyuhe">
<meta property="og:url" content="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%AE%B0%E5%BF%86%EF%BC%9A%E9%80%9A%E8%BF%87Memory%E8%AE%B0%E4%BD%8F%E5%AE%A2%E6%88%B7%E4%B8%8A%E6%AC%A1%E4%B9%B0%E8%8A%B1%E6%97%B6%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%BB%86%E8%8A%82/index.html">
<meta property="og:site_name" content="O3xiaoyuhe">
<meta property="og:description" content="你好，我是黄佳，欢迎来到 LangChain 实战课！ 在默认情况下，无论是 LLM 还是代理都是无状态的，每次模型的调用都是独立于其他交互的。也就是说，我们每次通过 API 开始和大语言模型展开一次新的对话，它都不知道你其实昨天或者前天曾经和它聊过天了。 你肯定会说，不可能啊，每次和 ChatGPT 聊天的时候，ChatGPT 明明白白地记得我之前交待过的事情。  的确如此，ChatGPT 之所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c9/97/c9907bc695521228cdfb5d3f75c13897.png?wh=588x593">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/e2/de/e26993dd3957bfd2947424abb9de7cde.png?wh=1965x1363">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c1/7c/c11b24c318dbd762f13781e3e40f9b7c.png?wh=1592x1066">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/a0/c0/a06b5db35405b74yy317de917eacbdc0.jpg?wh=1660x640">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c5/ea/c56yyd7eb61637687de448512yy426ea.png?wh=3676x1478">
<meta property="article:published_time" content="2024-12-08T12:29:01.365Z">
<meta property="article:modified_time" content="2024-11-18T11:23:24.399Z">
<meta property="article:author" content="听">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/c9/97/c9907bc695521228cdfb5d3f75c13897.png?wh=588x593">

<link rel="canonical" href="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%AE%B0%E5%BF%86%EF%BC%9A%E9%80%9A%E8%BF%87Memory%E8%AE%B0%E4%BD%8F%E5%AE%A2%E6%88%B7%E4%B8%8A%E6%AC%A1%E4%B9%B0%E8%8A%B1%E6%97%B6%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%BB%86%E8%8A%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | O3xiaoyuhe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">O3xiaoyuhe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%AE%B0%E5%BF%86%EF%BC%9A%E9%80%9A%E8%BF%87Memory%E8%AE%B0%E4%BD%8F%E5%AE%A2%E6%88%B7%E4%B8%8A%E6%AC%A1%E4%B9%B0%E8%8A%B1%E6%97%B6%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%BB%86%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:01" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:01+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-18 19:23:24" itemprop="dateModified" datetime="2024-11-18T19:23:24+08:00">2024-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>你好，我是黄佳，欢迎来到 LangChain 实战课！</p>
<p>在默认情况下，无论是 LLM 还是代理都是无状态的，每次模型的调用都是独立于其他交互的。也就是说，我们每次通过 API 开始和大语言模型展开一次新的对话，它都不知道你其实昨天或者前天曾经和它聊过天了。</p>
<p>你肯定会说，不可能啊，每次和 ChatGPT 聊天的时候，ChatGPT 明明白白地记得我之前交待过的事情。</p>
<p><img src="https://static001.geekbang.org/resource/image/c9/97/c9907bc695521228cdfb5d3f75c13897.png?wh=588x593" alt=""></p>
<p>的确如此，ChatGPT 之所以能够记得你之前说过的话，正是因为它使用了<strong>记忆（Memory）机制</strong>，记录了之前的对话上下文，并且把这个上下文作为提示的一部分，在最新的调用中传递给了模型。在聊天机器人的构建中，记忆机制非常重要。</p>
<p><img src="https://static001.geekbang.org/resource/image/e2/de/e26993dd3957bfd2947424abb9de7cde.png?wh=1965x1363" alt=""></p>
<h2 id="使用-ConversationChain">使用 ConversationChain</h2>
<p>不过，在开始介绍 LangChain 中记忆机制的具体实现之前，先重新看一下我们上一节课曾经见过的 ConversationChain。</p>
<p>这个 Chain 最主要的特点是，它提供了包含 AI 前缀和人类前缀的对话摘要格式，这个对话格式和记忆机制结合得非常紧密。</p>
<p>让我们看一个简单的示例，并打印出 ConversationChain 中的内置提示模板，你就会明白这个对话格式的意义了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from langchain import OpenAI</span><br><span class="line">from langchain.chains import ConversationChain</span><br><span class="line"></span><br><span class="line"># 初始化大语言模型</span><br><span class="line">llm = OpenAI(</span><br><span class="line">    temperature=0.5,</span><br><span class="line">    model_name=&quot;gpt-3.5-turbo-instruct&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 初始化对话链</span><br><span class="line">conv_chain = ConversationChain(llm=llm)</span><br><span class="line"></span><br><span class="line"># 打印对话的模板</span><br><span class="line">print(conv_chain.prompt.template)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.</span><br><span class="line"></span><br><span class="line">Current conversation:</span><br><span class="line">&#123;history&#125;</span><br><span class="line">Human: &#123;input&#125;</span><br><span class="line">AI:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的提示为人类（我们）和人工智能（text-davinci-003）之间的对话设置了一个基本对话框架：这是<strong>人类和</strong> <strong>AI</strong> <strong>之间的友好对话。AI</strong> <strong>非常健谈并从其上下文中提供了大量的具体细节。</strong> (The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context.)</p>
<p>同时，这个提示试图通过说明以下内容来减少幻觉，也就是尽量减少模型编造的信息：</p>
<p><strong>“如果</strong> <strong>AI</strong> <strong>不知道问题的答案，它就会如实说它不知道。”</strong>（If the AI does not know the answer to a question, it truthfully says it does not know.）</p>
<p>之后，我们看到两个参数 {history} 和 {input}。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>{history}</strong> 是存储会话记忆的地方，也就是人类和人工智能之间对话历史的信息。</p>
</li>
<li class="lvl-4">
<p><strong>{input}</strong> 是新输入的地方，你可以把它看成是和 ChatGPT 对话时，文本框中的输入。</p>
</li>
</ul>
<p>这两个参数会通过提示模板传递给 LLM，我们希望返回的输出只是对话的延续。</p>
<p><img src="https://static001.geekbang.org/resource/image/c1/7c/c11b24c318dbd762f13781e3e40f9b7c.png?wh=1592x1066" alt=""></p>
<p><strong>那么当有了</strong> <strong>{history}</strong> <strong>参数，以及</strong> <strong>Human</strong> <strong>和</strong> <strong>AI</strong> <strong>这两个前缀，我们就能够把历史对话信息存储在提示模板中，并作为新的提示内容在新一轮的对话过程中传递给模型。—— 这就是记忆机制的原理</strong>。</p>
<p>下面就让我们来在 ConversationChain 中加入记忆功能。</p>
<h2 id="使用-ConversationBufferMemory">使用 ConversationBufferMemory</h2>
<p>在 LangChain 中，通过 ConversationBufferMemory（<strong>缓冲记忆</strong>）可以实现最简单的记忆机制。</p>
<p>下面，我们就在对话链中引入 ConversationBufferMemory。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from langchain import OpenAI</span><br><span class="line">from langchain.chains import ConversationChain</span><br><span class="line">from langchain.chains.conversation.memory import ConversationBufferMemory</span><br><span class="line"></span><br><span class="line"># 初始化大语言模型</span><br><span class="line">llm = OpenAI(</span><br><span class="line">    temperature=0.5,</span><br><span class="line">    model_name=&quot;gpt-3.5-turbo-instruct&quot;)</span><br><span class="line"></span><br><span class="line"># 初始化对话链</span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationBufferMemory()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 第一天的对话</span><br><span class="line"># 回合1</span><br><span class="line">conversation(&quot;我姐姐明天要过生日，我需要一束生日花束。&quot;)</span><br><span class="line">print(&quot;第一次对话后的记忆:&quot;, conversation.memory.buffer)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次对话后的记忆: </span><br><span class="line">Human: 我姐姐明天要过生日，我需要一束生日花束。</span><br><span class="line">AI:  哦，你姐姐明天要过生日，那太棒了！我可以帮你推荐一些生日花束，你想要什么样的？我知道有很多种，比如玫瑰、康乃馨、郁金香等等。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下一轮对话中，这些记忆会作为一部分传入提示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 回合2</span><br><span class="line">conversation(&quot;她喜欢粉色玫瑰，颜色是粉色的。&quot;)</span><br><span class="line">print(&quot;第二次对话后的记忆:&quot;, conversation.memory.buffer)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二次对话后的记忆: </span><br><span class="line">Human: 我姐姐明天要过生日，我需要一束生日花束。</span><br><span class="line">AI:  哦，你姐姐明天要过生日，那太棒了！我可以帮你推荐一些生日花束，你想要什么样的？我知道有很多种，比如玫瑰、康乃馨、郁金香等等。</span><br><span class="line">Human: 她喜欢粉色玫瑰，颜色是粉色的。</span><br><span class="line">AI:  好的，那我可以推荐一束粉色玫瑰的生日花束给你。你想要多少朵？我可以帮你定制一束，比如说十朵、二十朵或者更多？</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面，我们继续对话，同时打印出此时提示模板的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 回合3 （第二天的对话）</span><br><span class="line">conversation(&quot;我又来了，还记得我昨天为什么要来买花吗？&quot;)</span><br><span class="line">print(&quot;/n第三次对话后时提示:/n&quot;,conversation.prompt.template)</span><br><span class="line">print(&quot;/n第三次对话后的记忆:/n&quot;, conversation.memory.buffer)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模型输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Human: 我姐姐明天要过生日，我需要一束生日花束。</span><br><span class="line">AI:  哦，你姐姐明天要过生日，那太棒了！我可以帮你推荐一些生日花束，你想要什么样的？我知道有很多种，比如玫瑰、康乃馨、郁金香等等。</span><br><span class="line">Human: 她喜欢粉色玫瑰，颜色是粉色的。</span><br><span class="line">AI:  好的，那我可以推荐一束粉色玫瑰的生日花束给你，你想要多少朵？</span><br><span class="line">Human: 我又来了，还记得我昨天为什么要来买花吗？</span><br><span class="line">AI:  是的，我记得你昨天来买花是因为你姐姐明天要过生日，你想要买一束粉色玫瑰的生日花束给她。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上，这些聊天历史信息，都被传入了 ConversationChain 的提示模板中的 {history} 参数，构建出了包含聊天记录的新的提示输入。</p>
<p>有了记忆机制，LLM 能够了解之前的对话内容，这样简单直接地存储所有内容为 LLM 提供了最大量的信息，但是新输入中也包含了更多的 Token（所有的聊天历史记录），这意味着响应时间变慢和更高的成本。而且，当达到 LLM 的令牌数（上下文窗口）限制时，太长的对话无法被记住（对于 text-davinci-003 和 gpt-3.5-turbo，每次的最大输入限制是 4096 个 Token）。</p>
<p>下面我们来看看针对 Token 太多、聊天历史记录过长的一些解决方案。</p>
<h2 id="使用-ConversationBufferWindowMemory">使用 ConversationBufferWindowMemory</h2>
<p>说到记忆，我们人类的大脑也不是无穷无尽的。所以说，有的时候事情太多，我们只能把有些遥远的记忆抹掉。毕竟，最新的经历最鲜活，也最重要。</p>
<p>ConversationBufferWindowMemory 是<strong>缓冲窗口记忆</strong>，它的思路就是只保存最新最近的几次人类和 AI 的互动。因此，它在之前的 “缓冲记忆” 基础上增加了一个窗口值 k。这意味着我们只保留一定数量的过去互动，然后 “忘记” 之前的互动。</p>
<p>下面看一下示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from langchain import OpenAI</span><br><span class="line">from langchain.chains import ConversationChain</span><br><span class="line">from langchain.chains.conversation.memory import ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line"># 创建大语言模型实例</span><br><span class="line">llm = OpenAI(</span><br><span class="line">    temperature=0.5,</span><br><span class="line">    model_name=&quot;gpt-3.5-turbo-instruct&quot;)</span><br><span class="line"></span><br><span class="line"># 初始化对话链</span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationBufferWindowMemory(k=1)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 第一天的对话</span><br><span class="line"># 回合1</span><br><span class="line">result = conversation(&quot;我姐姐明天要过生日，我需要一束生日花束。&quot;)</span><br><span class="line">print(result)</span><br><span class="line"># 回合2</span><br><span class="line">result = conversation(&quot;她喜欢粉色玫瑰，颜色是粉色的。&quot;)</span><br><span class="line"># print(&quot;\n第二次对话后的记忆:\n&quot;, conversation.memory.buffer)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"># 第二天的对话</span><br><span class="line"># 回合3</span><br><span class="line">result = conversation(&quot;我又来了，还记得我昨天为什么要来买花吗？&quot;)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我姐姐明天要过生日，我需要一束生日花束。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;&#x27;,</span><br><span class="line"> &#x27;response&#x27;: &#x27; 哦，你姐姐明天要过生日！那太棒了！你想要一束什么样的花束呢？有很多种类可以选择，比如玫瑰花束、康乃馨花束、郁金香花束等等，你有什么喜欢的吗？&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;她喜欢粉色玫瑰，颜色是粉色的。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;Human: 我姐姐明天要过生日，我需要一束生日花束。\nAI:  哦，你姐姐明天要过生日！那太棒了！你想要一束什么样的花束呢？有很多种类可以选择，比如玫瑰花束、康乃馨花束、郁金香花束等等，你有什么喜欢的吗？&#x27;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 好的，那粉色玫瑰花束怎么样？我可以帮你找到一束非常漂亮的粉色玫瑰花束，你觉得怎么样？&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我又来了，还记得我昨天为什么要来买花吗？&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;Human: 她喜欢粉色玫瑰，颜色是粉色的。\nAI:  好的，那粉色玫瑰花束怎么样？我可以帮你找到一束非常漂亮的粉色玫瑰花束，你觉得怎么样？&#x27;, </span><br><span class="line">&#x27;response&#x27;: &#x27;  当然记得，你昨天来买花是为了给你喜欢的人送一束粉色玫瑰花束，表达你对TA的爱意。&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在给定的例子中，设置 k=1，这意味着窗口只会记住与 AI 之间的最新的互动，即只保留上一次的人类回应和 AI 的回应。</p>
<p>在第三个回合，当我们询问 “还记得我昨天为什么要来买花吗？”，由于我们只保留了最近的互动（k=1），模型已经忘记了正确的答案。所以，虽然它说记得，但只能模糊地说出 “喜欢的人”，而没有说关键字 “姐姐”。不过，如果（我是说如果哈）在第二个回合，模型能回答 “我可以帮你<strong>为你姐姐</strong>找到…”，那么，尽管我们没有第一回合的历史记录，但凭着上一个回合的信息，模型还是有可能推断出昨天来的人买花的真实意图。</p>
<p>尽管这种方法不适合记住遥远的互动，但它非常擅长限制使用的 Token 数量。如果只需要记住最近的互动，缓冲窗口记忆是一个很好的选择。但是，如果需要混合远期和近期的互动信息，则还有其他选择。</p>
<h2 id="使用-ConversationSummaryMemory">使用 ConversationSummaryMemory</h2>
<p>上面说了，如果模型在第二轮回答的时候，能够说出 “我可以帮你为你姐姐找到…”，那么在第三轮回答时，即使窗口大小 k=1，还是能够回答出正确答案。</p>
<p>这是为什么？</p>
<p>因为模型<strong>在回答新问题的时候，对之前的问题进行了总结性的重述</strong>。</p>
<p>ConversationSummaryMemory（<strong>对话总结记忆</strong>）的思路就是将对话历史进行汇总，然后再传递给 {history} 参数。这种方法旨在通过对之前的对话进行汇总来避免过度使用 Token。</p>
<p>ConversationSummaryMemory 有这么几个核心特点。</p>
<ol>
<li class="lvl-4">
<p>汇总对话：此方法不是保存整个对话历史，而是每次新的互动发生时对其进行汇总，然后将其添加到之前所有互动的 “运行汇总” 中。</p>
</li>
<li class="lvl-4">
<p>使用 LLM 进行汇总：该汇总功能由另一个 LLM 驱动，这意味着对话的汇总实际上是由 AI 自己进行的。</p>
</li>
<li class="lvl-4">
<p>适合长对话：对于长对话，此方法的优势尤为明显。虽然最初使用的 Token 数量较多，但随着对话的进展，汇总方法的增长速度会减慢。与此同时，常规的缓冲内存模型会继续线性增长。</p>
</li>
</ol>
<p>下面，我们来看看使用 ConversationSummaryMemory 的代码示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from langchain.chains.conversation.memory import ConversationSummaryMemory</span><br><span class="line"></span><br><span class="line"># 初始化对话链</span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationSummaryMemory(llm=llm)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我姐姐明天要过生日，我需要一束生日花束。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;&#x27;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 我明白，你需要一束生日花束。我可以为你提供一些建议吗？我可以推荐一些花束给你，比如玫瑰，康乃馨，百合，仙客来，郁金香，满天星等等。挑选一束最适合你姐姐的生日花束吧！&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;她喜欢粉色玫瑰，颜色是粉色的。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &quot;\nThe human asked what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential. The human then asked the AI for advice on what type of flower bouquet to get for their sister&#x27;s birthday, to which the AI provided a variety of suggestions.&quot;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 为了为你的姐姐的生日准备一束花，我建议你搭配粉色玫瑰和白色康乃馨。你可以在玫瑰花束中添加一些紫色的满天星，或者添加一些绿叶以增加颜色对比。这将是一束可爱的花束，让你姐姐的生日更加特别。&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我又来了，还记得我昨天为什么要来买花吗？&#x27;, </span><br><span class="line">&#x27;history&#x27;: &quot;\n\nThe human asked what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential. The human then asked the AI for advice on what type of flower bouquet to get for their sister&#x27;s birthday, to which the AI suggested pink roses and white carnations with the addition of purple aster flowers and green leaves for contrast. This would make a lovely bouquet to make the sister&#x27;s birthday extra special.&quot;,</span><br><span class="line">&#x27;response&#x27;: &#x27; 确实，我记得你昨天想买一束花给你的姐姐作为生日礼物。我建议你买粉红色的玫瑰花和白色的康乃馨花，再加上紫色的雏菊花和绿叶，这样可以让你的姐姐的生日更加特别。&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看得出来，这里的 <code>'history'</code>，不再是之前人类和 AI 对话的简单复制粘贴，而是经过了总结和整理之后的一个综述信息。</p>
<p>这里，我们<strong>不仅仅利用了 LLM 来回答每轮问题，还利用 LLM 来对之前的对话进行总结性的陈述，以节约 Token 数量</strong>。这里，帮我们总结对话的 LLM，和用来回答问题的 LLM，可以是同一个大模型，也可以是不同的大模型。</p>
<p>ConversationSummaryMemory 的优点是对于长对话，可以减少使用的 Token 数量，因此可以记录更多轮的对话信息，使用起来也直观易懂。不过，它的缺点是，对于较短的对话，可能会导致更高的 Token 使用。另外，对话历史的记忆完全依赖于中间汇总 LLM 的能力，还需要为汇总 LLM 使用 Token，这增加了成本，且并不限制对话长度。</p>
<p>通过对话历史的汇总来优化和管理 Token 的使用，ConversationSummaryMemory 为那些预期会有多轮的、长时间对话的场景提供了一种很好的方法。然而，这种方法仍然受到 Token 数量的限制。在一段时间后，我们仍然会超过大模型的上下文窗口限制。</p>
<p>而且，总结的过程中并没有区分近期的对话和长期的对话（通常情况下近期的对话更重要），所以我们还要继续寻找新的记忆管理方法。</p>
<h2 id="使用-ConversationSummaryBufferMemory">使用 ConversationSummaryBufferMemory</h2>
<p>我要为你介绍的最后一种记忆机制是 ConversationSummaryBufferMemory，即<strong>对话总结缓冲记忆</strong>，它是一种<strong>混合记忆</strong>模型，结合了上述各种记忆机制，包括 ConversationSummaryMemory 和 ConversationBufferWindowMemory 的特点。这种模型旨在在对话中总结早期的互动，同时尽量保留最近互动中的原始内容。</p>
<p>它是通过 max_token_limit 这个参数做到这一点的。当最新的对话文字长度在 300 字之内的时候，LangChain 会记忆原始对话内容；当对话文字超出了这个参数的长度，那么模型就会把所有超过预设长度的内容进行总结，以节省 Token 数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from langchain.chains.conversation.memory import ConversationSummaryBufferMemory</span><br><span class="line"></span><br><span class="line"># 初始化对话链</span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationSummaryBufferMemory(</span><br><span class="line">        llm=llm,</span><br><span class="line">        max_token_limit=300))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我姐姐明天要过生日，我需要一束生日花束。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;&#x27;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 哇，你姐姐要过生日啊！那太棒了！我建议你去买一束色彩鲜艳的花束，因为这样可以代表你给她的祝福和祝愿。你可以去你家附近的花店，或者也可以从网上订购，你可以看看有没有特别的花束，比如彩色玫瑰或者百合花，它们会更有特色。&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;她喜欢粉色玫瑰，颜色是粉色的。&#x27;, </span><br><span class="line">&#x27;history&#x27;: &#x27;Human: 我姐姐明天要过生日，我需要一束生日花束。\nAI:  哇，你姐姐要过生日啊！那太棒了！我建议你去买一束色彩鲜艳的花束，因为这样可以代表你给她的祝福和祝愿。你可以去你家附近的花店，或者也可以从网上订购，你可以看看有没有特别的花束，比如彩色玫瑰或者百合花，它们会更有特色。&#x27;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 好的，那粉色玫瑰就是一个很好的选择！你可以买一束粉色玫瑰花束，这样你姐姐会很开心的！你可以在花店里找到粉色玫瑰，也可以从网上订购，你可以根据你的预算，选择合适的数量。另外，你可以考虑添加一些装饰，比如细绳、彩带或者小礼品&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三回合的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;input&#x27;: &#x27;我又来了，还记得我昨天为什么要来买花吗？&#x27;, </span><br><span class="line">&#x27;history&#x27;: &quot;System: \nThe human asked the AI for advice on buying a bouquet for their sister&#x27;s birthday. The AI suggested buying a vibrant bouquet as a representation of their wishes and blessings, and recommended looking for special bouquets like colorful roses or lilies for something more unique.\nHuman: 她喜欢粉色玫瑰，颜色是粉色的。\nAI:  好的，那粉色玫瑰就是一个很好的选择！你可以买一束粉色玫瑰花束，这样你姐姐会很开心的！你可以在花店里找到粉色玫瑰，也可以从网上订购，你可以根据你的预算，选择合适的数量。另外，你可以考虑添加一些装饰，比如细绳、彩带或者小礼品&quot;, </span><br><span class="line">&#x27;response&#x27;: &#x27; 是的，我记得你昨天来买花是为了给你姐姐的生日。你想买一束粉色玫瑰花束来表达你的祝福和祝愿，你可以在花店里找到粉色玫瑰，也可以从网上订购，你可以根据你的预算，选择合适的数量。另外，你可以考虑添加一些装饰，比如细绳、彩带或者小礼品&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不难看出，在第二回合，记忆机制完整地记录了第一回合的对话，但是在第三回合，它察觉出前两轮的对话已经超出了 300 个字节，就把早期的对话加以总结，以节省 Token 资源。</p>
<p>ConversationSummaryBufferMemory 的优势是通过总结可以回忆起较早的互动，而且有缓冲区确保我们不会错过最近的互动信息。当然，对于较短的对话，ConversationSummaryBufferMemory 也会增加 Token 数量。</p>
<p>总体来说，ConversationSummaryBufferMemory 为我们提供了大量的灵活性。它是我们迄今为止的唯一记忆类型，可以回忆起较早的互动并完整地存储最近的互动。在节省 Token 数量方面，ConversationSummaryBufferMemory 与其他方法相比，也具有竞争力。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>好的，今天我给你介绍了一种对话链和四种类型的对话记忆机制，那么我们可以通过一个表格对这四种类型的记忆做一个整体比较。</p>
<p>四种记忆机制的比较如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/a0/c0/a06b5db35405b74yy317de917eacbdc0.jpg?wh=1660x640" alt=""></p>
<p>网上还有人总结了一个示意图，体现出了当对话轮次逐渐增加时，各种记忆机制对 Token 的消耗数量。意图向我们表达的是：有些记忆机制，比如说 ConversationSummaryBufferMemory 和 ConversationSummaryMemory，在对话轮次较少的时候可能会浪费一些 Token，但是多轮对话过后，Token 的节省就逐渐体现出来了。</p>
<p>当然 ConversationBufferWindowMemory 对于 Token 的节省最为直接，但是它会完全遗忘掉 K 轮之前的对话内容，因此对于某些场景也不是最佳选择。</p>
<p><img src="https://static001.geekbang.org/resource/image/c5/ea/c56yyd7eb61637687de448512yy426ea.png?wh=3676x1478" alt=""></p>
<h2 id="思考题">思考题</h2>
<ol>
<li class="lvl-4">
<p>在你的客服聊天机器人设计中，你会首先告知客户：“亲，我的记忆能力有限，只能记住和你的最近 10 次对话哦。如果我忘了之前的对话，请你体谅我。” 当有了这样的预设，你会为你的 ChatBot 选择那种记忆机制？</p>
</li>
<li class="lvl-4">
<p>尝试改变示例程序 ConversationBufferWindowMemory 中的 k 值，并增加对话轮次，看看记忆效果。</p>
</li>
<li class="lvl-4">
<p>尝试改变示例程序 ConversationSummaryBufferMemory 中的 max_token_limit 值，看看记忆效果。</p>
</li>
</ol>
<p>期待在留言区看到你的分享。如果你觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p>
<h2 id="延伸阅读">延伸阅读</h2>
<ol>
<li class="lvl-4">
<p>代码，ConversationBufferMemory 的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flangchain-ai%2Flangchain%2Fblob%2Fmaster%2Flibs%2Flangchain%2Flangchain%2Fmemory%2Fbuffer.py" title="https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/memory/buffer.py">实现细节</a></p>
</li>
<li class="lvl-4">
<p>代码，ConversationSummaryMemory 的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flangchain-ai%2Flangchain%2Fblob%2Fmaster%2Flibs%2Flangchain%2Flangchain%2Fmemory%2Fsummary.py" title="https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/memory/summary.py">实现细节</a></p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%BD%BF%E7%94%A8OpenAI%20API%E8%BF%98%E6%98%AF%E5%BE%AE%E8%B0%83%E5%BC%80%E6%BA%90Llama2%E3%80%81ChatGLM%EF%BC%9F/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8E%E2%80%9C%E6%98%93%E9%80%9F%E9%B2%9C%E8%8A%B1%E2%80%9D%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93%E7%9A%84%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConversationChain"><span class="nav-number">1.</span> <span class="nav-text">使用 ConversationChain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConversationBufferMemory"><span class="nav-number">2.</span> <span class="nav-text">使用 ConversationBufferMemory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConversationBufferWindowMemory"><span class="nav-number">3.</span> <span class="nav-text">使用 ConversationBufferWindowMemory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConversationSummaryMemory"><span class="nav-number">4.</span> <span class="nav-text">使用 ConversationSummaryMemory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConversationSummaryBufferMemory"><span class="nav-number">5.</span> <span class="nav-text">使用 ConversationSummaryBufferMemory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E6%97%B6%E5%88%BB"><span class="nav-number">6.</span> <span class="nav-text">总结时刻</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="nav-number">8.</span> <span class="nav-text">延伸阅读</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">听</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">653</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">听</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
