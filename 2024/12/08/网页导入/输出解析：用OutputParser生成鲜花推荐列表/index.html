<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link rel="stylesheet" href="/css/custom.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你好，我是黄佳，欢迎来到 LangChain 实战课！ 首先请你回忆一下第 5 课中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个 CSV 文件中。为了实现这个目标，程序调用了 OpenAI 模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。 今天我要带着你深入研究一下 LangChain 中的输出解析器，并用一个新的解析器——Pydantic 解析器来重">
<meta property="og:type" content="article">
<meta property="og:title" content="O3xiaoyuhe">
<meta property="og:url" content="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%94%A8OutputParser%E7%94%9F%E6%88%90%E9%B2%9C%E8%8A%B1%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/index.html">
<meta property="og:site_name" content="O3xiaoyuhe">
<meta property="og:description" content="你好，我是黄佳，欢迎来到 LangChain 实战课！ 首先请你回忆一下第 5 课中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个 CSV 文件中。为了实现这个目标，程序调用了 OpenAI 模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。 今天我要带着你深入研究一下 LangChain 中的输出解析器，并用一个新的解析器——Pydantic 解析器来重">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85c52269a79349ccbf6c82d47257f77e~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp#?w=4000&amp;h=1536&amp;s=328739&amp;e=jpg&amp;b=eefcf1">
<meta property="article:published_time" content="2024-12-08T12:29:01.365Z">
<meta property="article:modified_time" content="2024-11-18T11:08:28.759Z">
<meta property="article:author" content="听">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85c52269a79349ccbf6c82d47257f77e~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp#?w=4000&amp;h=1536&amp;s=328739&amp;e=jpg&amp;b=eefcf1">

<link rel="canonical" href="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%94%A8OutputParser%E7%94%9F%E6%88%90%E9%B2%9C%E8%8A%B1%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | O3xiaoyuhe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">O3xiaoyuhe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%94%A8OutputParser%E7%94%9F%E6%88%90%E9%B2%9C%E8%8A%B1%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="听">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="O3xiaoyuhe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-08 20:29:01" itemprop="dateCreated datePublished" datetime="2024-12-08T20:29:01+08:00">2024-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-18 19:08:28" itemprop="dateModified" datetime="2024-11-18T19:08:28+08:00">2024-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>你好，我是黄佳，欢迎来到 LangChain 实战课！</p>
<p>首先请你回忆一下<a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304/section/7388069971579895818" title="https://juejin.cn/book/7387702347436130304/section/7388069971579895818">第 5 课</a>中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个 CSV 文件中。为了实现这个目标，程序调用了 OpenAI 模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。</p>
<p>今天我要带着你深入研究一下 LangChain 中的输出解析器，并用一个新的解析器——Pydantic 解析器来重构第 5 课中的程序。这节课也是模型 I/O 框架的最后一讲。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85c52269a79349ccbf6c82d47257f77e~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp#?w=4000&amp;h=1536&amp;s=328739&amp;e=jpg&amp;b=eefcf1" alt=""></p>
<p>下面先来看看 LangChain 中的输出解析器究竟是什么，有哪些种类。</p>
<h2 id="LangChain-中的输出解析器">LangChain 中的输出解析器</h2>
<p>语言模型输出的是文本，这是给人类阅读的。但很多时候，你可能想要获得的是程序能够处理的结构化信息。这就是输出解析器发挥作用的地方。</p>
<p>输出解析器是<strong>一种专用于处理和构建语言模型响应的类</strong>。一个基本的输出解析器类通常需要实现两个核心方法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>get_format_instructions：这个方法需要返回一个字符串，用于指导如何格式化语言模型的输出，告诉它应该如何组织并构建它的回答。</p>
</li>
<li class="lvl-4">
<p>parse：这个方法接收一个字符串（也就是语言模型的输出）并将其解析为特定的数据结构或格式。这一步通常用于确保模型的输出符合我们的预期，并且能够以我们需要的形式进行后续处理。</p>
</li>
</ul>
<p>还有一个可选的方法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>parse_with_prompt：这个方法接收一个字符串（也就是语言模型的输出）和一个提示（用于生成这个输出的提示），并将其解析为特定的数据结构。这样，你可以根据原始提示来修正或重新解析模型的输出，确保输出的信息更加准确和贴合要求。</p>
</li>
</ul>
<p>下面是一个基于上述描述的简单伪代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class OutputParser:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def get_format_instructions(self):</span><br><span class="line">        # 返回一个字符串，指导如何格式化模型的输出</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse(self, model_output):</span><br><span class="line">        # 解析模型的输出，转换为某种数据结构或格式</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse_with_prompt(self, model_output, prompt):</span><br><span class="line">        # 基于原始提示解析模型的输出，转换为某种数据结构或格式</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 LangChain 中，通过实现 get_format_instructions、parse 和 parse_with_prompt 这些方法，针对不同的使用场景和目标，设计了各种输出解析器。让我们来逐一认识一下。</p>
<ol>
<li class="lvl-4">
<p>列表解析器（List Parser）：这个解析器用于处理模型生成的输出，当需要模型的输出是一个列表的时候使用。例如，如果你询问模型 “列出所有鲜花的库存”，模型的回答应该是一个列表。</p>
</li>
<li class="lvl-4">
<p>日期时间解析器（Datetime Parser）：这个解析器用于处理日期和时间相关的输出，确保模型的输出是正确的日期或时间格式。</p>
</li>
<li class="lvl-4">
<p>枚举解析器（Enum Parser）：这个解析器用于处理预定义的一组值，当模型的输出应该是这组预定义值之一时使用。例如，如果你定义了一个问题的答案只能是 “是” 或“否”，那么枚举解析器可以确保模型的回答是这两个选项之一。</p>
</li>
<li class="lvl-4">
<p>结构化输出解析器（Structured Output Parser）：这个解析器用于处理复杂的、结构化的输出。如果你的应用需要模型生成具有特定结构的复杂回答（例如一份报告、一篇文章等），那么可以使用结构化输出解析器来实现。</p>
</li>
<li class="lvl-4">
<p>Pydantic（JSON）解析器：这个解析器用于处理模型的输出，当模型的输出应该是一个符合特定格式的 JSON 对象时使用。它使用 Pydantic 库，这是一个数据验证库，可以用于构建复杂的数据模型，并确保模型的输出符合预期的数据模型。</p>
</li>
<li class="lvl-4">
<p>自动修复解析器（Auto-Fixing Parser）：这个解析器可以自动修复某些常见的模型输出错误。例如，如果模型的输出应该是一段文本，但是模型返回了一段包含语法或拼写错误的文本，自动修复解析器可以自动纠正这些错误。</p>
</li>
<li class="lvl-4">
<p>重试解析器（RetryWithErrorOutputParser）：这个解析器用于在模型的初次输出不符合预期时，尝试修复或重新生成新的输出。例如，如果模型的输出应该是一个日期，但是模型返回了一个字符串，那么重试解析器可以重新提示模型生成正确的日期格式。</p>
</li>
</ol>
<p>上面的各种解析器中，前三种很容易理解，而结构化输出解析器你已经用过了。所以接下来我们重点讲一讲 Pydantic（JSON）解析器、自动修复解析器和重试解析器。</p>
<h2 id="Pydantic（JSON）解析器实战">Pydantic（JSON）解析器实战</h2>
<p>Pydantic (JSON) 解析器应该是最常用也是最重要的解析器，我带着你用它来重构鲜花文案生成程序。</p>
<p>Pydantic 是一个 Python 数据验证和设置管理库，主要基于 Python 类型提示。尽管它不是专为 JSON 设计的，但由于 JSON 是现代 Web 应用和 API 交互中的常见数据格式，Pydantic 在处理和验证 JSON 数据时特别有用。</p>
<h3 id="第一步：创建模型实例">第一步：创建模型实例</h3>
<p>先通过环境变量设置 OpenAI API 密钥，然后使用 LangChain 库创建了一个 OpenAI 的模型实例。这里我们仍然选择了 text-davinci-003 作为大语言模型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ------Part 1</span><br><span class="line"># 设置OpenAI API密钥</span><br><span class="line">import os</span><br><span class="line">os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span><br><span class="line"></span><br><span class="line"># 创建模型实例</span><br><span class="line">from langchain import OpenAI</span><br><span class="line">model = OpenAI(model_name=&#x27;gpt-3.5-turbo-instruct&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二步：定义输出数据的格式">第二步：定义输出数据的格式</h3>
<p>先创建了一个空的 DataFrame，用于存储从模型生成的描述。接下来，通过一个名为 FlowerDescription 的 Pydantic BaseModel 类，定义了期望的数据格式（也就是数据的结构）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ------Part 2</span><br><span class="line"># 创建一个空的DataFrame用于存储结果</span><br><span class="line">import pandas as pd</span><br><span class="line">df = pd.DataFrame(columns=[&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;])</span><br><span class="line"></span><br><span class="line"># 数据准备</span><br><span class="line">flowers = [&quot;玫瑰&quot;, &quot;百合&quot;, &quot;康乃馨&quot;]</span><br><span class="line">prices = [&quot;50&quot;, &quot;30&quot;, &quot;20&quot;]</span><br><span class="line"></span><br><span class="line"># 定义我们想要接收的数据格式</span><br><span class="line">from pydantic import BaseModel, Field</span><br><span class="line">class FlowerDescription(BaseModel):</span><br><span class="line">    flower_type: str = Field(description=&quot;鲜花的种类&quot;)</span><br><span class="line">    price: int = Field(description=&quot;鲜花的价格&quot;)</span><br><span class="line">    description: str = Field(description=&quot;鲜花的描述文案&quot;)</span><br><span class="line">    reason: str = Field(description=&quot;为什么要这样写这个文案&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们用到了负责数据格式验证的 Pydantic 库来创建带有类型注解的类 FlowerDescription，它可以自动验证输入数据，确保输入数据符合你指定的类型和其他验证条件。</p>
<p>Pydantic 有这样几个特点。</p>
<ol>
<li class="lvl-4">
<p>数据验证：当你向 Pydantic 类赋值时，它会自动进行数据验证。例如，如果你创建了一个字段需要是整数，但试图向它赋予一个字符串，Pydantic 会引发异常。</p>
</li>
<li class="lvl-4">
<p>数据转换：Pydantic 不仅进行数据验证，还可以进行数据转换。例如，如果你有一个需要整数的字段，但你提供了一个可以转换为整数的字符串，如 <code>&quot;42&quot;</code>，Pydantic 会自动将这个字符串转换为整数 42。</p>
</li>
<li class="lvl-4">
<p>易于使用：创建一个 Pydantic 类就像定义一个普通的 Python 类一样简单。只需要使用 Python 的类型注解功能，即可在类定义中指定每个字段的类型。</p>
</li>
<li class="lvl-4">
<p>JSON 支持：Pydantic 类可以很容易地从 JSON 数据创建，并可以将类的数据转换为 JSON 格式。</p>
</li>
</ol>
<p>下面，我们基于这个 Pydantic 数据格式类来创建 LangChain 的输出解析器。</p>
<h3 id="第三步：创建输出解析器">第三步：创建输出解析器</h3>
<p>在这一步中，我们创建输出解析器并获取输出格式指示。先使用 LangChain 库中的 PydanticOutputParser 创建了输出解析器，该解析器将用于解析模型的输出，以确保其符合 FlowerDescription 的格式。然后，使用解析器的 get_format_instructions 方法获取了输出格式的指示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ------Part 3</span><br><span class="line"># 创建输出解析器</span><br><span class="line">from langchain.output_parsers import PydanticOutputParser</span><br><span class="line">output_parser = PydanticOutputParser(pydantic_object=FlowerDescription)</span><br><span class="line"></span><br><span class="line"># 获取输出格式指示</span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"># 打印提示</span><br><span class="line">print(&quot;输出格式：&quot;,format_instructions)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出格式： The output should be formatted as a JSON instance that conforms to the JSON schema below.</span><br><span class="line"></span><br><span class="line">As an example, for the schema &#123;&quot;properties&quot;: &#123;&quot;foo&quot;: &#123;&quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;a list of strings&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123;&quot;type&quot;: &quot;string&quot;&#125;&#125;&#125;, &quot;required&quot;: [&quot;foo&quot;]&#125;&#125;</span><br><span class="line">the object &#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125; is a well-formatted instance of the schema. The object &#123;&quot;properties&quot;: &#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125;&#125; is not well-formatted.</span><br><span class="line"></span><br><span class="line">Here is the output schema:</span><br><span class="line"></span><br><span class="line">&#123;&quot;properties&quot;: &#123;&quot;flower_type&quot;: &#123;&quot;title&quot;: &quot;Flower Type&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u79cd\u7c7b&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;price&quot;: &#123;&quot;title&quot;: &quot;Price&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u4ef7\u683c&quot;, &quot;type&quot;: &quot;integer&quot;&#125;, &quot;description&quot;: &#123;&quot;title&quot;: &quot;Description&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u63cf\u8ff0\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;reason&quot;: &#123;&quot;title&quot;: &quot;Reason&quot;, &quot;description&quot;: &quot;\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u5199\u8fd9\u4e2a\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;&#125;, &quot;required&quot;: [&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;]&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个输出，这部分是通过 output_parser.get_format_instructions() 方法生成的，这是 Pydantic (JSON) 解析器的核心价值，值得你好好研究研究。同时它也算得上是一个很清晰的提示模板，能够为模型提供良好的指导，描述了模型输出应该符合的格式。（其中 description 中的中文被转成了 UTF-8 编码。）</p>
<p>它指示模型输出 JSON Schema 的形式，定义了一个有效的输出应该包含哪些字段，以及这些字段的数据类型。例如，它指定了 <code>&quot;flower_type&quot;</code> 字段应该是字符串类型，<code>&quot;price&quot;</code> 字段应该是整数类型。这个指示中还提供了一个例子，说明了什么是一个格式良好的输出。</p>
<p>下面，我们会把这个内容也传输到模型的提示中，<strong>让输入模型的提示和输出解析器的要求相互吻合，前后就呼应得上</strong>。</p>
<h3 id="第四步：创建提示模板">第四步：创建提示模板</h3>
<p>我们定义了一个提示模板，该模板将用于为模型生成输入提示。模板中包含了你需要模型填充的变量（如价格和花的种类），以及之前获取的输出格式指示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ------Part 4</span><br><span class="line"># 创建提示模板</span><br><span class="line">from langchain import PromptTemplate</span><br><span class="line">prompt_template = &quot;&quot;&quot;您是一位专业的鲜花店文案撰写员。</span><br><span class="line">对于售价为 &#123;price&#125; 元的 &#123;flower&#125; ，您能提供一个吸引人的简短中文描述吗？</span><br><span class="line">&#123;format_instructions&#125;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 根据模板创建提示，同时在提示中加入输出解析器的说明</span><br><span class="line">prompt = PromptTemplate.from_template(prompt_template, </span><br><span class="line">       partial_variables=&#123;&quot;format_instructions&quot;: format_instructions&#125;) </span><br><span class="line"></span><br><span class="line"># 打印提示</span><br><span class="line">print(&quot;提示：&quot;, prompt)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">提示： </span><br><span class="line">input_variables=[&#x27;flower&#x27;, &#x27;price&#x27;] </span><br><span class="line"></span><br><span class="line">output_parser=None </span><br><span class="line"></span><br><span class="line">partial_variables=&#123;&#x27;format_instructions&#x27;: &#x27;The output should be formatted as a JSON instance that conforms to the JSON schema below.\n\n</span><br><span class="line">As an example, for the schema &#123;</span><br><span class="line">&quot;properties&quot;: &#123;&quot;foo&quot;: &#123;&quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;a list of strings&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123;&quot;type&quot;: &quot;string&quot;&#125;&#125;&#125;, </span><br><span class="line">&quot;required&quot;: [&quot;foo&quot;]&#125;&#125;\n</span><br><span class="line">the object &#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125; is a well-formatted instance of the schema. </span><br><span class="line">The object &#123;&quot;properties&quot;: &#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125;&#125; is not well-formatted.\n\n</span><br><span class="line">Here is the output schema:\n```\n</span><br><span class="line">&#123;&quot;properties&quot;: &#123;</span><br><span class="line">&quot;flower_type&quot;: &#123;&quot;title&quot;: &quot;Flower Type&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u79cd\\u7c7b&quot;, &quot;type&quot;: &quot;string&quot;&#125;, </span><br><span class="line">&quot;price&quot;: &#123;&quot;title&quot;: &quot;Price&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u4ef7\\u683c&quot;, &quot;type&quot;: &quot;integer&quot;&#125;, </span><br><span class="line">&quot;description&quot;: &#123;&quot;title&quot;: &quot;Description&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u63cf\\u8ff0\\u6587\\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;, </span><br><span class="line">&quot;reason&quot;: &#123;&quot;title&quot;: &quot;Reason&quot;, &quot;description&quot;: &quot;\\u4e3a\\u4ec0\\u4e48\\u8981\\u8fd9\\u6837\\u5199\\u8fd9\\u4e2a\\u6587\\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;&#125;, </span><br><span class="line">&quot;required&quot;: [&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;]&#125;\n```&#x27;&#125; </span><br><span class="line"></span><br><span class="line">template=&#x27;您是一位专业的鲜花店文案撰写员。</span><br><span class="line">\n对于售价为 &#123;price&#125; 元的 &#123;flower&#125; ，您能提供一个吸引人的简短中文描述吗？\n</span><br><span class="line">&#123;format_instructions&#125;&#x27; </span><br><span class="line"></span><br><span class="line">template_format=&#x27;f-string&#x27; </span><br><span class="line"></span><br><span class="line">validate_template=True</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是包含了 format_instructions 信息的提示模板。</p>
<ol>
<li class="lvl-4">
<p><code>input_variables=['flower', 'price']</code>：这是一个包含你想要在模板中使用的输入变量的列表。我们在模板中使用了 <code>'flower'</code> 和 <code>'price'</code> 两个变量，后面我们会用具体的值（如玫瑰、20 元）来替换这两个变量。</p>
</li>
<li class="lvl-4">
<p><code>output_parser=None</code>：这是你可以选择在模板中使用的一个输出解析器。在此例中，我们并没有选择在模板中使用输出解析器，而是在模型外部进行输出解析，所以这里是 <code>None</code>。</p>
</li>
<li class="lvl-4">
<p><code>partial_variables</code>：包含了你想要在模板中使用，但在生成模板时无法立即提供的变量。在这里，我们通过 <code>'format_instructions'</code> 传入输出格式的详细说明。</p>
</li>
<li class="lvl-4">
<p><code>template</code>：这是模板字符串本身。它包含了你想要模型生成的文本的结构。在此例中，模板字符串是你询问鲜花描述的问题，以及关于输出格式的说明。</p>
</li>
<li class="lvl-4">
<p><code>template_format='f-string'</code>：这是一个表示模板字符串格式的选项。此处是 f-string 格式。</p>
</li>
<li class="lvl-4">
<p><code>validate_template=True</code>：表示是否在创建模板时检查模板的有效性。这里选择了在创建模板时进行检查，以确保模板是有效的。</p>
</li>
</ol>
<p>总的来说，这个提示模板是一个用于生成模型输入的工具。你可以在模板中定义需要的输入变量，以及模板字符串的格式和结构，然后使用这个模板来为每种鲜花生成一个描述。</p>
<p>后面，我们还要把实际的信息，循环传入提示模板，生成一个个的具体提示。下面让我们继续。</p>
<h3 id="第五步：生成提示，传入模型并解析输出">第五步：生成提示，传入模型并解析输出</h3>
<p>这部分是程序的主体，我们循环来处理所有的花和它们的价格。对于每种花，都根据提示模板创建了输入，然后获取模型的输出。然后使用之前创建的解析器来解析这个输出，并将解析后的输出添加到 DataFrame 中。最后，你打印出了所有的结果，并且可以选择将其保存到 CSV 文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ------Part 5</span><br><span class="line">for flower, price in zip(flowers, prices):</span><br><span class="line">    # 根据提示准备模型的输入</span><br><span class="line">    input = prompt.format(flower=flower, price=price)</span><br><span class="line">    # 打印提示</span><br><span class="line">    print(&quot;提示：&quot;, input)</span><br><span class="line"></span><br><span class="line">    # 获取模型的输出</span><br><span class="line">    output = model(input)</span><br><span class="line"></span><br><span class="line">    # 解析模型的输出</span><br><span class="line">    parsed_output = output_parser.parse(output)</span><br><span class="line">    parsed_output_dict = parsed_output.dict()  # 将Pydantic格式转换为字典</span><br><span class="line"></span><br><span class="line">    # 将解析后的输出添加到DataFrame中</span><br><span class="line">    df.loc[len(df)] = parsed_output.dict()</span><br><span class="line"></span><br><span class="line"># 打印字典</span><br><span class="line">print(&quot;输出的数据：&quot;, df.to_dict(orient=&#x27;records&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一步中，你使用你的模型和输入提示（由鲜花种类和价格组成）生成了一个具体鲜花的文案需求（同时带有格式描述），然后传递给大模型，也就是说，提示模板中的 flower 和 price，此时都被具体的花取代了，而且模板中的 {format_instructions}，也被替换成了 JSON Schema 中指明的格式信息。</p>
<p>具体来说，输出的一个提示是这样的：</p>
<p><strong>提示</strong>： 您是一位专业的鲜花店文案撰写员。 对于售价为 20 元的 康乃馨 ，您能提供一个吸引人的简短中文描述吗？</p>
<p>The output should be formatted as a JSON instance that conforms to the JSON schema below.</p>
<p>As an example, for the schema {“properties”: {“foo”: {“title”: “Foo”, “description”: “a list of strings”, “type”: “array”, “items”: {“type”: “string”}}}, “required”: [“foo”]}}</p>
<p>the object {“foo”: [“bar”, “baz”]} is a well-formatted instance of the schema. The object {“properties”: {“foo”: [“bar”, “baz”]}} is not well-formatted.</p>
<p>Here is the output schema:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;properties&quot;: &#123;&quot;flower_type&quot;: &#123;&quot;title&quot;: &quot;Flower Type&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u79cd\u7c7b&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;price&quot;: &#123;&quot;title&quot;: &quot;Price&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u4ef7\u683c&quot;, &quot;type&quot;: &quot;integer&quot;&#125;, &quot;description&quot;: &#123;&quot;title&quot;: &quot;Description&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u63cf\u8ff0\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;reason&quot;: &#123;&quot;title&quot;: &quot;Reason&quot;, &quot;description&quot;: &quot;\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u5199\u8fd9\u4e2a\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;&#125;, &quot;required&quot;: [&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;]&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面，程序解析模型的输出。在这一步中，你使用你之前定义的输出解析器（output_parser）将模型的输出解析成了一个 FlowerDescription 的实例。FlowerDescription 是你之前定义的一个 Pydantic 类，它包含了鲜花的类型、价格、描述以及描述的理由。</p>
<p>然后，将解析后的输出添加到 DataFrame 中。在这一步中，你将解析后的输出（即 FlowerDescription 实例）转换为一个字典，并将这个字典添加到你的 DataFrame 中。这个 DataFrame 是你用来存储所有鲜花描述的。</p>
<p>模型的最后输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出的数据： </span><br><span class="line">[&#123;&#x27;flower_type&#x27;: &#x27;Rose&#x27;, &#x27;price&#x27;: 50, &#x27;description&#x27;: &#x27;玫瑰是最浪漫的花，它具有柔和的粉红色，有着浓浓的爱意，价格实惠，50元就可以拥有一束玫瑰。&#x27;, &#x27;reason&#x27;: &#x27;玫瑰代表着爱情，是最浪漫的礼物，以实惠的价格，可以让您尽情体验爱的浪漫。&#x27;&#125;, </span><br><span class="line">&#123;&#x27;flower_type&#x27;: &#x27;百合&#x27;, &#x27;price&#x27;: 30, &#x27;description&#x27;: &#x27;这支百合，柔美的花蕾，在你的手中摇曳，仿佛在与你深情的交谈&#x27;, &#x27;reason&#x27;: &#x27;营造浪漫氛围&#x27;&#125;, </span><br><span class="line">&#123;&#x27;flower_type&#x27;: &#x27;Carnation&#x27;, &#x27;price&#x27;: 20, &#x27;description&#x27;: &#x27;艳丽缤纷的康乃馨，带给你温馨、浪漫的气氛，是最佳的礼物选择！&#x27;, &#x27;reason&#x27;: &#x27;康乃馨是一种颜色鲜艳、芬芳淡雅、具有浪漫寓意的鲜花，非常适合作为礼物，而且20元的价格比较实惠。&#x27;&#125;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，Pydantic 的优点就是容易解析，而解析之后的字典格式的列表在进行数据分析、处理和存储时非常方便。每个字典代表一条记录，它的键（ 即 <code>&quot;flower_type&quot;</code>、<code>&quot;price&quot;</code>、<code>&quot;description&quot;</code> 和 <code>&quot;reason&quot;</code>）是字段名称，对应的值是这个字段的内容。这样一来，每个字段都对应一列，每个字典就是一行，适合以 DataFrame 的形式来表示和处理。</p>
<h2 id="自动修复解析器（OutputFixingParser）实战">自动修复解析器（OutputFixingParser）实战</h2>
<p>下面咱们来看看如何使用自动修复解析器。</p>
<p>首先，让我们来设计一个解析时出现的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 导入所需要的库和模块</span><br><span class="line">from langchain.output_parsers import PydanticOutputParser</span><br><span class="line">from pydantic import BaseModel, Field</span><br><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line"># 使用Pydantic创建一个数据格式，表示花</span><br><span class="line">class Flower(BaseModel):</span><br><span class="line">    name: str = Field(description=&quot;name of a flower&quot;)</span><br><span class="line">    colors: List[str] = Field(description=&quot;the colors of this flower&quot;)</span><br><span class="line"># 定义一个用于获取某种花的颜色列表的查询</span><br><span class="line">flower_query = &quot;Generate the charaters for a random flower.&quot;</span><br><span class="line"></span><br><span class="line"># 定义一个格式不正确的输出</span><br><span class="line">misformatted = &quot;&#123;&#x27;name&#x27;: &#x27;康乃馨&#x27;, &#x27;colors&#x27;: [&#x27;粉红色&#x27;,&#x27;白色&#x27;,&#x27;红色&#x27;,&#x27;紫色&#x27;,&#x27;黄色&#x27;]&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 创建一个用于解析输出的Pydantic解析器，此处希望解析为Flower格式</span><br><span class="line">parser = PydanticOutputParser(pydantic_object=Flower)</span><br><span class="line"># 使用Pydantic解析器解析不正确的输出</span><br><span class="line">parser.parse(misformatted)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码如果运行，会出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">langchain.schema.output_parser.OutputParserException: Failed to parse Flower from completion &#123;&#x27;name&#x27;: &#x27;康乃馨&#x27;, &#x27;colors&#x27;: [&#x27;粉红色&#x27;,&#x27;白色&#x27;]&#125;. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个错误消息来自 Python 的内建 JSON 解析器发现我们输入的 JSON 格式不正确。程序尝试用 PydanticOutputParser 来解析 JSON 字符串时，Python 期望属性名称被双引号包围，但在给定的 JSON 字符串中是单引号。</p>
<p>当这个错误被触发后，程序进一步引发了一个自定义异常：OutputParserException，它提供了更多关于错误的上下文。这个自定义异常的消息表示在尝试解析 flower 对象时遇到了问题。</p>
<p>刚才说了，问题在于 misformatted 字符串的内容：</p>
<p><code>&quot;&#123;'name': '康乃馨', 'colors': ['粉红色','白色','红色','紫色','黄色']&#125;&quot;</code></p>
<p>应该改为：</p>
<p><code>'&#123;&quot;name&quot;: &quot;康乃馨&quot;, &quot;colors&quot;: [&quot;粉红色&quot;,&quot;白色&quot;,&quot;红色&quot;,&quot;紫色&quot;,&quot;黄色&quot;]&#125;'</code></p>
<p>这样，你的 JSON 字符串就会使用正确的双引号格式，应该可以被正确地解析。</p>
<p>不过，这里我并不想这样解决问题，而是尝试使用 OutputFixingParser 来帮助咱们自动解决类似的格式错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 从langchain库导入所需的模块</span><br><span class="line">from langchain.chat_models import ChatOpenAI</span><br><span class="line">from langchain.output_parsers import OutputFixingParser</span><br><span class="line"></span><br><span class="line"># 设置OpenAI API密钥</span><br><span class="line">import os</span><br><span class="line">os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span><br><span class="line"></span><br><span class="line"># 使用OutputFixingParser创建一个新的解析器，该解析器能够纠正格式不正确的输出</span><br><span class="line">new_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())</span><br><span class="line"></span><br><span class="line"># 使用新的解析器解析不正确的输出</span><br><span class="line">result = new_parser.parse(misformatted) # 错误被自动修正</span><br><span class="line">print(result) # 打印解析后的输出结果</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用上面的新的 new_parser 来代替 Parser 进行解析，你会发现，JSON 格式的错误问题被解决了，程序不再出错。</p>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=&#x27;Rose&#x27; colors=[&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;white&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的秘密在于，在 OutputFixingParser 内部，调用了原有的 PydanticOutputParser，如果成功，就返回；如果失败，它会将格式错误的输出以及格式化的指令传递给大模型，并要求 LLM 进行相关的修复。</p>
<p>神奇吧，大模型不仅给我们提供知识，还随时帮助分析并解决程序出错的信息。</p>
<h2 id="重试解析器（RetryWithErrorOutputParser）实战">重试解析器（RetryWithErrorOutputParser）实战</h2>
<p>OutputFixingParser 不错，但它只能做简单的格式修复。如果出错的不只是格式，比如，输出根本不完整，有缺失内容，那么仅仅根据输出和格式本身，是无法修复它的。</p>
<p>此时，通过实现输出解析器中 parse_with_prompt 方法，LangChain 提供的重试解析器可以帮助我们利用大模型的推理能力根据原始提示找回相关信息。</p>
<p>我们通过分析一个重试解析器的用例来理解上面的这段话。</p>
<p>首先还是设计一个解析过程中的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个模板字符串，这个模板将用于生成提问</span><br><span class="line">template = &quot;&quot;&quot;Based on the user question, provide an Action and Action Input for what step should be taken.</span><br><span class="line">&#123;format_instructions&#125;</span><br><span class="line">Question: &#123;query&#125;</span><br><span class="line">Response:&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 定义一个Pydantic数据格式，它描述了一个&quot;行动&quot;类及其属性</span><br><span class="line">from pydantic import BaseModel, Field</span><br><span class="line">class Action(BaseModel):</span><br><span class="line">    action: str = Field(description=&quot;action to take&quot;)</span><br><span class="line">    action_input: str = Field(description=&quot;input to the action&quot;)</span><br><span class="line"></span><br><span class="line"># 使用Pydantic格式Action来初始化一个输出解析器</span><br><span class="line">from langchain.output_parsers import PydanticOutputParser</span><br><span class="line">parser = PydanticOutputParser(pydantic_object=Action)</span><br><span class="line"></span><br><span class="line"># 定义一个提示模板，它将用于向模型提问</span><br><span class="line">from langchain.prompts import PromptTemplate</span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=&quot;Answer the user query.\n&#123;format_instructions&#125;\n&#123;query&#125;\n&quot;,</span><br><span class="line">    input_variables=[&quot;query&quot;],</span><br><span class="line">    partial_variables=&#123;&quot;format_instructions&quot;: parser.get_format_instructions()&#125;,</span><br><span class="line">)</span><br><span class="line">prompt_value = prompt.format_prompt(query=&quot;What are the colors of Orchid?&quot;)</span><br><span class="line"></span><br><span class="line"># 定义一个错误格式的字符串</span><br><span class="line">bad_response = &#x27;&#123;&quot;action&quot;: &quot;search&quot;&#125;&#x27;</span><br><span class="line">parser.parse(bad_response) # 如果直接解析，它会引发一个错误</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于 bad_response 只提供了 action 字段，而没有提供 action_input 字段，这与 Action 数据格式的预期不符，所以解析会失败。</p>
<p>我们首先尝试用 OutputFixingParser 来解决这个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain.output_parsers import OutputFixingParser</span><br><span class="line">from langchain.chat_models import ChatOpenAI</span><br><span class="line">fix_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())</span><br><span class="line">parse_result = fix_parser.parse(bad_response)</span><br><span class="line">print(&#x27;OutputFixingParser的parse结果:&#x27;,parse_result)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OutputFixingParser 的 parse 结果：<code>action='search' action_input='query'</code></p>
<p>我们来看看这个尝试解决了什么问题，没解决什么问题。</p>
<p><strong>解决的问题有：</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>不完整的数据：原始的 bad_response 只提供了 action 字段而没有 action_input 字段。OutputFixingParser 已经填补了这个缺失，为 action_input 字段提供了值 <code>'query'</code>。</p>
</li>
</ul>
<p><strong>没解决的问题有：</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>具体性：尽管 OutputFixingParser 为 action_input 字段提供了默认值 <code>'query'</code>，但这并不具有描述性。真正的查询是 “Orchid（兰花）的颜色是什么？”。所以，这个修复只是提供了一个通用的值，并没有真正地回答用户的问题。</p>
</li>
<li class="lvl-4">
<p>可能的误导：<code>'query'</code> 可能被误解为一个指示，要求进一步查询某些内容，而不是作为实际的查询输入。</p>
</li>
</ul>
<p>当然，还有更鲁棒的选择，我们最后尝试一下 RetryWithErrorOutputParser 这个解析器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 初始化RetryWithErrorOutputParser，它会尝试再次提问来得到一个正确的输出</span><br><span class="line">from langchain.output_parsers import RetryWithErrorOutputParser</span><br><span class="line">from langchain.llms import OpenAI</span><br><span class="line">retry_parser = RetryWithErrorOutputParser.from_llm(</span><br><span class="line">    parser=parser, llm=OpenAI(temperature=0)</span><br><span class="line">)</span><br><span class="line">parse_result = retry_parser.parse_with_prompt(bad_response, prompt_value)</span><br><span class="line">print(&#x27;RetryWithErrorOutputParser的parse结果:&#x27;,parse_result)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个解析器没有让我们失望，成功地还原了格式，甚至也根据传入的原始提示，还原了 action_input 字段的内容。</p>
<p>RetryWithErrorOutputParser 的 parse 结果：<code>action='search' action_input='colors of Orchid'</code></p>
<h2 id="总结时刻">总结时刻</h2>
<p>结构化解析器和 Pydantic 解析器都旨在从大型语言模型中获取格式化的输出。结构化解析器更适合简单的文本响应，而 Pydantic 解析器则提供了对复杂数据结构和类型的支持。选择哪种解析器取决于应用的具体需求和输出的复杂性。</p>
<p>自动修复解析器主要适用于纠正小的格式错误，它更加 “被动”，仅在原始输出出现问题时进行修复。重试解析器则可以处理更复杂的问题，包括格式错误和内容缺失。它通过重新与模型交互，使得输出更加完整和符合预期。</p>
<p>在选择哪种解析器时，需要考虑具体的应用场景。如果仅面临格式问题，自动修复解析器可能足够；但如果输出的完整性和准确性至关重要，那么重试解析器可能是更好的选择。</p>
<h2 id="思考题">思考题</h2>
<ol>
<li class="lvl-4">
<p>到目前为止，我们已经使用了哪些 LangChain 输出解析器？请你说一说它们的用法和异同。同时也请你尝试使用其他类型的输出解析器，并把代码与大家分享。</p>
</li>
<li class="lvl-4">
<p>为什么大模型能够返回 JSON 格式的数据，输出解析器用了什么魔法让大模型做到了这一点？</p>
</li>
<li class="lvl-4">
<p>自动修复解析器的 “修复” 功能具体来说是怎样实现的？请做 debug，研究一下 LangChain 在调用大模型之前如何设计“提示”。</p>
</li>
<li class="lvl-4">
<p>重试解析器的原理是什么？它主要实现了解析器类的哪个可选方法？</p>
</li>
</ol>
<p>题目较多，可以选择性思考，期待在留言区看到你的分享。如果你觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p>
<h2 id="延伸阅读">延伸阅读</h2>
<ol>
<li class="lvl-4">
<p>工具：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.pydantic.dev%2Flatest%2F" title="https://docs.pydantic.dev/latest/">Pydantic</a> 是一个 Python 库，用于数据验证，可以确保数据符合特定的格式</p>
</li>
<li class="lvl-4">
<p>文档：LangChain 中的各种 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fpython.langchain.com%2Fdocs%2Fmodules%2Fmodel_io%2Foutput_parsers%2F" title="https://python.langchain.com/docs/modules/model_io/output_parsers/">Output Parsers</a></p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E4%BB%A3%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AReAct%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8E%A8%E7%90%86%E4%B8%8E%E8%A1%8C%E5%8A%A8%E7%9A%84%E5%8D%8F%E5%90%8C/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/08/%E7%BD%91%E9%A1%B5%E5%AF%BC%E5%85%A5/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%BD%BF%E7%94%A8OpenAI%20API%E8%BF%98%E6%98%AF%E5%BE%AE%E8%B0%83%E5%BC%80%E6%BA%90Llama2%E3%80%81ChatGLM%EF%BC%9F/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#LangChain-%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">LangChain 中的输出解析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pydantic%EF%BC%88JSON%EF%BC%89%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E6%88%98"><span class="nav-number">2.</span> <span class="nav-text">Pydantic（JSON）解析器实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.1.</span> <span class="nav-text">第一步：创建模型实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%B9%89%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">第二步：定义输出数据的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">第三步：创建输出解析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%8F%90%E7%A4%BA%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.4.</span> <span class="nav-text">第四步：创建提示模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E7%94%9F%E6%88%90%E6%8F%90%E7%A4%BA%EF%BC%8C%E4%BC%A0%E5%85%A5%E6%A8%A1%E5%9E%8B%E5%B9%B6%E8%A7%A3%E6%9E%90%E8%BE%93%E5%87%BA"><span class="nav-number">2.5.</span> <span class="nav-text">第五步：生成提示，传入模型并解析输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88OutputFixingParser%EF%BC%89%E5%AE%9E%E6%88%98"><span class="nav-number">3.</span> <span class="nav-text">自动修复解析器（OutputFixingParser）实战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%AF%95%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88RetryWithErrorOutputParser%EF%BC%89%E5%AE%9E%E6%88%98"><span class="nav-number">4.</span> <span class="nav-text">重试解析器（RetryWithErrorOutputParser）实战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E6%97%B6%E5%88%BB"><span class="nav-number">5.</span> <span class="nav-text">总结时刻</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="nav-number">7.</span> <span class="nav-text">延伸阅读</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">听</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">653</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">听</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
